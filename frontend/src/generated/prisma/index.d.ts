
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model JobPosting
 * 
 */
export type JobPosting = $Result.DefaultSelection<Prisma.$JobPostingPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model JobRequirement
 * 
 */
export type JobRequirement = $Result.DefaultSelection<Prisma.$JobRequirementPayload>
/**
 * Model CandidateProfile
 * 
 */
export type CandidateProfile = $Result.DefaultSelection<Prisma.$CandidateProfilePayload>
/**
 * Model Resume
 * 
 */
export type Resume = $Result.DefaultSelection<Prisma.$ResumePayload>
/**
 * Model ParsedResumeSkill
 * 
 */
export type ParsedResumeSkill = $Result.DefaultSelection<Prisma.$ParsedResumeSkillPayload>
/**
 * Model ResumeVsJdMatch
 * 
 */
export type ResumeVsJdMatch = $Result.DefaultSelection<Prisma.$ResumeVsJdMatchPayload>
/**
 * Model AiInterview
 * 
 */
export type AiInterview = $Result.DefaultSelection<Prisma.$AiInterviewPayload>
/**
 * Model AiInterviewQuestion
 * 
 */
export type AiInterviewQuestion = $Result.DefaultSelection<Prisma.$AiInterviewQuestionPayload>
/**
 * Model AiInterviewResponse
 * 
 */
export type AiInterviewResponse = $Result.DefaultSelection<Prisma.$AiInterviewResponsePayload>
/**
 * Model AiInterviewCheatingEvent
 * 
 */
export type AiInterviewCheatingEvent = $Result.DefaultSelection<Prisma.$AiInterviewCheatingEventPayload>
/**
 * Model AiInterviewPostureData
 * 
 */
export type AiInterviewPostureData = $Result.DefaultSelection<Prisma.$AiInterviewPostureDataPayload>
/**
 * Model AiVoicePrompt
 * 
 */
export type AiVoicePrompt = $Result.DefaultSelection<Prisma.$AiVoicePromptPayload>
/**
 * Model AiInterviewAnalysis
 * 
 */
export type AiInterviewAnalysis = $Result.DefaultSelection<Prisma.$AiInterviewAnalysisPayload>
/**
 * Model AiGenerationLog
 * 
 */
export type AiGenerationLog = $Result.DefaultSelection<Prisma.$AiGenerationLogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobPosting`: Exposes CRUD operations for the **JobPosting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPostings
    * const jobPostings = await prisma.jobPosting.findMany()
    * ```
    */
  get jobPosting(): Prisma.JobPostingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRequirement`: Exposes CRUD operations for the **JobRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRequirements
    * const jobRequirements = await prisma.jobRequirement.findMany()
    * ```
    */
  get jobRequirement(): Prisma.JobRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.candidateProfile`: Exposes CRUD operations for the **CandidateProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CandidateProfiles
    * const candidateProfiles = await prisma.candidateProfile.findMany()
    * ```
    */
  get candidateProfile(): Prisma.CandidateProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resumes
    * const resumes = await prisma.resume.findMany()
    * ```
    */
  get resume(): Prisma.ResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parsedResumeSkill`: Exposes CRUD operations for the **ParsedResumeSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParsedResumeSkills
    * const parsedResumeSkills = await prisma.parsedResumeSkill.findMany()
    * ```
    */
  get parsedResumeSkill(): Prisma.ParsedResumeSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resumeVsJdMatch`: Exposes CRUD operations for the **ResumeVsJdMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResumeVsJdMatches
    * const resumeVsJdMatches = await prisma.resumeVsJdMatch.findMany()
    * ```
    */
  get resumeVsJdMatch(): Prisma.ResumeVsJdMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterview`: Exposes CRUD operations for the **AiInterview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviews
    * const aiInterviews = await prisma.aiInterview.findMany()
    * ```
    */
  get aiInterview(): Prisma.AiInterviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterviewQuestion`: Exposes CRUD operations for the **AiInterviewQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviewQuestions
    * const aiInterviewQuestions = await prisma.aiInterviewQuestion.findMany()
    * ```
    */
  get aiInterviewQuestion(): Prisma.AiInterviewQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterviewResponse`: Exposes CRUD operations for the **AiInterviewResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviewResponses
    * const aiInterviewResponses = await prisma.aiInterviewResponse.findMany()
    * ```
    */
  get aiInterviewResponse(): Prisma.AiInterviewResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterviewCheatingEvent`: Exposes CRUD operations for the **AiInterviewCheatingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviewCheatingEvents
    * const aiInterviewCheatingEvents = await prisma.aiInterviewCheatingEvent.findMany()
    * ```
    */
  get aiInterviewCheatingEvent(): Prisma.AiInterviewCheatingEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterviewPostureData`: Exposes CRUD operations for the **AiInterviewPostureData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviewPostureData
    * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findMany()
    * ```
    */
  get aiInterviewPostureData(): Prisma.AiInterviewPostureDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiVoicePrompt`: Exposes CRUD operations for the **AiVoicePrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiVoicePrompts
    * const aiVoicePrompts = await prisma.aiVoicePrompt.findMany()
    * ```
    */
  get aiVoicePrompt(): Prisma.AiVoicePromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiInterviewAnalysis`: Exposes CRUD operations for the **AiInterviewAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiInterviewAnalyses
    * const aiInterviewAnalyses = await prisma.aiInterviewAnalysis.findMany()
    * ```
    */
  get aiInterviewAnalysis(): Prisma.AiInterviewAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiGenerationLog`: Exposes CRUD operations for the **AiGenerationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiGenerationLogs
    * const aiGenerationLogs = await prisma.aiGenerationLog.findMany()
    * ```
    */
  get aiGenerationLog(): Prisma.AiGenerationLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Company: 'Company',
    JobPosting: 'JobPosting',
    Skill: 'Skill',
    JobRequirement: 'JobRequirement',
    CandidateProfile: 'CandidateProfile',
    Resume: 'Resume',
    ParsedResumeSkill: 'ParsedResumeSkill',
    ResumeVsJdMatch: 'ResumeVsJdMatch',
    AiInterview: 'AiInterview',
    AiInterviewQuestion: 'AiInterviewQuestion',
    AiInterviewResponse: 'AiInterviewResponse',
    AiInterviewCheatingEvent: 'AiInterviewCheatingEvent',
    AiInterviewPostureData: 'AiInterviewPostureData',
    AiVoicePrompt: 'AiVoicePrompt',
    AiInterviewAnalysis: 'AiInterviewAnalysis',
    AiGenerationLog: 'AiGenerationLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "company" | "jobPosting" | "skill" | "jobRequirement" | "candidateProfile" | "resume" | "parsedResumeSkill" | "resumeVsJdMatch" | "aiInterview" | "aiInterviewQuestion" | "aiInterviewResponse" | "aiInterviewCheatingEvent" | "aiInterviewPostureData" | "aiVoicePrompt" | "aiInterviewAnalysis" | "aiGenerationLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      JobPosting: {
        payload: Prisma.$JobPostingPayload<ExtArgs>
        fields: Prisma.JobPostingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobPostingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobPostingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          findFirst: {
            args: Prisma.JobPostingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobPostingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          findMany: {
            args: Prisma.JobPostingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          create: {
            args: Prisma.JobPostingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          createMany: {
            args: Prisma.JobPostingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobPostingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          delete: {
            args: Prisma.JobPostingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          update: {
            args: Prisma.JobPostingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          deleteMany: {
            args: Prisma.JobPostingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobPostingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobPostingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>[]
          }
          upsert: {
            args: Prisma.JobPostingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPostingPayload>
          }
          aggregate: {
            args: Prisma.JobPostingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobPosting>
          }
          groupBy: {
            args: Prisma.JobPostingGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobPostingGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobPostingCountArgs<ExtArgs>
            result: $Utils.Optional<JobPostingCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      JobRequirement: {
        payload: Prisma.$JobRequirementPayload<ExtArgs>
        fields: Prisma.JobRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          findFirst: {
            args: Prisma.JobRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          findMany: {
            args: Prisma.JobRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>[]
          }
          create: {
            args: Prisma.JobRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          createMany: {
            args: Prisma.JobRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>[]
          }
          delete: {
            args: Prisma.JobRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          update: {
            args: Prisma.JobRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          deleteMany: {
            args: Prisma.JobRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobRequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>[]
          }
          upsert: {
            args: Prisma.JobRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRequirementPayload>
          }
          aggregate: {
            args: Prisma.JobRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRequirement>
          }
          groupBy: {
            args: Prisma.JobRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<JobRequirementCountAggregateOutputType> | number
          }
        }
      }
      CandidateProfile: {
        payload: Prisma.$CandidateProfilePayload<ExtArgs>
        fields: Prisma.CandidateProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidateProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidateProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          findFirst: {
            args: Prisma.CandidateProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidateProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          findMany: {
            args: Prisma.CandidateProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>[]
          }
          create: {
            args: Prisma.CandidateProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          createMany: {
            args: Prisma.CandidateProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidateProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>[]
          }
          delete: {
            args: Prisma.CandidateProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          update: {
            args: Prisma.CandidateProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          deleteMany: {
            args: Prisma.CandidateProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidateProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CandidateProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>[]
          }
          upsert: {
            args: Prisma.CandidateProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidateProfilePayload>
          }
          aggregate: {
            args: Prisma.CandidateProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidateProfile>
          }
          groupBy: {
            args: Prisma.CandidateProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidateProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidateProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CandidateProfileCountAggregateOutputType> | number
          }
        }
      }
      Resume: {
        payload: Prisma.$ResumePayload<ExtArgs>
        fields: Prisma.ResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findFirst: {
            args: Prisma.ResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findMany: {
            args: Prisma.ResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          create: {
            args: Prisma.ResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          createMany: {
            args: Prisma.ResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          delete: {
            args: Prisma.ResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          update: {
            args: Prisma.ResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          deleteMany: {
            args: Prisma.ResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          upsert: {
            args: Prisma.ResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          aggregate: {
            args: Prisma.ResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResume>
          }
          groupBy: {
            args: Prisma.ResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeCountAggregateOutputType> | number
          }
        }
      }
      ParsedResumeSkill: {
        payload: Prisma.$ParsedResumeSkillPayload<ExtArgs>
        fields: Prisma.ParsedResumeSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParsedResumeSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParsedResumeSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          findFirst: {
            args: Prisma.ParsedResumeSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParsedResumeSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          findMany: {
            args: Prisma.ParsedResumeSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>[]
          }
          create: {
            args: Prisma.ParsedResumeSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          createMany: {
            args: Prisma.ParsedResumeSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParsedResumeSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>[]
          }
          delete: {
            args: Prisma.ParsedResumeSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          update: {
            args: Prisma.ParsedResumeSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          deleteMany: {
            args: Prisma.ParsedResumeSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParsedResumeSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParsedResumeSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>[]
          }
          upsert: {
            args: Prisma.ParsedResumeSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParsedResumeSkillPayload>
          }
          aggregate: {
            args: Prisma.ParsedResumeSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParsedResumeSkill>
          }
          groupBy: {
            args: Prisma.ParsedResumeSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParsedResumeSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParsedResumeSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ParsedResumeSkillCountAggregateOutputType> | number
          }
        }
      }
      ResumeVsJdMatch: {
        payload: Prisma.$ResumeVsJdMatchPayload<ExtArgs>
        fields: Prisma.ResumeVsJdMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeVsJdMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeVsJdMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          findFirst: {
            args: Prisma.ResumeVsJdMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeVsJdMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          findMany: {
            args: Prisma.ResumeVsJdMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>[]
          }
          create: {
            args: Prisma.ResumeVsJdMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          createMany: {
            args: Prisma.ResumeVsJdMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeVsJdMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>[]
          }
          delete: {
            args: Prisma.ResumeVsJdMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          update: {
            args: Prisma.ResumeVsJdMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          deleteMany: {
            args: Prisma.ResumeVsJdMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeVsJdMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeVsJdMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>[]
          }
          upsert: {
            args: Prisma.ResumeVsJdMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumeVsJdMatchPayload>
          }
          aggregate: {
            args: Prisma.ResumeVsJdMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResumeVsJdMatch>
          }
          groupBy: {
            args: Prisma.ResumeVsJdMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeVsJdMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeVsJdMatchCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeVsJdMatchCountAggregateOutputType> | number
          }
        }
      }
      AiInterview: {
        payload: Prisma.$AiInterviewPayload<ExtArgs>
        fields: Prisma.AiInterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          findFirst: {
            args: Prisma.AiInterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          findMany: {
            args: Prisma.AiInterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>[]
          }
          create: {
            args: Prisma.AiInterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          createMany: {
            args: Prisma.AiInterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>[]
          }
          delete: {
            args: Prisma.AiInterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          update: {
            args: Prisma.AiInterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPayload>
          }
          aggregate: {
            args: Prisma.AiInterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterview>
          }
          groupBy: {
            args: Prisma.AiInterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewCountAggregateOutputType> | number
          }
        }
      }
      AiInterviewQuestion: {
        payload: Prisma.$AiInterviewQuestionPayload<ExtArgs>
        fields: Prisma.AiInterviewQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          findFirst: {
            args: Prisma.AiInterviewQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          findMany: {
            args: Prisma.AiInterviewQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>[]
          }
          create: {
            args: Prisma.AiInterviewQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          createMany: {
            args: Prisma.AiInterviewQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>[]
          }
          delete: {
            args: Prisma.AiInterviewQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          update: {
            args: Prisma.AiInterviewQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewQuestionPayload>
          }
          aggregate: {
            args: Prisma.AiInterviewQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterviewQuestion>
          }
          groupBy: {
            args: Prisma.AiInterviewQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewQuestionCountAggregateOutputType> | number
          }
        }
      }
      AiInterviewResponse: {
        payload: Prisma.$AiInterviewResponsePayload<ExtArgs>
        fields: Prisma.AiInterviewResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          findFirst: {
            args: Prisma.AiInterviewResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          findMany: {
            args: Prisma.AiInterviewResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>[]
          }
          create: {
            args: Prisma.AiInterviewResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          createMany: {
            args: Prisma.AiInterviewResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>[]
          }
          delete: {
            args: Prisma.AiInterviewResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          update: {
            args: Prisma.AiInterviewResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewResponsePayload>
          }
          aggregate: {
            args: Prisma.AiInterviewResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterviewResponse>
          }
          groupBy: {
            args: Prisma.AiInterviewResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewResponseCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewResponseCountAggregateOutputType> | number
          }
        }
      }
      AiInterviewCheatingEvent: {
        payload: Prisma.$AiInterviewCheatingEventPayload<ExtArgs>
        fields: Prisma.AiInterviewCheatingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewCheatingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewCheatingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          findFirst: {
            args: Prisma.AiInterviewCheatingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewCheatingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          findMany: {
            args: Prisma.AiInterviewCheatingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>[]
          }
          create: {
            args: Prisma.AiInterviewCheatingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          createMany: {
            args: Prisma.AiInterviewCheatingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewCheatingEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>[]
          }
          delete: {
            args: Prisma.AiInterviewCheatingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          update: {
            args: Prisma.AiInterviewCheatingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewCheatingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewCheatingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewCheatingEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewCheatingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewCheatingEventPayload>
          }
          aggregate: {
            args: Prisma.AiInterviewCheatingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterviewCheatingEvent>
          }
          groupBy: {
            args: Prisma.AiInterviewCheatingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewCheatingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewCheatingEventCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewCheatingEventCountAggregateOutputType> | number
          }
        }
      }
      AiInterviewPostureData: {
        payload: Prisma.$AiInterviewPostureDataPayload<ExtArgs>
        fields: Prisma.AiInterviewPostureDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewPostureDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewPostureDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          findFirst: {
            args: Prisma.AiInterviewPostureDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewPostureDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          findMany: {
            args: Prisma.AiInterviewPostureDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>[]
          }
          create: {
            args: Prisma.AiInterviewPostureDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          createMany: {
            args: Prisma.AiInterviewPostureDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewPostureDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>[]
          }
          delete: {
            args: Prisma.AiInterviewPostureDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          update: {
            args: Prisma.AiInterviewPostureDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewPostureDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewPostureDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewPostureDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewPostureDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewPostureDataPayload>
          }
          aggregate: {
            args: Prisma.AiInterviewPostureDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterviewPostureData>
          }
          groupBy: {
            args: Prisma.AiInterviewPostureDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewPostureDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewPostureDataCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewPostureDataCountAggregateOutputType> | number
          }
        }
      }
      AiVoicePrompt: {
        payload: Prisma.$AiVoicePromptPayload<ExtArgs>
        fields: Prisma.AiVoicePromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiVoicePromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiVoicePromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          findFirst: {
            args: Prisma.AiVoicePromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiVoicePromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          findMany: {
            args: Prisma.AiVoicePromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>[]
          }
          create: {
            args: Prisma.AiVoicePromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          createMany: {
            args: Prisma.AiVoicePromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiVoicePromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>[]
          }
          delete: {
            args: Prisma.AiVoicePromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          update: {
            args: Prisma.AiVoicePromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          deleteMany: {
            args: Prisma.AiVoicePromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiVoicePromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiVoicePromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>[]
          }
          upsert: {
            args: Prisma.AiVoicePromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiVoicePromptPayload>
          }
          aggregate: {
            args: Prisma.AiVoicePromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiVoicePrompt>
          }
          groupBy: {
            args: Prisma.AiVoicePromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiVoicePromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiVoicePromptCountArgs<ExtArgs>
            result: $Utils.Optional<AiVoicePromptCountAggregateOutputType> | number
          }
        }
      }
      AiInterviewAnalysis: {
        payload: Prisma.$AiInterviewAnalysisPayload<ExtArgs>
        fields: Prisma.AiInterviewAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiInterviewAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiInterviewAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          findFirst: {
            args: Prisma.AiInterviewAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiInterviewAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          findMany: {
            args: Prisma.AiInterviewAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>[]
          }
          create: {
            args: Prisma.AiInterviewAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          createMany: {
            args: Prisma.AiInterviewAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiInterviewAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>[]
          }
          delete: {
            args: Prisma.AiInterviewAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          update: {
            args: Prisma.AiInterviewAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.AiInterviewAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiInterviewAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiInterviewAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.AiInterviewAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiInterviewAnalysisPayload>
          }
          aggregate: {
            args: Prisma.AiInterviewAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiInterviewAnalysis>
          }
          groupBy: {
            args: Prisma.AiInterviewAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiInterviewAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<AiInterviewAnalysisCountAggregateOutputType> | number
          }
        }
      }
      AiGenerationLog: {
        payload: Prisma.$AiGenerationLogPayload<ExtArgs>
        fields: Prisma.AiGenerationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiGenerationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiGenerationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          findFirst: {
            args: Prisma.AiGenerationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiGenerationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          findMany: {
            args: Prisma.AiGenerationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>[]
          }
          create: {
            args: Prisma.AiGenerationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          createMany: {
            args: Prisma.AiGenerationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiGenerationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>[]
          }
          delete: {
            args: Prisma.AiGenerationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          update: {
            args: Prisma.AiGenerationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          deleteMany: {
            args: Prisma.AiGenerationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiGenerationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiGenerationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>[]
          }
          upsert: {
            args: Prisma.AiGenerationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGenerationLogPayload>
          }
          aggregate: {
            args: Prisma.AiGenerationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiGenerationLog>
          }
          groupBy: {
            args: Prisma.AiGenerationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiGenerationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiGenerationLogCountArgs<ExtArgs>
            result: $Utils.Optional<AiGenerationLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    company?: CompanyOmit
    jobPosting?: JobPostingOmit
    skill?: SkillOmit
    jobRequirement?: JobRequirementOmit
    candidateProfile?: CandidateProfileOmit
    resume?: ResumeOmit
    parsedResumeSkill?: ParsedResumeSkillOmit
    resumeVsJdMatch?: ResumeVsJdMatchOmit
    aiInterview?: AiInterviewOmit
    aiInterviewQuestion?: AiInterviewQuestionOmit
    aiInterviewResponse?: AiInterviewResponseOmit
    aiInterviewCheatingEvent?: AiInterviewCheatingEventOmit
    aiInterviewPostureData?: AiInterviewPostureDataOmit
    aiVoicePrompt?: AiVoicePromptOmit
    aiInterviewAnalysis?: AiInterviewAnalysisOmit
    aiGenerationLog?: AiGenerationLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ai_generation_logs: number
    roles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_generation_logs?: boolean | UserCountOutputTypeCountAi_generation_logsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAi_generation_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGenerationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    job_postings: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_postings?: boolean | CompanyCountOutputTypeCountJob_postingsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJob_postingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingWhereInput
  }


  /**
   * Count Type JobPostingCountOutputType
   */

  export type JobPostingCountOutputType = {
    interviews: number
    requirements: number
    matches: number
  }

  export type JobPostingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviews?: boolean | JobPostingCountOutputTypeCountInterviewsArgs
    requirements?: boolean | JobPostingCountOutputTypeCountRequirementsArgs
    matches?: boolean | JobPostingCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPostingCountOutputType
     */
    select?: JobPostingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRequirementWhereInput
  }

  /**
   * JobPostingCountOutputType without action
   */
  export type JobPostingCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeVsJdMatchWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    job_requirements: number
    parsed_resume_skills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_requirements?: boolean | SkillCountOutputTypeCountJob_requirementsArgs
    parsed_resume_skills?: boolean | SkillCountOutputTypeCountParsed_resume_skillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountJob_requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRequirementWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountParsed_resume_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedResumeSkillWhereInput
  }


  /**
   * Count Type CandidateProfileCountOutputType
   */

  export type CandidateProfileCountOutputType = {
    interviews: number
    resumes: number
  }

  export type CandidateProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviews?: boolean | CandidateProfileCountOutputTypeCountInterviewsArgs
    resumes?: boolean | CandidateProfileCountOutputTypeCountResumesArgs
  }

  // Custom InputTypes
  /**
   * CandidateProfileCountOutputType without action
   */
  export type CandidateProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfileCountOutputType
     */
    select?: CandidateProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CandidateProfileCountOutputType without action
   */
  export type CandidateProfileCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewWhereInput
  }

  /**
   * CandidateProfileCountOutputType without action
   */
  export type CandidateProfileCountOutputTypeCountResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
  }


  /**
   * Count Type ResumeCountOutputType
   */

  export type ResumeCountOutputType = {
    parsed_resume_skills: number
    matches: number
  }

  export type ResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsed_resume_skills?: boolean | ResumeCountOutputTypeCountParsed_resume_skillsArgs
    matches?: boolean | ResumeCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCountOutputType
     */
    select?: ResumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountParsed_resume_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedResumeSkillWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeVsJdMatchWhereInput
  }


  /**
   * Count Type AiInterviewCountOutputType
   */

  export type AiInterviewCountOutputType = {
    cheating_events: number
    posture_data: number
    questions: number
    responses: number
    voice_prompts: number
  }

  export type AiInterviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cheating_events?: boolean | AiInterviewCountOutputTypeCountCheating_eventsArgs
    posture_data?: boolean | AiInterviewCountOutputTypeCountPosture_dataArgs
    questions?: boolean | AiInterviewCountOutputTypeCountQuestionsArgs
    responses?: boolean | AiInterviewCountOutputTypeCountResponsesArgs
    voice_prompts?: boolean | AiInterviewCountOutputTypeCountVoice_promptsArgs
  }

  // Custom InputTypes
  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCountOutputType
     */
    select?: AiInterviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeCountCheating_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewCheatingEventWhereInput
  }

  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeCountPosture_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewPostureDataWhereInput
  }

  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewQuestionWhereInput
  }

  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewResponseWhereInput
  }

  /**
   * AiInterviewCountOutputType without action
   */
  export type AiInterviewCountOutputTypeCountVoice_promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiVoicePromptWhereInput
  }


  /**
   * Count Type AiInterviewQuestionCountOutputType
   */

  export type AiInterviewQuestionCountOutputType = {
    responses: number
  }

  export type AiInterviewQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | AiInterviewQuestionCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * AiInterviewQuestionCountOutputType without action
   */
  export type AiInterviewQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestionCountOutputType
     */
    select?: AiInterviewQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiInterviewQuestionCountOutputType without action
   */
  export type AiInterviewQuestionCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewResponseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    phone: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    name: number
    email: number
    password_hash: number
    phone: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    password_hash?: true
    phone?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    name: string | null
    email: string
    password_hash: string
    phone: string | null
    created_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    created_at?: boolean
    ai_generation_logs?: boolean | User$ai_generation_logsArgs<ExtArgs>
    CandidateProfile?: boolean | User$CandidateProfileArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    user_id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    phone?: boolean
    created_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "name" | "email" | "password_hash" | "phone" | "created_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ai_generation_logs?: boolean | User$ai_generation_logsArgs<ExtArgs>
    CandidateProfile?: boolean | User$CandidateProfileArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ai_generation_logs: Prisma.$AiGenerationLogPayload<ExtArgs>[]
      CandidateProfile: Prisma.$CandidateProfilePayload<ExtArgs> | null
      roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      name: string | null
      email: string
      password_hash: string
      phone: string | null
      created_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ai_generation_logs<T extends User$ai_generation_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$ai_generation_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CandidateProfile<T extends User$CandidateProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$CandidateProfileArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly user_id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ai_generation_logs
   */
  export type User$ai_generation_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    where?: AiGenerationLogWhereInput
    orderBy?: AiGenerationLogOrderByWithRelationInput | AiGenerationLogOrderByWithRelationInput[]
    cursor?: AiGenerationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiGenerationLogScalarFieldEnum | AiGenerationLogScalarFieldEnum[]
  }

  /**
   * User.CandidateProfile
   */
  export type User$CandidateProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    where?: CandidateProfileWhereInput
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RoleSumAggregateOutputType = {
    role_id: number | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    role_name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    role_id?: true
  }

  export type RoleSumAggregateInputType = {
    role_id?: true
  }

  export type RoleMinAggregateInputType = {
    role_id?: true
    role_name?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: number
    role_name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "role_name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly role_id: FieldRef<"Role", 'Int'>
    readonly role_name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    user_id: number
    role_id: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserRoleSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserRoleMinAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserRoleMaxAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserRoleCountAggregateInputType = {
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    user_id: number
    role_id: number
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    user_id?: boolean
    role_id?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "role_id", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      role_id: number
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userRoleWithUser_idOnly = await prisma.userRole.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `user_id`
     * const userRoleWithUser_idOnly = await prisma.userRole.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `user_id`
     * const userRoleWithUser_idOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly user_id: FieldRef<"UserRole", 'Int'>
    readonly role_id: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    company_id: number | null
  }

  export type CompanySumAggregateOutputType = {
    company_id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    company_id: number | null
    name: string | null
    website: string | null
    created_at: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    company_id: number | null
    name: string | null
    website: string | null
    created_at: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    company_id: number
    name: number
    website: number
    created_at: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    company_id?: true
  }

  export type CompanySumAggregateInputType = {
    company_id?: true
  }

  export type CompanyMinAggregateInputType = {
    company_id?: true
    name?: true
    website?: true
    created_at?: true
  }

  export type CompanyMaxAggregateInputType = {
    company_id?: true
    name?: true
    website?: true
    created_at?: true
  }

  export type CompanyCountAggregateInputType = {
    company_id?: true
    name?: true
    website?: true
    created_at?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    company_id: number
    name: string | null
    website: string | null
    created_at: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
    job_postings?: boolean | Company$job_postingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    company_id?: boolean
    name?: boolean
    website?: boolean
    created_at?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"company_id" | "name" | "website" | "created_at", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_postings?: boolean | Company$job_postingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      job_postings: Prisma.$JobPostingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      company_id: number
      name: string | null
      website: string | null
      created_at: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.findMany({ select: { company_id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.createManyAndReturn({
     *   select: { company_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.updateManyAndReturn({
     *   select: { company_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_postings<T extends Company$job_postingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$job_postingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly company_id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly created_at: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data?: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.job_postings
   */
  export type Company$job_postingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    where?: JobPostingWhereInput
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    cursor?: JobPostingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model JobPosting
   */

  export type AggregateJobPosting = {
    _count: JobPostingCountAggregateOutputType | null
    _avg: JobPostingAvgAggregateOutputType | null
    _sum: JobPostingSumAggregateOutputType | null
    _min: JobPostingMinAggregateOutputType | null
    _max: JobPostingMaxAggregateOutputType | null
  }

  export type JobPostingAvgAggregateOutputType = {
    job_id: number | null
    company_id: number | null
  }

  export type JobPostingSumAggregateOutputType = {
    job_id: number | null
    company_id: number | null
  }

  export type JobPostingMinAggregateOutputType = {
    job_id: number | null
    company_id: number | null
    title: string | null
    description: string | null
    location: string | null
    posted_at: Date | null
  }

  export type JobPostingMaxAggregateOutputType = {
    job_id: number | null
    company_id: number | null
    title: string | null
    description: string | null
    location: string | null
    posted_at: Date | null
  }

  export type JobPostingCountAggregateOutputType = {
    job_id: number
    company_id: number
    title: number
    description: number
    location: number
    posted_at: number
    _all: number
  }


  export type JobPostingAvgAggregateInputType = {
    job_id?: true
    company_id?: true
  }

  export type JobPostingSumAggregateInputType = {
    job_id?: true
    company_id?: true
  }

  export type JobPostingMinAggregateInputType = {
    job_id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    posted_at?: true
  }

  export type JobPostingMaxAggregateInputType = {
    job_id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    posted_at?: true
  }

  export type JobPostingCountAggregateInputType = {
    job_id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    posted_at?: true
    _all?: true
  }

  export type JobPostingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPosting to aggregate.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPostings
    **/
    _count?: true | JobPostingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobPostingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobPostingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostingMaxAggregateInputType
  }

  export type GetJobPostingAggregateType<T extends JobPostingAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPosting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPosting[P]>
      : GetScalarType<T[P], AggregateJobPosting[P]>
  }




  export type JobPostingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobPostingWhereInput
    orderBy?: JobPostingOrderByWithAggregationInput | JobPostingOrderByWithAggregationInput[]
    by: JobPostingScalarFieldEnum[] | JobPostingScalarFieldEnum
    having?: JobPostingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostingCountAggregateInputType | true
    _avg?: JobPostingAvgAggregateInputType
    _sum?: JobPostingSumAggregateInputType
    _min?: JobPostingMinAggregateInputType
    _max?: JobPostingMaxAggregateInputType
  }

  export type JobPostingGroupByOutputType = {
    job_id: number
    company_id: number
    title: string | null
    description: string | null
    location: string | null
    posted_at: Date | null
    _count: JobPostingCountAggregateOutputType | null
    _avg: JobPostingAvgAggregateOutputType | null
    _sum: JobPostingSumAggregateOutputType | null
    _min: JobPostingMinAggregateOutputType | null
    _max: JobPostingMaxAggregateOutputType | null
  }

  type GetJobPostingGroupByPayload<T extends JobPostingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobPostingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostingGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostingGroupByOutputType[P]>
        }
      >
    >


  export type JobPostingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    posted_at?: boolean
    interviews?: boolean | JobPosting$interviewsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    requirements?: boolean | JobPosting$requirementsArgs<ExtArgs>
    matches?: boolean | JobPosting$matchesArgs<ExtArgs>
    _count?: boolean | JobPostingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    posted_at?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    posted_at?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobPosting"]>

  export type JobPostingSelectScalar = {
    job_id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    posted_at?: boolean
  }

  export type JobPostingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_id" | "company_id" | "title" | "description" | "location" | "posted_at", ExtArgs["result"]["jobPosting"]>
  export type JobPostingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviews?: boolean | JobPosting$interviewsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    requirements?: boolean | JobPosting$requirementsArgs<ExtArgs>
    matches?: boolean | JobPosting$matchesArgs<ExtArgs>
    _count?: boolean | JobPostingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobPostingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type JobPostingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $JobPostingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobPosting"
    objects: {
      interviews: Prisma.$AiInterviewPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      requirements: Prisma.$JobRequirementPayload<ExtArgs>[]
      matches: Prisma.$ResumeVsJdMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_id: number
      company_id: number
      title: string | null
      description: string | null
      location: string | null
      posted_at: Date | null
    }, ExtArgs["result"]["jobPosting"]>
    composites: {}
  }

  type JobPostingGetPayload<S extends boolean | null | undefined | JobPostingDefaultArgs> = $Result.GetResult<Prisma.$JobPostingPayload, S>

  type JobPostingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobPostingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobPostingCountAggregateInputType | true
    }

  export interface JobPostingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobPosting'], meta: { name: 'JobPosting' } }
    /**
     * Find zero or one JobPosting that matches the filter.
     * @param {JobPostingFindUniqueArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobPostingFindUniqueArgs>(args: SelectSubset<T, JobPostingFindUniqueArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobPosting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobPostingFindUniqueOrThrowArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobPostingFindUniqueOrThrowArgs>(args: SelectSubset<T, JobPostingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPosting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindFirstArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobPostingFindFirstArgs>(args?: SelectSubset<T, JobPostingFindFirstArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobPosting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindFirstOrThrowArgs} args - Arguments to find a JobPosting
     * @example
     * // Get one JobPosting
     * const jobPosting = await prisma.jobPosting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobPostingFindFirstOrThrowArgs>(args?: SelectSubset<T, JobPostingFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobPostings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPostings
     * const jobPostings = await prisma.jobPosting.findMany()
     * 
     * // Get first 10 JobPostings
     * const jobPostings = await prisma.jobPosting.findMany({ take: 10 })
     * 
     * // Only select the `job_id`
     * const jobPostingWithJob_idOnly = await prisma.jobPosting.findMany({ select: { job_id: true } })
     * 
     */
    findMany<T extends JobPostingFindManyArgs>(args?: SelectSubset<T, JobPostingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobPosting.
     * @param {JobPostingCreateArgs} args - Arguments to create a JobPosting.
     * @example
     * // Create one JobPosting
     * const JobPosting = await prisma.jobPosting.create({
     *   data: {
     *     // ... data to create a JobPosting
     *   }
     * })
     * 
     */
    create<T extends JobPostingCreateArgs>(args: SelectSubset<T, JobPostingCreateArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobPostings.
     * @param {JobPostingCreateManyArgs} args - Arguments to create many JobPostings.
     * @example
     * // Create many JobPostings
     * const jobPosting = await prisma.jobPosting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobPostingCreateManyArgs>(args?: SelectSubset<T, JobPostingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobPostings and returns the data saved in the database.
     * @param {JobPostingCreateManyAndReturnArgs} args - Arguments to create many JobPostings.
     * @example
     * // Create many JobPostings
     * const jobPosting = await prisma.jobPosting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobPostings and only return the `job_id`
     * const jobPostingWithJob_idOnly = await prisma.jobPosting.createManyAndReturn({
     *   select: { job_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobPostingCreateManyAndReturnArgs>(args?: SelectSubset<T, JobPostingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobPosting.
     * @param {JobPostingDeleteArgs} args - Arguments to delete one JobPosting.
     * @example
     * // Delete one JobPosting
     * const JobPosting = await prisma.jobPosting.delete({
     *   where: {
     *     // ... filter to delete one JobPosting
     *   }
     * })
     * 
     */
    delete<T extends JobPostingDeleteArgs>(args: SelectSubset<T, JobPostingDeleteArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobPosting.
     * @param {JobPostingUpdateArgs} args - Arguments to update one JobPosting.
     * @example
     * // Update one JobPosting
     * const jobPosting = await prisma.jobPosting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobPostingUpdateArgs>(args: SelectSubset<T, JobPostingUpdateArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobPostings.
     * @param {JobPostingDeleteManyArgs} args - Arguments to filter JobPostings to delete.
     * @example
     * // Delete a few JobPostings
     * const { count } = await prisma.jobPosting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobPostingDeleteManyArgs>(args?: SelectSubset<T, JobPostingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPostings
     * const jobPosting = await prisma.jobPosting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobPostingUpdateManyArgs>(args: SelectSubset<T, JobPostingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPostings and returns the data updated in the database.
     * @param {JobPostingUpdateManyAndReturnArgs} args - Arguments to update many JobPostings.
     * @example
     * // Update many JobPostings
     * const jobPosting = await prisma.jobPosting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobPostings and only return the `job_id`
     * const jobPostingWithJob_idOnly = await prisma.jobPosting.updateManyAndReturn({
     *   select: { job_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobPostingUpdateManyAndReturnArgs>(args: SelectSubset<T, JobPostingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobPosting.
     * @param {JobPostingUpsertArgs} args - Arguments to update or create a JobPosting.
     * @example
     * // Update or create a JobPosting
     * const jobPosting = await prisma.jobPosting.upsert({
     *   create: {
     *     // ... data to create a JobPosting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPosting we want to update
     *   }
     * })
     */
    upsert<T extends JobPostingUpsertArgs>(args: SelectSubset<T, JobPostingUpsertArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobPostings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingCountArgs} args - Arguments to filter JobPostings to count.
     * @example
     * // Count the number of JobPostings
     * const count = await prisma.jobPosting.count({
     *   where: {
     *     // ... the filter for the JobPostings we want to count
     *   }
     * })
    **/
    count<T extends JobPostingCountArgs>(
      args?: Subset<T, JobPostingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostingAggregateArgs>(args: Subset<T, JobPostingAggregateArgs>): Prisma.PrismaPromise<GetJobPostingAggregateType<T>>

    /**
     * Group by JobPosting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostingGroupByArgs['orderBy'] }
        : { orderBy?: JobPostingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobPosting model
   */
  readonly fields: JobPostingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPosting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobPostingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interviews<T extends JobPosting$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirements<T extends JobPosting$requirementsArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matches<T extends JobPosting$matchesArgs<ExtArgs> = {}>(args?: Subset<T, JobPosting$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobPosting model
   */
  interface JobPostingFieldRefs {
    readonly job_id: FieldRef<"JobPosting", 'Int'>
    readonly company_id: FieldRef<"JobPosting", 'Int'>
    readonly title: FieldRef<"JobPosting", 'String'>
    readonly description: FieldRef<"JobPosting", 'String'>
    readonly location: FieldRef<"JobPosting", 'String'>
    readonly posted_at: FieldRef<"JobPosting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobPosting findUnique
   */
  export type JobPostingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting findUniqueOrThrow
   */
  export type JobPostingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting findFirst
   */
  export type JobPostingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostings.
     */
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting findFirstOrThrow
   */
  export type JobPostingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPosting to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPostings.
     */
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting findMany
   */
  export type JobPostingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter, which JobPostings to fetch.
     */
    where?: JobPostingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPostings to fetch.
     */
    orderBy?: JobPostingOrderByWithRelationInput | JobPostingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPostings.
     */
    cursor?: JobPostingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPostings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPostings.
     */
    skip?: number
    distinct?: JobPostingScalarFieldEnum | JobPostingScalarFieldEnum[]
  }

  /**
   * JobPosting create
   */
  export type JobPostingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The data needed to create a JobPosting.
     */
    data: XOR<JobPostingCreateInput, JobPostingUncheckedCreateInput>
  }

  /**
   * JobPosting createMany
   */
  export type JobPostingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobPostings.
     */
    data: JobPostingCreateManyInput | JobPostingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobPosting createManyAndReturn
   */
  export type JobPostingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * The data used to create many JobPostings.
     */
    data: JobPostingCreateManyInput | JobPostingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPosting update
   */
  export type JobPostingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The data needed to update a JobPosting.
     */
    data: XOR<JobPostingUpdateInput, JobPostingUncheckedUpdateInput>
    /**
     * Choose, which JobPosting to update.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting updateMany
   */
  export type JobPostingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobPostings.
     */
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyInput>
    /**
     * Filter which JobPostings to update
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to update.
     */
    limit?: number
  }

  /**
   * JobPosting updateManyAndReturn
   */
  export type JobPostingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * The data used to update JobPostings.
     */
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyInput>
    /**
     * Filter which JobPostings to update
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobPosting upsert
   */
  export type JobPostingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * The filter to search for the JobPosting to update in case it exists.
     */
    where: JobPostingWhereUniqueInput
    /**
     * In case the JobPosting found by the `where` argument doesn't exist, create a new JobPosting with this data.
     */
    create: XOR<JobPostingCreateInput, JobPostingUncheckedCreateInput>
    /**
     * In case the JobPosting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobPostingUpdateInput, JobPostingUncheckedUpdateInput>
  }

  /**
   * JobPosting delete
   */
  export type JobPostingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
    /**
     * Filter which JobPosting to delete.
     */
    where: JobPostingWhereUniqueInput
  }

  /**
   * JobPosting deleteMany
   */
  export type JobPostingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobPostings to delete
     */
    where?: JobPostingWhereInput
    /**
     * Limit how many JobPostings to delete.
     */
    limit?: number
  }

  /**
   * JobPosting.interviews
   */
  export type JobPosting$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    where?: AiInterviewWhereInput
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    cursor?: AiInterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewScalarFieldEnum | AiInterviewScalarFieldEnum[]
  }

  /**
   * JobPosting.requirements
   */
  export type JobPosting$requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    where?: JobRequirementWhereInput
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    cursor?: JobRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRequirementScalarFieldEnum | JobRequirementScalarFieldEnum[]
  }

  /**
   * JobPosting.matches
   */
  export type JobPosting$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    where?: ResumeVsJdMatchWhereInput
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    cursor?: ResumeVsJdMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeVsJdMatchScalarFieldEnum | ResumeVsJdMatchScalarFieldEnum[]
  }

  /**
   * JobPosting without action
   */
  export type JobPostingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobPosting
     */
    select?: JobPostingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobPosting
     */
    omit?: JobPostingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobPostingInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    skill_id: number | null
  }

  export type SkillSumAggregateOutputType = {
    skill_id: number | null
  }

  export type SkillMinAggregateOutputType = {
    skill_id: number | null
    skill_name: string | null
  }

  export type SkillMaxAggregateOutputType = {
    skill_id: number | null
    skill_name: string | null
  }

  export type SkillCountAggregateOutputType = {
    skill_id: number
    skill_name: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    skill_id?: true
  }

  export type SkillSumAggregateInputType = {
    skill_id?: true
  }

  export type SkillMinAggregateInputType = {
    skill_id?: true
    skill_name?: true
  }

  export type SkillMaxAggregateInputType = {
    skill_id?: true
    skill_name?: true
  }

  export type SkillCountAggregateInputType = {
    skill_id?: true
    skill_name?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    skill_id: number
    skill_name: string
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill_id?: boolean
    skill_name?: boolean
    job_requirements?: boolean | Skill$job_requirementsArgs<ExtArgs>
    parsed_resume_skills?: boolean | Skill$parsed_resume_skillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill_id?: boolean
    skill_name?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill_id?: boolean
    skill_name?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    skill_id?: boolean
    skill_name?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"skill_id" | "skill_name", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_requirements?: boolean | Skill$job_requirementsArgs<ExtArgs>
    parsed_resume_skills?: boolean | Skill$parsed_resume_skillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      job_requirements: Prisma.$JobRequirementPayload<ExtArgs>[]
      parsed_resume_skills: Prisma.$ParsedResumeSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      skill_id: number
      skill_name: string
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `skill_id`
     * const skillWithSkill_idOnly = await prisma.skill.findMany({ select: { skill_id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `skill_id`
     * const skillWithSkill_idOnly = await prisma.skill.createManyAndReturn({
     *   select: { skill_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `skill_id`
     * const skillWithSkill_idOnly = await prisma.skill.updateManyAndReturn({
     *   select: { skill_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_requirements<T extends Skill$job_requirementsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$job_requirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parsed_resume_skills<T extends Skill$parsed_resume_skillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$parsed_resume_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly skill_id: FieldRef<"Skill", 'Int'>
    readonly skill_name: FieldRef<"Skill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.job_requirements
   */
  export type Skill$job_requirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    where?: JobRequirementWhereInput
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    cursor?: JobRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobRequirementScalarFieldEnum | JobRequirementScalarFieldEnum[]
  }

  /**
   * Skill.parsed_resume_skills
   */
  export type Skill$parsed_resume_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    where?: ParsedResumeSkillWhereInput
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    cursor?: ParsedResumeSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedResumeSkillScalarFieldEnum | ParsedResumeSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model JobRequirement
   */

  export type AggregateJobRequirement = {
    _count: JobRequirementCountAggregateOutputType | null
    _avg: JobRequirementAvgAggregateOutputType | null
    _sum: JobRequirementSumAggregateOutputType | null
    _min: JobRequirementMinAggregateOutputType | null
    _max: JobRequirementMaxAggregateOutputType | null
  }

  export type JobRequirementAvgAggregateOutputType = {
    req_id: number | null
    job_id: number | null
    skill_id: number | null
  }

  export type JobRequirementSumAggregateOutputType = {
    req_id: number | null
    job_id: number | null
    skill_id: number | null
  }

  export type JobRequirementMinAggregateOutputType = {
    req_id: number | null
    job_id: number | null
    skill_id: number | null
    required_level: string | null
  }

  export type JobRequirementMaxAggregateOutputType = {
    req_id: number | null
    job_id: number | null
    skill_id: number | null
    required_level: string | null
  }

  export type JobRequirementCountAggregateOutputType = {
    req_id: number
    job_id: number
    skill_id: number
    required_level: number
    _all: number
  }


  export type JobRequirementAvgAggregateInputType = {
    req_id?: true
    job_id?: true
    skill_id?: true
  }

  export type JobRequirementSumAggregateInputType = {
    req_id?: true
    job_id?: true
    skill_id?: true
  }

  export type JobRequirementMinAggregateInputType = {
    req_id?: true
    job_id?: true
    skill_id?: true
    required_level?: true
  }

  export type JobRequirementMaxAggregateInputType = {
    req_id?: true
    job_id?: true
    skill_id?: true
    required_level?: true
  }

  export type JobRequirementCountAggregateInputType = {
    req_id?: true
    job_id?: true
    skill_id?: true
    required_level?: true
    _all?: true
  }

  export type JobRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRequirement to aggregate.
     */
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     */
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRequirements
    **/
    _count?: true | JobRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRequirementMaxAggregateInputType
  }

  export type GetJobRequirementAggregateType<T extends JobRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRequirement[P]>
      : GetScalarType<T[P], AggregateJobRequirement[P]>
  }




  export type JobRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRequirementWhereInput
    orderBy?: JobRequirementOrderByWithAggregationInput | JobRequirementOrderByWithAggregationInput[]
    by: JobRequirementScalarFieldEnum[] | JobRequirementScalarFieldEnum
    having?: JobRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRequirementCountAggregateInputType | true
    _avg?: JobRequirementAvgAggregateInputType
    _sum?: JobRequirementSumAggregateInputType
    _min?: JobRequirementMinAggregateInputType
    _max?: JobRequirementMaxAggregateInputType
  }

  export type JobRequirementGroupByOutputType = {
    req_id: number
    job_id: number
    skill_id: number
    required_level: string | null
    _count: JobRequirementCountAggregateOutputType | null
    _avg: JobRequirementAvgAggregateOutputType | null
    _sum: JobRequirementSumAggregateOutputType | null
    _min: JobRequirementMinAggregateOutputType | null
    _max: JobRequirementMaxAggregateOutputType | null
  }

  type GetJobRequirementGroupByPayload<T extends JobRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], JobRequirementGroupByOutputType[P]>
        }
      >
    >


  export type JobRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    req_id?: boolean
    job_id?: boolean
    skill_id?: boolean
    required_level?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRequirement"]>

  export type JobRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    req_id?: boolean
    job_id?: boolean
    skill_id?: boolean
    required_level?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRequirement"]>

  export type JobRequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    req_id?: boolean
    job_id?: boolean
    skill_id?: boolean
    required_level?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobRequirement"]>

  export type JobRequirementSelectScalar = {
    req_id?: boolean
    job_id?: boolean
    skill_id?: boolean
    required_level?: boolean
  }

  export type JobRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"req_id" | "job_id" | "skill_id" | "required_level", ExtArgs["result"]["jobRequirement"]>
  export type JobRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type JobRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type JobRequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $JobRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRequirement"
    objects: {
      job: Prisma.$JobPostingPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      req_id: number
      job_id: number
      skill_id: number
      required_level: string | null
    }, ExtArgs["result"]["jobRequirement"]>
    composites: {}
  }

  type JobRequirementGetPayload<S extends boolean | null | undefined | JobRequirementDefaultArgs> = $Result.GetResult<Prisma.$JobRequirementPayload, S>

  type JobRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRequirementCountAggregateInputType | true
    }

  export interface JobRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRequirement'], meta: { name: 'JobRequirement' } }
    /**
     * Find zero or one JobRequirement that matches the filter.
     * @param {JobRequirementFindUniqueArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRequirementFindUniqueArgs>(args: SelectSubset<T, JobRequirementFindUniqueArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRequirementFindUniqueOrThrowArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindFirstArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRequirementFindFirstArgs>(args?: SelectSubset<T, JobRequirementFindFirstArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindFirstOrThrowArgs} args - Arguments to find a JobRequirement
     * @example
     * // Get one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRequirements
     * const jobRequirements = await prisma.jobRequirement.findMany()
     * 
     * // Get first 10 JobRequirements
     * const jobRequirements = await prisma.jobRequirement.findMany({ take: 10 })
     * 
     * // Only select the `req_id`
     * const jobRequirementWithReq_idOnly = await prisma.jobRequirement.findMany({ select: { req_id: true } })
     * 
     */
    findMany<T extends JobRequirementFindManyArgs>(args?: SelectSubset<T, JobRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRequirement.
     * @param {JobRequirementCreateArgs} args - Arguments to create a JobRequirement.
     * @example
     * // Create one JobRequirement
     * const JobRequirement = await prisma.jobRequirement.create({
     *   data: {
     *     // ... data to create a JobRequirement
     *   }
     * })
     * 
     */
    create<T extends JobRequirementCreateArgs>(args: SelectSubset<T, JobRequirementCreateArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRequirements.
     * @param {JobRequirementCreateManyArgs} args - Arguments to create many JobRequirements.
     * @example
     * // Create many JobRequirements
     * const jobRequirement = await prisma.jobRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRequirementCreateManyArgs>(args?: SelectSubset<T, JobRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobRequirements and returns the data saved in the database.
     * @param {JobRequirementCreateManyAndReturnArgs} args - Arguments to create many JobRequirements.
     * @example
     * // Create many JobRequirements
     * const jobRequirement = await prisma.jobRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobRequirements and only return the `req_id`
     * const jobRequirementWithReq_idOnly = await prisma.jobRequirement.createManyAndReturn({
     *   select: { req_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, JobRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobRequirement.
     * @param {JobRequirementDeleteArgs} args - Arguments to delete one JobRequirement.
     * @example
     * // Delete one JobRequirement
     * const JobRequirement = await prisma.jobRequirement.delete({
     *   where: {
     *     // ... filter to delete one JobRequirement
     *   }
     * })
     * 
     */
    delete<T extends JobRequirementDeleteArgs>(args: SelectSubset<T, JobRequirementDeleteArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRequirement.
     * @param {JobRequirementUpdateArgs} args - Arguments to update one JobRequirement.
     * @example
     * // Update one JobRequirement
     * const jobRequirement = await prisma.jobRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRequirementUpdateArgs>(args: SelectSubset<T, JobRequirementUpdateArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRequirements.
     * @param {JobRequirementDeleteManyArgs} args - Arguments to filter JobRequirements to delete.
     * @example
     * // Delete a few JobRequirements
     * const { count } = await prisma.jobRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRequirementDeleteManyArgs>(args?: SelectSubset<T, JobRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRequirements
     * const jobRequirement = await prisma.jobRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRequirementUpdateManyArgs>(args: SelectSubset<T, JobRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRequirements and returns the data updated in the database.
     * @param {JobRequirementUpdateManyAndReturnArgs} args - Arguments to update many JobRequirements.
     * @example
     * // Update many JobRequirements
     * const jobRequirement = await prisma.jobRequirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobRequirements and only return the `req_id`
     * const jobRequirementWithReq_idOnly = await prisma.jobRequirement.updateManyAndReturn({
     *   select: { req_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobRequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, JobRequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobRequirement.
     * @param {JobRequirementUpsertArgs} args - Arguments to update or create a JobRequirement.
     * @example
     * // Update or create a JobRequirement
     * const jobRequirement = await prisma.jobRequirement.upsert({
     *   create: {
     *     // ... data to create a JobRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRequirement we want to update
     *   }
     * })
     */
    upsert<T extends JobRequirementUpsertArgs>(args: SelectSubset<T, JobRequirementUpsertArgs<ExtArgs>>): Prisma__JobRequirementClient<$Result.GetResult<Prisma.$JobRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementCountArgs} args - Arguments to filter JobRequirements to count.
     * @example
     * // Count the number of JobRequirements
     * const count = await prisma.jobRequirement.count({
     *   where: {
     *     // ... the filter for the JobRequirements we want to count
     *   }
     * })
    **/
    count<T extends JobRequirementCountArgs>(
      args?: Subset<T, JobRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRequirementAggregateArgs>(args: Subset<T, JobRequirementAggregateArgs>): Prisma.PrismaPromise<GetJobRequirementAggregateType<T>>

    /**
     * Group by JobRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRequirementGroupByArgs['orderBy'] }
        : { orderBy?: JobRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRequirement model
   */
  readonly fields: JobRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRequirement model
   */
  interface JobRequirementFieldRefs {
    readonly req_id: FieldRef<"JobRequirement", 'Int'>
    readonly job_id: FieldRef<"JobRequirement", 'Int'>
    readonly skill_id: FieldRef<"JobRequirement", 'Int'>
    readonly required_level: FieldRef<"JobRequirement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobRequirement findUnique
   */
  export type JobRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobRequirement to fetch.
     */
    where: JobRequirementWhereUniqueInput
  }

  /**
   * JobRequirement findUniqueOrThrow
   */
  export type JobRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobRequirement to fetch.
     */
    where: JobRequirementWhereUniqueInput
  }

  /**
   * JobRequirement findFirst
   */
  export type JobRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobRequirement to fetch.
     */
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     */
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRequirements.
     */
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRequirements.
     */
    distinct?: JobRequirementScalarFieldEnum | JobRequirementScalarFieldEnum[]
  }

  /**
   * JobRequirement findFirstOrThrow
   */
  export type JobRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobRequirement to fetch.
     */
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     */
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRequirements.
     */
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRequirements.
     */
    distinct?: JobRequirementScalarFieldEnum | JobRequirementScalarFieldEnum[]
  }

  /**
   * JobRequirement findMany
   */
  export type JobRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter, which JobRequirements to fetch.
     */
    where?: JobRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRequirements to fetch.
     */
    orderBy?: JobRequirementOrderByWithRelationInput | JobRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRequirements.
     */
    cursor?: JobRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRequirements.
     */
    skip?: number
    distinct?: JobRequirementScalarFieldEnum | JobRequirementScalarFieldEnum[]
  }

  /**
   * JobRequirement create
   */
  export type JobRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a JobRequirement.
     */
    data: XOR<JobRequirementCreateInput, JobRequirementUncheckedCreateInput>
  }

  /**
   * JobRequirement createMany
   */
  export type JobRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRequirements.
     */
    data: JobRequirementCreateManyInput | JobRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRequirement createManyAndReturn
   */
  export type JobRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * The data used to create many JobRequirements.
     */
    data: JobRequirementCreateManyInput | JobRequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRequirement update
   */
  export type JobRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a JobRequirement.
     */
    data: XOR<JobRequirementUpdateInput, JobRequirementUncheckedUpdateInput>
    /**
     * Choose, which JobRequirement to update.
     */
    where: JobRequirementWhereUniqueInput
  }

  /**
   * JobRequirement updateMany
   */
  export type JobRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRequirements.
     */
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyInput>
    /**
     * Filter which JobRequirements to update
     */
    where?: JobRequirementWhereInput
    /**
     * Limit how many JobRequirements to update.
     */
    limit?: number
  }

  /**
   * JobRequirement updateManyAndReturn
   */
  export type JobRequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * The data used to update JobRequirements.
     */
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyInput>
    /**
     * Filter which JobRequirements to update
     */
    where?: JobRequirementWhereInput
    /**
     * Limit how many JobRequirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobRequirement upsert
   */
  export type JobRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the JobRequirement to update in case it exists.
     */
    where: JobRequirementWhereUniqueInput
    /**
     * In case the JobRequirement found by the `where` argument doesn't exist, create a new JobRequirement with this data.
     */
    create: XOR<JobRequirementCreateInput, JobRequirementUncheckedCreateInput>
    /**
     * In case the JobRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRequirementUpdateInput, JobRequirementUncheckedUpdateInput>
  }

  /**
   * JobRequirement delete
   */
  export type JobRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
    /**
     * Filter which JobRequirement to delete.
     */
    where: JobRequirementWhereUniqueInput
  }

  /**
   * JobRequirement deleteMany
   */
  export type JobRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRequirements to delete
     */
    where?: JobRequirementWhereInput
    /**
     * Limit how many JobRequirements to delete.
     */
    limit?: number
  }

  /**
   * JobRequirement without action
   */
  export type JobRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRequirement
     */
    select?: JobRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRequirement
     */
    omit?: JobRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobRequirementInclude<ExtArgs> | null
  }


  /**
   * Model CandidateProfile
   */

  export type AggregateCandidateProfile = {
    _count: CandidateProfileCountAggregateOutputType | null
    _avg: CandidateProfileAvgAggregateOutputType | null
    _sum: CandidateProfileSumAggregateOutputType | null
    _min: CandidateProfileMinAggregateOutputType | null
    _max: CandidateProfileMaxAggregateOutputType | null
  }

  export type CandidateProfileAvgAggregateOutputType = {
    candidate_id: number | null
  }

  export type CandidateProfileSumAggregateOutputType = {
    candidate_id: number | null
  }

  export type CandidateProfileMinAggregateOutputType = {
    candidate_id: number | null
    education: string | null
    experience: string | null
  }

  export type CandidateProfileMaxAggregateOutputType = {
    candidate_id: number | null
    education: string | null
    experience: string | null
  }

  export type CandidateProfileCountAggregateOutputType = {
    candidate_id: number
    education: number
    experience: number
    _all: number
  }


  export type CandidateProfileAvgAggregateInputType = {
    candidate_id?: true
  }

  export type CandidateProfileSumAggregateInputType = {
    candidate_id?: true
  }

  export type CandidateProfileMinAggregateInputType = {
    candidate_id?: true
    education?: true
    experience?: true
  }

  export type CandidateProfileMaxAggregateInputType = {
    candidate_id?: true
    education?: true
    experience?: true
  }

  export type CandidateProfileCountAggregateInputType = {
    candidate_id?: true
    education?: true
    experience?: true
    _all?: true
  }

  export type CandidateProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateProfile to aggregate.
     */
    where?: CandidateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateProfiles to fetch.
     */
    orderBy?: CandidateProfileOrderByWithRelationInput | CandidateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CandidateProfiles
    **/
    _count?: true | CandidateProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidateProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidateProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidateProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidateProfileMaxAggregateInputType
  }

  export type GetCandidateProfileAggregateType<T extends CandidateProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidateProfile[P]>
      : GetScalarType<T[P], AggregateCandidateProfile[P]>
  }




  export type CandidateProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidateProfileWhereInput
    orderBy?: CandidateProfileOrderByWithAggregationInput | CandidateProfileOrderByWithAggregationInput[]
    by: CandidateProfileScalarFieldEnum[] | CandidateProfileScalarFieldEnum
    having?: CandidateProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidateProfileCountAggregateInputType | true
    _avg?: CandidateProfileAvgAggregateInputType
    _sum?: CandidateProfileSumAggregateInputType
    _min?: CandidateProfileMinAggregateInputType
    _max?: CandidateProfileMaxAggregateInputType
  }

  export type CandidateProfileGroupByOutputType = {
    candidate_id: number
    education: string | null
    experience: string | null
    _count: CandidateProfileCountAggregateOutputType | null
    _avg: CandidateProfileAvgAggregateOutputType | null
    _sum: CandidateProfileSumAggregateOutputType | null
    _min: CandidateProfileMinAggregateOutputType | null
    _max: CandidateProfileMaxAggregateOutputType | null
  }

  type GetCandidateProfileGroupByPayload<T extends CandidateProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidateProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidateProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidateProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CandidateProfileGroupByOutputType[P]>
        }
      >
    >


  export type CandidateProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    candidate_id?: boolean
    education?: boolean
    experience?: boolean
    interviews?: boolean | CandidateProfile$interviewsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    resumes?: boolean | CandidateProfile$resumesArgs<ExtArgs>
    _count?: boolean | CandidateProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateProfile"]>

  export type CandidateProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    candidate_id?: boolean
    education?: boolean
    experience?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateProfile"]>

  export type CandidateProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    candidate_id?: boolean
    education?: boolean
    experience?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidateProfile"]>

  export type CandidateProfileSelectScalar = {
    candidate_id?: boolean
    education?: boolean
    experience?: boolean
  }

  export type CandidateProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"candidate_id" | "education" | "experience", ExtArgs["result"]["candidateProfile"]>
  export type CandidateProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviews?: boolean | CandidateProfile$interviewsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    resumes?: boolean | CandidateProfile$resumesArgs<ExtArgs>
    _count?: boolean | CandidateProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CandidateProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CandidateProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CandidateProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CandidateProfile"
    objects: {
      interviews: Prisma.$AiInterviewPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      resumes: Prisma.$ResumePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      candidate_id: number
      education: string | null
      experience: string | null
    }, ExtArgs["result"]["candidateProfile"]>
    composites: {}
  }

  type CandidateProfileGetPayload<S extends boolean | null | undefined | CandidateProfileDefaultArgs> = $Result.GetResult<Prisma.$CandidateProfilePayload, S>

  type CandidateProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CandidateProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CandidateProfileCountAggregateInputType | true
    }

  export interface CandidateProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CandidateProfile'], meta: { name: 'CandidateProfile' } }
    /**
     * Find zero or one CandidateProfile that matches the filter.
     * @param {CandidateProfileFindUniqueArgs} args - Arguments to find a CandidateProfile
     * @example
     * // Get one CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidateProfileFindUniqueArgs>(args: SelectSubset<T, CandidateProfileFindUniqueArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CandidateProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CandidateProfileFindUniqueOrThrowArgs} args - Arguments to find a CandidateProfile
     * @example
     * // Get one CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidateProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidateProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CandidateProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileFindFirstArgs} args - Arguments to find a CandidateProfile
     * @example
     * // Get one CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidateProfileFindFirstArgs>(args?: SelectSubset<T, CandidateProfileFindFirstArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CandidateProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileFindFirstOrThrowArgs} args - Arguments to find a CandidateProfile
     * @example
     * // Get one CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidateProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidateProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CandidateProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CandidateProfiles
     * const candidateProfiles = await prisma.candidateProfile.findMany()
     * 
     * // Get first 10 CandidateProfiles
     * const candidateProfiles = await prisma.candidateProfile.findMany({ take: 10 })
     * 
     * // Only select the `candidate_id`
     * const candidateProfileWithCandidate_idOnly = await prisma.candidateProfile.findMany({ select: { candidate_id: true } })
     * 
     */
    findMany<T extends CandidateProfileFindManyArgs>(args?: SelectSubset<T, CandidateProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CandidateProfile.
     * @param {CandidateProfileCreateArgs} args - Arguments to create a CandidateProfile.
     * @example
     * // Create one CandidateProfile
     * const CandidateProfile = await prisma.candidateProfile.create({
     *   data: {
     *     // ... data to create a CandidateProfile
     *   }
     * })
     * 
     */
    create<T extends CandidateProfileCreateArgs>(args: SelectSubset<T, CandidateProfileCreateArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CandidateProfiles.
     * @param {CandidateProfileCreateManyArgs} args - Arguments to create many CandidateProfiles.
     * @example
     * // Create many CandidateProfiles
     * const candidateProfile = await prisma.candidateProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidateProfileCreateManyArgs>(args?: SelectSubset<T, CandidateProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CandidateProfiles and returns the data saved in the database.
     * @param {CandidateProfileCreateManyAndReturnArgs} args - Arguments to create many CandidateProfiles.
     * @example
     * // Create many CandidateProfiles
     * const candidateProfile = await prisma.candidateProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CandidateProfiles and only return the `candidate_id`
     * const candidateProfileWithCandidate_idOnly = await prisma.candidateProfile.createManyAndReturn({
     *   select: { candidate_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidateProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidateProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CandidateProfile.
     * @param {CandidateProfileDeleteArgs} args - Arguments to delete one CandidateProfile.
     * @example
     * // Delete one CandidateProfile
     * const CandidateProfile = await prisma.candidateProfile.delete({
     *   where: {
     *     // ... filter to delete one CandidateProfile
     *   }
     * })
     * 
     */
    delete<T extends CandidateProfileDeleteArgs>(args: SelectSubset<T, CandidateProfileDeleteArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CandidateProfile.
     * @param {CandidateProfileUpdateArgs} args - Arguments to update one CandidateProfile.
     * @example
     * // Update one CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidateProfileUpdateArgs>(args: SelectSubset<T, CandidateProfileUpdateArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CandidateProfiles.
     * @param {CandidateProfileDeleteManyArgs} args - Arguments to filter CandidateProfiles to delete.
     * @example
     * // Delete a few CandidateProfiles
     * const { count } = await prisma.candidateProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidateProfileDeleteManyArgs>(args?: SelectSubset<T, CandidateProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CandidateProfiles
     * const candidateProfile = await prisma.candidateProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidateProfileUpdateManyArgs>(args: SelectSubset<T, CandidateProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CandidateProfiles and returns the data updated in the database.
     * @param {CandidateProfileUpdateManyAndReturnArgs} args - Arguments to update many CandidateProfiles.
     * @example
     * // Update many CandidateProfiles
     * const candidateProfile = await prisma.candidateProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CandidateProfiles and only return the `candidate_id`
     * const candidateProfileWithCandidate_idOnly = await prisma.candidateProfile.updateManyAndReturn({
     *   select: { candidate_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CandidateProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, CandidateProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CandidateProfile.
     * @param {CandidateProfileUpsertArgs} args - Arguments to update or create a CandidateProfile.
     * @example
     * // Update or create a CandidateProfile
     * const candidateProfile = await prisma.candidateProfile.upsert({
     *   create: {
     *     // ... data to create a CandidateProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CandidateProfile we want to update
     *   }
     * })
     */
    upsert<T extends CandidateProfileUpsertArgs>(args: SelectSubset<T, CandidateProfileUpsertArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CandidateProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileCountArgs} args - Arguments to filter CandidateProfiles to count.
     * @example
     * // Count the number of CandidateProfiles
     * const count = await prisma.candidateProfile.count({
     *   where: {
     *     // ... the filter for the CandidateProfiles we want to count
     *   }
     * })
    **/
    count<T extends CandidateProfileCountArgs>(
      args?: Subset<T, CandidateProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidateProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CandidateProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidateProfileAggregateArgs>(args: Subset<T, CandidateProfileAggregateArgs>): Prisma.PrismaPromise<GetCandidateProfileAggregateType<T>>

    /**
     * Group by CandidateProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidateProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidateProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidateProfileGroupByArgs['orderBy'] }
        : { orderBy?: CandidateProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidateProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidateProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CandidateProfile model
   */
  readonly fields: CandidateProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CandidateProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidateProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interviews<T extends CandidateProfile$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, CandidateProfile$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resumes<T extends CandidateProfile$resumesArgs<ExtArgs> = {}>(args?: Subset<T, CandidateProfile$resumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CandidateProfile model
   */
  interface CandidateProfileFieldRefs {
    readonly candidate_id: FieldRef<"CandidateProfile", 'Int'>
    readonly education: FieldRef<"CandidateProfile", 'String'>
    readonly experience: FieldRef<"CandidateProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CandidateProfile findUnique
   */
  export type CandidateProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter, which CandidateProfile to fetch.
     */
    where: CandidateProfileWhereUniqueInput
  }

  /**
   * CandidateProfile findUniqueOrThrow
   */
  export type CandidateProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter, which CandidateProfile to fetch.
     */
    where: CandidateProfileWhereUniqueInput
  }

  /**
   * CandidateProfile findFirst
   */
  export type CandidateProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter, which CandidateProfile to fetch.
     */
    where?: CandidateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateProfiles to fetch.
     */
    orderBy?: CandidateProfileOrderByWithRelationInput | CandidateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateProfiles.
     */
    cursor?: CandidateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateProfiles.
     */
    distinct?: CandidateProfileScalarFieldEnum | CandidateProfileScalarFieldEnum[]
  }

  /**
   * CandidateProfile findFirstOrThrow
   */
  export type CandidateProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter, which CandidateProfile to fetch.
     */
    where?: CandidateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateProfiles to fetch.
     */
    orderBy?: CandidateProfileOrderByWithRelationInput | CandidateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CandidateProfiles.
     */
    cursor?: CandidateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CandidateProfiles.
     */
    distinct?: CandidateProfileScalarFieldEnum | CandidateProfileScalarFieldEnum[]
  }

  /**
   * CandidateProfile findMany
   */
  export type CandidateProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter, which CandidateProfiles to fetch.
     */
    where?: CandidateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CandidateProfiles to fetch.
     */
    orderBy?: CandidateProfileOrderByWithRelationInput | CandidateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CandidateProfiles.
     */
    cursor?: CandidateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CandidateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CandidateProfiles.
     */
    skip?: number
    distinct?: CandidateProfileScalarFieldEnum | CandidateProfileScalarFieldEnum[]
  }

  /**
   * CandidateProfile create
   */
  export type CandidateProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CandidateProfile.
     */
    data: XOR<CandidateProfileCreateInput, CandidateProfileUncheckedCreateInput>
  }

  /**
   * CandidateProfile createMany
   */
  export type CandidateProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CandidateProfiles.
     */
    data: CandidateProfileCreateManyInput | CandidateProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CandidateProfile createManyAndReturn
   */
  export type CandidateProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * The data used to create many CandidateProfiles.
     */
    data: CandidateProfileCreateManyInput | CandidateProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CandidateProfile update
   */
  export type CandidateProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CandidateProfile.
     */
    data: XOR<CandidateProfileUpdateInput, CandidateProfileUncheckedUpdateInput>
    /**
     * Choose, which CandidateProfile to update.
     */
    where: CandidateProfileWhereUniqueInput
  }

  /**
   * CandidateProfile updateMany
   */
  export type CandidateProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CandidateProfiles.
     */
    data: XOR<CandidateProfileUpdateManyMutationInput, CandidateProfileUncheckedUpdateManyInput>
    /**
     * Filter which CandidateProfiles to update
     */
    where?: CandidateProfileWhereInput
    /**
     * Limit how many CandidateProfiles to update.
     */
    limit?: number
  }

  /**
   * CandidateProfile updateManyAndReturn
   */
  export type CandidateProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * The data used to update CandidateProfiles.
     */
    data: XOR<CandidateProfileUpdateManyMutationInput, CandidateProfileUncheckedUpdateManyInput>
    /**
     * Filter which CandidateProfiles to update
     */
    where?: CandidateProfileWhereInput
    /**
     * Limit how many CandidateProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CandidateProfile upsert
   */
  export type CandidateProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CandidateProfile to update in case it exists.
     */
    where: CandidateProfileWhereUniqueInput
    /**
     * In case the CandidateProfile found by the `where` argument doesn't exist, create a new CandidateProfile with this data.
     */
    create: XOR<CandidateProfileCreateInput, CandidateProfileUncheckedCreateInput>
    /**
     * In case the CandidateProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidateProfileUpdateInput, CandidateProfileUncheckedUpdateInput>
  }

  /**
   * CandidateProfile delete
   */
  export type CandidateProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
    /**
     * Filter which CandidateProfile to delete.
     */
    where: CandidateProfileWhereUniqueInput
  }

  /**
   * CandidateProfile deleteMany
   */
  export type CandidateProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CandidateProfiles to delete
     */
    where?: CandidateProfileWhereInput
    /**
     * Limit how many CandidateProfiles to delete.
     */
    limit?: number
  }

  /**
   * CandidateProfile.interviews
   */
  export type CandidateProfile$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    where?: AiInterviewWhereInput
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    cursor?: AiInterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewScalarFieldEnum | AiInterviewScalarFieldEnum[]
  }

  /**
   * CandidateProfile.resumes
   */
  export type CandidateProfile$resumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    cursor?: ResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * CandidateProfile without action
   */
  export type CandidateProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidateProfile
     */
    select?: CandidateProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CandidateProfile
     */
    omit?: CandidateProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidateProfileInclude<ExtArgs> | null
  }


  /**
   * Model Resume
   */

  export type AggregateResume = {
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  export type ResumeAvgAggregateOutputType = {
    resume_id: number | null
    candidate_id: number | null
  }

  export type ResumeSumAggregateOutputType = {
    resume_id: number | null
    candidate_id: number | null
  }

  export type ResumeMinAggregateOutputType = {
    resume_id: number | null
    candidate_id: number | null
    file_path: string | null
    parsed_text: string | null
    uploaded_at: Date | null
  }

  export type ResumeMaxAggregateOutputType = {
    resume_id: number | null
    candidate_id: number | null
    file_path: string | null
    parsed_text: string | null
    uploaded_at: Date | null
  }

  export type ResumeCountAggregateOutputType = {
    resume_id: number
    candidate_id: number
    file_path: number
    parsed_text: number
    parsed_json: number
    uploaded_at: number
    _all: number
  }


  export type ResumeAvgAggregateInputType = {
    resume_id?: true
    candidate_id?: true
  }

  export type ResumeSumAggregateInputType = {
    resume_id?: true
    candidate_id?: true
  }

  export type ResumeMinAggregateInputType = {
    resume_id?: true
    candidate_id?: true
    file_path?: true
    parsed_text?: true
    uploaded_at?: true
  }

  export type ResumeMaxAggregateInputType = {
    resume_id?: true
    candidate_id?: true
    file_path?: true
    parsed_text?: true
    uploaded_at?: true
  }

  export type ResumeCountAggregateInputType = {
    resume_id?: true
    candidate_id?: true
    file_path?: true
    parsed_text?: true
    parsed_json?: true
    uploaded_at?: true
    _all?: true
  }

  export type ResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resume to aggregate.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resumes
    **/
    _count?: true | ResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeMaxAggregateInputType
  }

  export type GetResumeAggregateType<T extends ResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResume[P]>
      : GetScalarType<T[P], AggregateResume[P]>
  }




  export type ResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithAggregationInput | ResumeOrderByWithAggregationInput[]
    by: ResumeScalarFieldEnum[] | ResumeScalarFieldEnum
    having?: ResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeCountAggregateInputType | true
    _avg?: ResumeAvgAggregateInputType
    _sum?: ResumeSumAggregateInputType
    _min?: ResumeMinAggregateInputType
    _max?: ResumeMaxAggregateInputType
  }

  export type ResumeGroupByOutputType = {
    resume_id: number
    candidate_id: number
    file_path: string | null
    parsed_text: string | null
    parsed_json: JsonValue | null
    uploaded_at: Date | null
    _count: ResumeCountAggregateOutputType | null
    _avg: ResumeAvgAggregateOutputType | null
    _sum: ResumeSumAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  type GetResumeGroupByPayload<T extends ResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    candidate_id?: boolean
    file_path?: boolean
    parsed_text?: boolean
    parsed_json?: boolean
    uploaded_at?: boolean
    parsed_resume_skills?: boolean | Resume$parsed_resume_skillsArgs<ExtArgs>
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    matches?: boolean | Resume$matchesArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    candidate_id?: boolean
    file_path?: boolean
    parsed_text?: boolean
    parsed_json?: boolean
    uploaded_at?: boolean
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    candidate_id?: boolean
    file_path?: boolean
    parsed_text?: boolean
    parsed_json?: boolean
    uploaded_at?: boolean
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectScalar = {
    resume_id?: boolean
    candidate_id?: boolean
    file_path?: boolean
    parsed_text?: boolean
    parsed_json?: boolean
    uploaded_at?: boolean
  }

  export type ResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"resume_id" | "candidate_id" | "file_path" | "parsed_text" | "parsed_json" | "uploaded_at", ExtArgs["result"]["resume"]>
  export type ResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parsed_resume_skills?: boolean | Resume$parsed_resume_skillsArgs<ExtArgs>
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    matches?: boolean | Resume$matchesArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
  }
  export type ResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
  }

  export type $ResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resume"
    objects: {
      parsed_resume_skills: Prisma.$ParsedResumeSkillPayload<ExtArgs>[]
      candidate: Prisma.$CandidateProfilePayload<ExtArgs>
      matches: Prisma.$ResumeVsJdMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      resume_id: number
      candidate_id: number
      file_path: string | null
      parsed_text: string | null
      parsed_json: Prisma.JsonValue | null
      uploaded_at: Date | null
    }, ExtArgs["result"]["resume"]>
    composites: {}
  }

  type ResumeGetPayload<S extends boolean | null | undefined | ResumeDefaultArgs> = $Result.GetResult<Prisma.$ResumePayload, S>

  type ResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeCountAggregateInputType | true
    }

  export interface ResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resume'], meta: { name: 'Resume' } }
    /**
     * Find zero or one Resume that matches the filter.
     * @param {ResumeFindUniqueArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeFindUniqueArgs>(args: SelectSubset<T, ResumeFindUniqueArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeFindUniqueOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeFindFirstArgs>(args?: SelectSubset<T, ResumeFindFirstArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resumes
     * const resumes = await prisma.resume.findMany()
     * 
     * // Get first 10 Resumes
     * const resumes = await prisma.resume.findMany({ take: 10 })
     * 
     * // Only select the `resume_id`
     * const resumeWithResume_idOnly = await prisma.resume.findMany({ select: { resume_id: true } })
     * 
     */
    findMany<T extends ResumeFindManyArgs>(args?: SelectSubset<T, ResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resume.
     * @param {ResumeCreateArgs} args - Arguments to create a Resume.
     * @example
     * // Create one Resume
     * const Resume = await prisma.resume.create({
     *   data: {
     *     // ... data to create a Resume
     *   }
     * })
     * 
     */
    create<T extends ResumeCreateArgs>(args: SelectSubset<T, ResumeCreateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resumes.
     * @param {ResumeCreateManyArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeCreateManyArgs>(args?: SelectSubset<T, ResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resumes and returns the data saved in the database.
     * @param {ResumeCreateManyAndReturnArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resumes and only return the `resume_id`
     * const resumeWithResume_idOnly = await prisma.resume.createManyAndReturn({
     *   select: { resume_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resume.
     * @param {ResumeDeleteArgs} args - Arguments to delete one Resume.
     * @example
     * // Delete one Resume
     * const Resume = await prisma.resume.delete({
     *   where: {
     *     // ... filter to delete one Resume
     *   }
     * })
     * 
     */
    delete<T extends ResumeDeleteArgs>(args: SelectSubset<T, ResumeDeleteArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resume.
     * @param {ResumeUpdateArgs} args - Arguments to update one Resume.
     * @example
     * // Update one Resume
     * const resume = await prisma.resume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeUpdateArgs>(args: SelectSubset<T, ResumeUpdateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resumes.
     * @param {ResumeDeleteManyArgs} args - Arguments to filter Resumes to delete.
     * @example
     * // Delete a few Resumes
     * const { count } = await prisma.resume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeDeleteManyArgs>(args?: SelectSubset<T, ResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeUpdateManyArgs>(args: SelectSubset<T, ResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes and returns the data updated in the database.
     * @param {ResumeUpdateManyAndReturnArgs} args - Arguments to update many Resumes.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resumes and only return the `resume_id`
     * const resumeWithResume_idOnly = await prisma.resume.updateManyAndReturn({
     *   select: { resume_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resume.
     * @param {ResumeUpsertArgs} args - Arguments to update or create a Resume.
     * @example
     * // Update or create a Resume
     * const resume = await prisma.resume.upsert({
     *   create: {
     *     // ... data to create a Resume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resume we want to update
     *   }
     * })
     */
    upsert<T extends ResumeUpsertArgs>(args: SelectSubset<T, ResumeUpsertArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCountArgs} args - Arguments to filter Resumes to count.
     * @example
     * // Count the number of Resumes
     * const count = await prisma.resume.count({
     *   where: {
     *     // ... the filter for the Resumes we want to count
     *   }
     * })
    **/
    count<T extends ResumeCountArgs>(
      args?: Subset<T, ResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeAggregateArgs>(args: Subset<T, ResumeAggregateArgs>): Prisma.PrismaPromise<GetResumeAggregateType<T>>

    /**
     * Group by Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeGroupByArgs['orderBy'] }
        : { orderBy?: ResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resume model
   */
  readonly fields: ResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parsed_resume_skills<T extends Resume$parsed_resume_skillsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$parsed_resume_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    candidate<T extends CandidateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateProfileDefaultArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matches<T extends Resume$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resume model
   */
  interface ResumeFieldRefs {
    readonly resume_id: FieldRef<"Resume", 'Int'>
    readonly candidate_id: FieldRef<"Resume", 'Int'>
    readonly file_path: FieldRef<"Resume", 'String'>
    readonly parsed_text: FieldRef<"Resume", 'String'>
    readonly parsed_json: FieldRef<"Resume", 'Json'>
    readonly uploaded_at: FieldRef<"Resume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resume findUnique
   */
  export type ResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findUniqueOrThrow
   */
  export type ResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findFirst
   */
  export type ResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findFirstOrThrow
   */
  export type ResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findMany
   */
  export type ResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resumes to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume create
   */
  export type ResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Resume.
     */
    data: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
  }

  /**
   * Resume createMany
   */
  export type ResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resume createManyAndReturn
   */
  export type ResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume update
   */
  export type ResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Resume.
     */
    data: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
    /**
     * Choose, which Resume to update.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume updateMany
   */
  export type ResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
  }

  /**
   * Resume updateManyAndReturn
   */
  export type ResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume upsert
   */
  export type ResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Resume to update in case it exists.
     */
    where: ResumeWhereUniqueInput
    /**
     * In case the Resume found by the `where` argument doesn't exist, create a new Resume with this data.
     */
    create: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
    /**
     * In case the Resume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
  }

  /**
   * Resume delete
   */
  export type ResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter which Resume to delete.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume deleteMany
   */
  export type ResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resumes to delete
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to delete.
     */
    limit?: number
  }

  /**
   * Resume.parsed_resume_skills
   */
  export type Resume$parsed_resume_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    where?: ParsedResumeSkillWhereInput
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    cursor?: ParsedResumeSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParsedResumeSkillScalarFieldEnum | ParsedResumeSkillScalarFieldEnum[]
  }

  /**
   * Resume.matches
   */
  export type Resume$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    where?: ResumeVsJdMatchWhereInput
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    cursor?: ResumeVsJdMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeVsJdMatchScalarFieldEnum | ResumeVsJdMatchScalarFieldEnum[]
  }

  /**
   * Resume without action
   */
  export type ResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
  }


  /**
   * Model ParsedResumeSkill
   */

  export type AggregateParsedResumeSkill = {
    _count: ParsedResumeSkillCountAggregateOutputType | null
    _avg: ParsedResumeSkillAvgAggregateOutputType | null
    _sum: ParsedResumeSkillSumAggregateOutputType | null
    _min: ParsedResumeSkillMinAggregateOutputType | null
    _max: ParsedResumeSkillMaxAggregateOutputType | null
  }

  export type ParsedResumeSkillAvgAggregateOutputType = {
    resume_id: number | null
    skill_id: number | null
  }

  export type ParsedResumeSkillSumAggregateOutputType = {
    resume_id: number | null
    skill_id: number | null
  }

  export type ParsedResumeSkillMinAggregateOutputType = {
    resume_id: number | null
    skill_id: number | null
  }

  export type ParsedResumeSkillMaxAggregateOutputType = {
    resume_id: number | null
    skill_id: number | null
  }

  export type ParsedResumeSkillCountAggregateOutputType = {
    resume_id: number
    skill_id: number
    _all: number
  }


  export type ParsedResumeSkillAvgAggregateInputType = {
    resume_id?: true
    skill_id?: true
  }

  export type ParsedResumeSkillSumAggregateInputType = {
    resume_id?: true
    skill_id?: true
  }

  export type ParsedResumeSkillMinAggregateInputType = {
    resume_id?: true
    skill_id?: true
  }

  export type ParsedResumeSkillMaxAggregateInputType = {
    resume_id?: true
    skill_id?: true
  }

  export type ParsedResumeSkillCountAggregateInputType = {
    resume_id?: true
    skill_id?: true
    _all?: true
  }

  export type ParsedResumeSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedResumeSkill to aggregate.
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedResumeSkills to fetch.
     */
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParsedResumeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedResumeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedResumeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParsedResumeSkills
    **/
    _count?: true | ParsedResumeSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParsedResumeSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParsedResumeSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParsedResumeSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParsedResumeSkillMaxAggregateInputType
  }

  export type GetParsedResumeSkillAggregateType<T extends ParsedResumeSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateParsedResumeSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsedResumeSkill[P]>
      : GetScalarType<T[P], AggregateParsedResumeSkill[P]>
  }




  export type ParsedResumeSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParsedResumeSkillWhereInput
    orderBy?: ParsedResumeSkillOrderByWithAggregationInput | ParsedResumeSkillOrderByWithAggregationInput[]
    by: ParsedResumeSkillScalarFieldEnum[] | ParsedResumeSkillScalarFieldEnum
    having?: ParsedResumeSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParsedResumeSkillCountAggregateInputType | true
    _avg?: ParsedResumeSkillAvgAggregateInputType
    _sum?: ParsedResumeSkillSumAggregateInputType
    _min?: ParsedResumeSkillMinAggregateInputType
    _max?: ParsedResumeSkillMaxAggregateInputType
  }

  export type ParsedResumeSkillGroupByOutputType = {
    resume_id: number
    skill_id: number
    _count: ParsedResumeSkillCountAggregateOutputType | null
    _avg: ParsedResumeSkillAvgAggregateOutputType | null
    _sum: ParsedResumeSkillSumAggregateOutputType | null
    _min: ParsedResumeSkillMinAggregateOutputType | null
    _max: ParsedResumeSkillMaxAggregateOutputType | null
  }

  type GetParsedResumeSkillGroupByPayload<T extends ParsedResumeSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParsedResumeSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParsedResumeSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParsedResumeSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ParsedResumeSkillGroupByOutputType[P]>
        }
      >
    >


  export type ParsedResumeSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    skill_id?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedResumeSkill"]>

  export type ParsedResumeSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    skill_id?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedResumeSkill"]>

  export type ParsedResumeSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resume_id?: boolean
    skill_id?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parsedResumeSkill"]>

  export type ParsedResumeSkillSelectScalar = {
    resume_id?: boolean
    skill_id?: boolean
  }

  export type ParsedResumeSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"resume_id" | "skill_id", ExtArgs["result"]["parsedResumeSkill"]>
  export type ParsedResumeSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ParsedResumeSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type ParsedResumeSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $ParsedResumeSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParsedResumeSkill"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      resume_id: number
      skill_id: number
    }, ExtArgs["result"]["parsedResumeSkill"]>
    composites: {}
  }

  type ParsedResumeSkillGetPayload<S extends boolean | null | undefined | ParsedResumeSkillDefaultArgs> = $Result.GetResult<Prisma.$ParsedResumeSkillPayload, S>

  type ParsedResumeSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParsedResumeSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParsedResumeSkillCountAggregateInputType | true
    }

  export interface ParsedResumeSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParsedResumeSkill'], meta: { name: 'ParsedResumeSkill' } }
    /**
     * Find zero or one ParsedResumeSkill that matches the filter.
     * @param {ParsedResumeSkillFindUniqueArgs} args - Arguments to find a ParsedResumeSkill
     * @example
     * // Get one ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParsedResumeSkillFindUniqueArgs>(args: SelectSubset<T, ParsedResumeSkillFindUniqueArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParsedResumeSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParsedResumeSkillFindUniqueOrThrowArgs} args - Arguments to find a ParsedResumeSkill
     * @example
     * // Get one ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParsedResumeSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ParsedResumeSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedResumeSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillFindFirstArgs} args - Arguments to find a ParsedResumeSkill
     * @example
     * // Get one ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParsedResumeSkillFindFirstArgs>(args?: SelectSubset<T, ParsedResumeSkillFindFirstArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParsedResumeSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillFindFirstOrThrowArgs} args - Arguments to find a ParsedResumeSkill
     * @example
     * // Get one ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParsedResumeSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ParsedResumeSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParsedResumeSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParsedResumeSkills
     * const parsedResumeSkills = await prisma.parsedResumeSkill.findMany()
     * 
     * // Get first 10 ParsedResumeSkills
     * const parsedResumeSkills = await prisma.parsedResumeSkill.findMany({ take: 10 })
     * 
     * // Only select the `resume_id`
     * const parsedResumeSkillWithResume_idOnly = await prisma.parsedResumeSkill.findMany({ select: { resume_id: true } })
     * 
     */
    findMany<T extends ParsedResumeSkillFindManyArgs>(args?: SelectSubset<T, ParsedResumeSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParsedResumeSkill.
     * @param {ParsedResumeSkillCreateArgs} args - Arguments to create a ParsedResumeSkill.
     * @example
     * // Create one ParsedResumeSkill
     * const ParsedResumeSkill = await prisma.parsedResumeSkill.create({
     *   data: {
     *     // ... data to create a ParsedResumeSkill
     *   }
     * })
     * 
     */
    create<T extends ParsedResumeSkillCreateArgs>(args: SelectSubset<T, ParsedResumeSkillCreateArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParsedResumeSkills.
     * @param {ParsedResumeSkillCreateManyArgs} args - Arguments to create many ParsedResumeSkills.
     * @example
     * // Create many ParsedResumeSkills
     * const parsedResumeSkill = await prisma.parsedResumeSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParsedResumeSkillCreateManyArgs>(args?: SelectSubset<T, ParsedResumeSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParsedResumeSkills and returns the data saved in the database.
     * @param {ParsedResumeSkillCreateManyAndReturnArgs} args - Arguments to create many ParsedResumeSkills.
     * @example
     * // Create many ParsedResumeSkills
     * const parsedResumeSkill = await prisma.parsedResumeSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParsedResumeSkills and only return the `resume_id`
     * const parsedResumeSkillWithResume_idOnly = await prisma.parsedResumeSkill.createManyAndReturn({
     *   select: { resume_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParsedResumeSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ParsedResumeSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParsedResumeSkill.
     * @param {ParsedResumeSkillDeleteArgs} args - Arguments to delete one ParsedResumeSkill.
     * @example
     * // Delete one ParsedResumeSkill
     * const ParsedResumeSkill = await prisma.parsedResumeSkill.delete({
     *   where: {
     *     // ... filter to delete one ParsedResumeSkill
     *   }
     * })
     * 
     */
    delete<T extends ParsedResumeSkillDeleteArgs>(args: SelectSubset<T, ParsedResumeSkillDeleteArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParsedResumeSkill.
     * @param {ParsedResumeSkillUpdateArgs} args - Arguments to update one ParsedResumeSkill.
     * @example
     * // Update one ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParsedResumeSkillUpdateArgs>(args: SelectSubset<T, ParsedResumeSkillUpdateArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParsedResumeSkills.
     * @param {ParsedResumeSkillDeleteManyArgs} args - Arguments to filter ParsedResumeSkills to delete.
     * @example
     * // Delete a few ParsedResumeSkills
     * const { count } = await prisma.parsedResumeSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParsedResumeSkillDeleteManyArgs>(args?: SelectSubset<T, ParsedResumeSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedResumeSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParsedResumeSkills
     * const parsedResumeSkill = await prisma.parsedResumeSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParsedResumeSkillUpdateManyArgs>(args: SelectSubset<T, ParsedResumeSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParsedResumeSkills and returns the data updated in the database.
     * @param {ParsedResumeSkillUpdateManyAndReturnArgs} args - Arguments to update many ParsedResumeSkills.
     * @example
     * // Update many ParsedResumeSkills
     * const parsedResumeSkill = await prisma.parsedResumeSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParsedResumeSkills and only return the `resume_id`
     * const parsedResumeSkillWithResume_idOnly = await prisma.parsedResumeSkill.updateManyAndReturn({
     *   select: { resume_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParsedResumeSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, ParsedResumeSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParsedResumeSkill.
     * @param {ParsedResumeSkillUpsertArgs} args - Arguments to update or create a ParsedResumeSkill.
     * @example
     * // Update or create a ParsedResumeSkill
     * const parsedResumeSkill = await prisma.parsedResumeSkill.upsert({
     *   create: {
     *     // ... data to create a ParsedResumeSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParsedResumeSkill we want to update
     *   }
     * })
     */
    upsert<T extends ParsedResumeSkillUpsertArgs>(args: SelectSubset<T, ParsedResumeSkillUpsertArgs<ExtArgs>>): Prisma__ParsedResumeSkillClient<$Result.GetResult<Prisma.$ParsedResumeSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParsedResumeSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillCountArgs} args - Arguments to filter ParsedResumeSkills to count.
     * @example
     * // Count the number of ParsedResumeSkills
     * const count = await prisma.parsedResumeSkill.count({
     *   where: {
     *     // ... the filter for the ParsedResumeSkills we want to count
     *   }
     * })
    **/
    count<T extends ParsedResumeSkillCountArgs>(
      args?: Subset<T, ParsedResumeSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParsedResumeSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParsedResumeSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParsedResumeSkillAggregateArgs>(args: Subset<T, ParsedResumeSkillAggregateArgs>): Prisma.PrismaPromise<GetParsedResumeSkillAggregateType<T>>

    /**
     * Group by ParsedResumeSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParsedResumeSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParsedResumeSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParsedResumeSkillGroupByArgs['orderBy'] }
        : { orderBy?: ParsedResumeSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParsedResumeSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsedResumeSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParsedResumeSkill model
   */
  readonly fields: ParsedResumeSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParsedResumeSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParsedResumeSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParsedResumeSkill model
   */
  interface ParsedResumeSkillFieldRefs {
    readonly resume_id: FieldRef<"ParsedResumeSkill", 'Int'>
    readonly skill_id: FieldRef<"ParsedResumeSkill", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ParsedResumeSkill findUnique
   */
  export type ParsedResumeSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ParsedResumeSkill to fetch.
     */
    where: ParsedResumeSkillWhereUniqueInput
  }

  /**
   * ParsedResumeSkill findUniqueOrThrow
   */
  export type ParsedResumeSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ParsedResumeSkill to fetch.
     */
    where: ParsedResumeSkillWhereUniqueInput
  }

  /**
   * ParsedResumeSkill findFirst
   */
  export type ParsedResumeSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ParsedResumeSkill to fetch.
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedResumeSkills to fetch.
     */
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedResumeSkills.
     */
    cursor?: ParsedResumeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedResumeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedResumeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedResumeSkills.
     */
    distinct?: ParsedResumeSkillScalarFieldEnum | ParsedResumeSkillScalarFieldEnum[]
  }

  /**
   * ParsedResumeSkill findFirstOrThrow
   */
  export type ParsedResumeSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ParsedResumeSkill to fetch.
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedResumeSkills to fetch.
     */
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParsedResumeSkills.
     */
    cursor?: ParsedResumeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedResumeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedResumeSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParsedResumeSkills.
     */
    distinct?: ParsedResumeSkillScalarFieldEnum | ParsedResumeSkillScalarFieldEnum[]
  }

  /**
   * ParsedResumeSkill findMany
   */
  export type ParsedResumeSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter, which ParsedResumeSkills to fetch.
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParsedResumeSkills to fetch.
     */
    orderBy?: ParsedResumeSkillOrderByWithRelationInput | ParsedResumeSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParsedResumeSkills.
     */
    cursor?: ParsedResumeSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParsedResumeSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParsedResumeSkills.
     */
    skip?: number
    distinct?: ParsedResumeSkillScalarFieldEnum | ParsedResumeSkillScalarFieldEnum[]
  }

  /**
   * ParsedResumeSkill create
   */
  export type ParsedResumeSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ParsedResumeSkill.
     */
    data: XOR<ParsedResumeSkillCreateInput, ParsedResumeSkillUncheckedCreateInput>
  }

  /**
   * ParsedResumeSkill createMany
   */
  export type ParsedResumeSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParsedResumeSkills.
     */
    data: ParsedResumeSkillCreateManyInput | ParsedResumeSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParsedResumeSkill createManyAndReturn
   */
  export type ParsedResumeSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * The data used to create many ParsedResumeSkills.
     */
    data: ParsedResumeSkillCreateManyInput | ParsedResumeSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedResumeSkill update
   */
  export type ParsedResumeSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ParsedResumeSkill.
     */
    data: XOR<ParsedResumeSkillUpdateInput, ParsedResumeSkillUncheckedUpdateInput>
    /**
     * Choose, which ParsedResumeSkill to update.
     */
    where: ParsedResumeSkillWhereUniqueInput
  }

  /**
   * ParsedResumeSkill updateMany
   */
  export type ParsedResumeSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParsedResumeSkills.
     */
    data: XOR<ParsedResumeSkillUpdateManyMutationInput, ParsedResumeSkillUncheckedUpdateManyInput>
    /**
     * Filter which ParsedResumeSkills to update
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * Limit how many ParsedResumeSkills to update.
     */
    limit?: number
  }

  /**
   * ParsedResumeSkill updateManyAndReturn
   */
  export type ParsedResumeSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * The data used to update ParsedResumeSkills.
     */
    data: XOR<ParsedResumeSkillUpdateManyMutationInput, ParsedResumeSkillUncheckedUpdateManyInput>
    /**
     * Filter which ParsedResumeSkills to update
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * Limit how many ParsedResumeSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParsedResumeSkill upsert
   */
  export type ParsedResumeSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ParsedResumeSkill to update in case it exists.
     */
    where: ParsedResumeSkillWhereUniqueInput
    /**
     * In case the ParsedResumeSkill found by the `where` argument doesn't exist, create a new ParsedResumeSkill with this data.
     */
    create: XOR<ParsedResumeSkillCreateInput, ParsedResumeSkillUncheckedCreateInput>
    /**
     * In case the ParsedResumeSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParsedResumeSkillUpdateInput, ParsedResumeSkillUncheckedUpdateInput>
  }

  /**
   * ParsedResumeSkill delete
   */
  export type ParsedResumeSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
    /**
     * Filter which ParsedResumeSkill to delete.
     */
    where: ParsedResumeSkillWhereUniqueInput
  }

  /**
   * ParsedResumeSkill deleteMany
   */
  export type ParsedResumeSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParsedResumeSkills to delete
     */
    where?: ParsedResumeSkillWhereInput
    /**
     * Limit how many ParsedResumeSkills to delete.
     */
    limit?: number
  }

  /**
   * ParsedResumeSkill without action
   */
  export type ParsedResumeSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParsedResumeSkill
     */
    select?: ParsedResumeSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParsedResumeSkill
     */
    omit?: ParsedResumeSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParsedResumeSkillInclude<ExtArgs> | null
  }


  /**
   * Model ResumeVsJdMatch
   */

  export type AggregateResumeVsJdMatch = {
    _count: ResumeVsJdMatchCountAggregateOutputType | null
    _avg: ResumeVsJdMatchAvgAggregateOutputType | null
    _sum: ResumeVsJdMatchSumAggregateOutputType | null
    _min: ResumeVsJdMatchMinAggregateOutputType | null
    _max: ResumeVsJdMatchMaxAggregateOutputType | null
  }

  export type ResumeVsJdMatchAvgAggregateOutputType = {
    match_id: number | null
    resume_id: number | null
    job_id: number | null
    match_score: number | null
  }

  export type ResumeVsJdMatchSumAggregateOutputType = {
    match_id: number | null
    resume_id: number | null
    job_id: number | null
    match_score: number | null
  }

  export type ResumeVsJdMatchMinAggregateOutputType = {
    match_id: number | null
    resume_id: number | null
    job_id: number | null
    match_score: number | null
  }

  export type ResumeVsJdMatchMaxAggregateOutputType = {
    match_id: number | null
    resume_id: number | null
    job_id: number | null
    match_score: number | null
  }

  export type ResumeVsJdMatchCountAggregateOutputType = {
    match_id: number
    resume_id: number
    job_id: number
    match_score: number
    matched_skills: number
    missing_skills: number
    _all: number
  }


  export type ResumeVsJdMatchAvgAggregateInputType = {
    match_id?: true
    resume_id?: true
    job_id?: true
    match_score?: true
  }

  export type ResumeVsJdMatchSumAggregateInputType = {
    match_id?: true
    resume_id?: true
    job_id?: true
    match_score?: true
  }

  export type ResumeVsJdMatchMinAggregateInputType = {
    match_id?: true
    resume_id?: true
    job_id?: true
    match_score?: true
  }

  export type ResumeVsJdMatchMaxAggregateInputType = {
    match_id?: true
    resume_id?: true
    job_id?: true
    match_score?: true
  }

  export type ResumeVsJdMatchCountAggregateInputType = {
    match_id?: true
    resume_id?: true
    job_id?: true
    match_score?: true
    matched_skills?: true
    missing_skills?: true
    _all?: true
  }

  export type ResumeVsJdMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeVsJdMatch to aggregate.
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeVsJdMatches to fetch.
     */
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeVsJdMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeVsJdMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeVsJdMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResumeVsJdMatches
    **/
    _count?: true | ResumeVsJdMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResumeVsJdMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResumeVsJdMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeVsJdMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeVsJdMatchMaxAggregateInputType
  }

  export type GetResumeVsJdMatchAggregateType<T extends ResumeVsJdMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateResumeVsJdMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResumeVsJdMatch[P]>
      : GetScalarType<T[P], AggregateResumeVsJdMatch[P]>
  }




  export type ResumeVsJdMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeVsJdMatchWhereInput
    orderBy?: ResumeVsJdMatchOrderByWithAggregationInput | ResumeVsJdMatchOrderByWithAggregationInput[]
    by: ResumeVsJdMatchScalarFieldEnum[] | ResumeVsJdMatchScalarFieldEnum
    having?: ResumeVsJdMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeVsJdMatchCountAggregateInputType | true
    _avg?: ResumeVsJdMatchAvgAggregateInputType
    _sum?: ResumeVsJdMatchSumAggregateInputType
    _min?: ResumeVsJdMatchMinAggregateInputType
    _max?: ResumeVsJdMatchMaxAggregateInputType
  }

  export type ResumeVsJdMatchGroupByOutputType = {
    match_id: number
    resume_id: number
    job_id: number
    match_score: number | null
    matched_skills: JsonValue | null
    missing_skills: JsonValue | null
    _count: ResumeVsJdMatchCountAggregateOutputType | null
    _avg: ResumeVsJdMatchAvgAggregateOutputType | null
    _sum: ResumeVsJdMatchSumAggregateOutputType | null
    _min: ResumeVsJdMatchMinAggregateOutputType | null
    _max: ResumeVsJdMatchMaxAggregateOutputType | null
  }

  type GetResumeVsJdMatchGroupByPayload<T extends ResumeVsJdMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeVsJdMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeVsJdMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeVsJdMatchGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeVsJdMatchGroupByOutputType[P]>
        }
      >
    >


  export type ResumeVsJdMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    match_id?: boolean
    resume_id?: boolean
    job_id?: boolean
    match_score?: boolean
    matched_skills?: boolean
    missing_skills?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeVsJdMatch"]>

  export type ResumeVsJdMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    match_id?: boolean
    resume_id?: boolean
    job_id?: boolean
    match_score?: boolean
    matched_skills?: boolean
    missing_skills?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeVsJdMatch"]>

  export type ResumeVsJdMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    match_id?: boolean
    resume_id?: boolean
    job_id?: boolean
    match_score?: boolean
    matched_skills?: boolean
    missing_skills?: boolean
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resumeVsJdMatch"]>

  export type ResumeVsJdMatchSelectScalar = {
    match_id?: boolean
    resume_id?: boolean
    job_id?: boolean
    match_score?: boolean
    matched_skills?: boolean
    missing_skills?: boolean
  }

  export type ResumeVsJdMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"match_id" | "resume_id" | "job_id" | "match_score" | "matched_skills" | "missing_skills", ExtArgs["result"]["resumeVsJdMatch"]>
  export type ResumeVsJdMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeVsJdMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ResumeVsJdMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ResumeVsJdMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResumeVsJdMatch"
    objects: {
      job: Prisma.$JobPostingPayload<ExtArgs>
      resume: Prisma.$ResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      match_id: number
      resume_id: number
      job_id: number
      match_score: number | null
      matched_skills: Prisma.JsonValue | null
      missing_skills: Prisma.JsonValue | null
    }, ExtArgs["result"]["resumeVsJdMatch"]>
    composites: {}
  }

  type ResumeVsJdMatchGetPayload<S extends boolean | null | undefined | ResumeVsJdMatchDefaultArgs> = $Result.GetResult<Prisma.$ResumeVsJdMatchPayload, S>

  type ResumeVsJdMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeVsJdMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeVsJdMatchCountAggregateInputType | true
    }

  export interface ResumeVsJdMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResumeVsJdMatch'], meta: { name: 'ResumeVsJdMatch' } }
    /**
     * Find zero or one ResumeVsJdMatch that matches the filter.
     * @param {ResumeVsJdMatchFindUniqueArgs} args - Arguments to find a ResumeVsJdMatch
     * @example
     * // Get one ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeVsJdMatchFindUniqueArgs>(args: SelectSubset<T, ResumeVsJdMatchFindUniqueArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResumeVsJdMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeVsJdMatchFindUniqueOrThrowArgs} args - Arguments to find a ResumeVsJdMatch
     * @example
     * // Get one ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeVsJdMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeVsJdMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeVsJdMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchFindFirstArgs} args - Arguments to find a ResumeVsJdMatch
     * @example
     * // Get one ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeVsJdMatchFindFirstArgs>(args?: SelectSubset<T, ResumeVsJdMatchFindFirstArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResumeVsJdMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchFindFirstOrThrowArgs} args - Arguments to find a ResumeVsJdMatch
     * @example
     * // Get one ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeVsJdMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeVsJdMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResumeVsJdMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResumeVsJdMatches
     * const resumeVsJdMatches = await prisma.resumeVsJdMatch.findMany()
     * 
     * // Get first 10 ResumeVsJdMatches
     * const resumeVsJdMatches = await prisma.resumeVsJdMatch.findMany({ take: 10 })
     * 
     * // Only select the `match_id`
     * const resumeVsJdMatchWithMatch_idOnly = await prisma.resumeVsJdMatch.findMany({ select: { match_id: true } })
     * 
     */
    findMany<T extends ResumeVsJdMatchFindManyArgs>(args?: SelectSubset<T, ResumeVsJdMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResumeVsJdMatch.
     * @param {ResumeVsJdMatchCreateArgs} args - Arguments to create a ResumeVsJdMatch.
     * @example
     * // Create one ResumeVsJdMatch
     * const ResumeVsJdMatch = await prisma.resumeVsJdMatch.create({
     *   data: {
     *     // ... data to create a ResumeVsJdMatch
     *   }
     * })
     * 
     */
    create<T extends ResumeVsJdMatchCreateArgs>(args: SelectSubset<T, ResumeVsJdMatchCreateArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResumeVsJdMatches.
     * @param {ResumeVsJdMatchCreateManyArgs} args - Arguments to create many ResumeVsJdMatches.
     * @example
     * // Create many ResumeVsJdMatches
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeVsJdMatchCreateManyArgs>(args?: SelectSubset<T, ResumeVsJdMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResumeVsJdMatches and returns the data saved in the database.
     * @param {ResumeVsJdMatchCreateManyAndReturnArgs} args - Arguments to create many ResumeVsJdMatches.
     * @example
     * // Create many ResumeVsJdMatches
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResumeVsJdMatches and only return the `match_id`
     * const resumeVsJdMatchWithMatch_idOnly = await prisma.resumeVsJdMatch.createManyAndReturn({
     *   select: { match_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeVsJdMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeVsJdMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResumeVsJdMatch.
     * @param {ResumeVsJdMatchDeleteArgs} args - Arguments to delete one ResumeVsJdMatch.
     * @example
     * // Delete one ResumeVsJdMatch
     * const ResumeVsJdMatch = await prisma.resumeVsJdMatch.delete({
     *   where: {
     *     // ... filter to delete one ResumeVsJdMatch
     *   }
     * })
     * 
     */
    delete<T extends ResumeVsJdMatchDeleteArgs>(args: SelectSubset<T, ResumeVsJdMatchDeleteArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResumeVsJdMatch.
     * @param {ResumeVsJdMatchUpdateArgs} args - Arguments to update one ResumeVsJdMatch.
     * @example
     * // Update one ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeVsJdMatchUpdateArgs>(args: SelectSubset<T, ResumeVsJdMatchUpdateArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResumeVsJdMatches.
     * @param {ResumeVsJdMatchDeleteManyArgs} args - Arguments to filter ResumeVsJdMatches to delete.
     * @example
     * // Delete a few ResumeVsJdMatches
     * const { count } = await prisma.resumeVsJdMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeVsJdMatchDeleteManyArgs>(args?: SelectSubset<T, ResumeVsJdMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeVsJdMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResumeVsJdMatches
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeVsJdMatchUpdateManyArgs>(args: SelectSubset<T, ResumeVsJdMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResumeVsJdMatches and returns the data updated in the database.
     * @param {ResumeVsJdMatchUpdateManyAndReturnArgs} args - Arguments to update many ResumeVsJdMatches.
     * @example
     * // Update many ResumeVsJdMatches
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResumeVsJdMatches and only return the `match_id`
     * const resumeVsJdMatchWithMatch_idOnly = await prisma.resumeVsJdMatch.updateManyAndReturn({
     *   select: { match_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeVsJdMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeVsJdMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResumeVsJdMatch.
     * @param {ResumeVsJdMatchUpsertArgs} args - Arguments to update or create a ResumeVsJdMatch.
     * @example
     * // Update or create a ResumeVsJdMatch
     * const resumeVsJdMatch = await prisma.resumeVsJdMatch.upsert({
     *   create: {
     *     // ... data to create a ResumeVsJdMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResumeVsJdMatch we want to update
     *   }
     * })
     */
    upsert<T extends ResumeVsJdMatchUpsertArgs>(args: SelectSubset<T, ResumeVsJdMatchUpsertArgs<ExtArgs>>): Prisma__ResumeVsJdMatchClient<$Result.GetResult<Prisma.$ResumeVsJdMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResumeVsJdMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchCountArgs} args - Arguments to filter ResumeVsJdMatches to count.
     * @example
     * // Count the number of ResumeVsJdMatches
     * const count = await prisma.resumeVsJdMatch.count({
     *   where: {
     *     // ... the filter for the ResumeVsJdMatches we want to count
     *   }
     * })
    **/
    count<T extends ResumeVsJdMatchCountArgs>(
      args?: Subset<T, ResumeVsJdMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeVsJdMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResumeVsJdMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeVsJdMatchAggregateArgs>(args: Subset<T, ResumeVsJdMatchAggregateArgs>): Prisma.PrismaPromise<GetResumeVsJdMatchAggregateType<T>>

    /**
     * Group by ResumeVsJdMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeVsJdMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeVsJdMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeVsJdMatchGroupByArgs['orderBy'] }
        : { orderBy?: ResumeVsJdMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeVsJdMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeVsJdMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResumeVsJdMatch model
   */
  readonly fields: ResumeVsJdMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResumeVsJdMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeVsJdMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResumeVsJdMatch model
   */
  interface ResumeVsJdMatchFieldRefs {
    readonly match_id: FieldRef<"ResumeVsJdMatch", 'Int'>
    readonly resume_id: FieldRef<"ResumeVsJdMatch", 'Int'>
    readonly job_id: FieldRef<"ResumeVsJdMatch", 'Int'>
    readonly match_score: FieldRef<"ResumeVsJdMatch", 'Float'>
    readonly matched_skills: FieldRef<"ResumeVsJdMatch", 'Json'>
    readonly missing_skills: FieldRef<"ResumeVsJdMatch", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ResumeVsJdMatch findUnique
   */
  export type ResumeVsJdMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter, which ResumeVsJdMatch to fetch.
     */
    where: ResumeVsJdMatchWhereUniqueInput
  }

  /**
   * ResumeVsJdMatch findUniqueOrThrow
   */
  export type ResumeVsJdMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter, which ResumeVsJdMatch to fetch.
     */
    where: ResumeVsJdMatchWhereUniqueInput
  }

  /**
   * ResumeVsJdMatch findFirst
   */
  export type ResumeVsJdMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter, which ResumeVsJdMatch to fetch.
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeVsJdMatches to fetch.
     */
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeVsJdMatches.
     */
    cursor?: ResumeVsJdMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeVsJdMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeVsJdMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeVsJdMatches.
     */
    distinct?: ResumeVsJdMatchScalarFieldEnum | ResumeVsJdMatchScalarFieldEnum[]
  }

  /**
   * ResumeVsJdMatch findFirstOrThrow
   */
  export type ResumeVsJdMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter, which ResumeVsJdMatch to fetch.
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeVsJdMatches to fetch.
     */
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResumeVsJdMatches.
     */
    cursor?: ResumeVsJdMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeVsJdMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeVsJdMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResumeVsJdMatches.
     */
    distinct?: ResumeVsJdMatchScalarFieldEnum | ResumeVsJdMatchScalarFieldEnum[]
  }

  /**
   * ResumeVsJdMatch findMany
   */
  export type ResumeVsJdMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter, which ResumeVsJdMatches to fetch.
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResumeVsJdMatches to fetch.
     */
    orderBy?: ResumeVsJdMatchOrderByWithRelationInput | ResumeVsJdMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResumeVsJdMatches.
     */
    cursor?: ResumeVsJdMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResumeVsJdMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResumeVsJdMatches.
     */
    skip?: number
    distinct?: ResumeVsJdMatchScalarFieldEnum | ResumeVsJdMatchScalarFieldEnum[]
  }

  /**
   * ResumeVsJdMatch create
   */
  export type ResumeVsJdMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ResumeVsJdMatch.
     */
    data: XOR<ResumeVsJdMatchCreateInput, ResumeVsJdMatchUncheckedCreateInput>
  }

  /**
   * ResumeVsJdMatch createMany
   */
  export type ResumeVsJdMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResumeVsJdMatches.
     */
    data: ResumeVsJdMatchCreateManyInput | ResumeVsJdMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResumeVsJdMatch createManyAndReturn
   */
  export type ResumeVsJdMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * The data used to create many ResumeVsJdMatches.
     */
    data: ResumeVsJdMatchCreateManyInput | ResumeVsJdMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeVsJdMatch update
   */
  export type ResumeVsJdMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ResumeVsJdMatch.
     */
    data: XOR<ResumeVsJdMatchUpdateInput, ResumeVsJdMatchUncheckedUpdateInput>
    /**
     * Choose, which ResumeVsJdMatch to update.
     */
    where: ResumeVsJdMatchWhereUniqueInput
  }

  /**
   * ResumeVsJdMatch updateMany
   */
  export type ResumeVsJdMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResumeVsJdMatches.
     */
    data: XOR<ResumeVsJdMatchUpdateManyMutationInput, ResumeVsJdMatchUncheckedUpdateManyInput>
    /**
     * Filter which ResumeVsJdMatches to update
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * Limit how many ResumeVsJdMatches to update.
     */
    limit?: number
  }

  /**
   * ResumeVsJdMatch updateManyAndReturn
   */
  export type ResumeVsJdMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * The data used to update ResumeVsJdMatches.
     */
    data: XOR<ResumeVsJdMatchUpdateManyMutationInput, ResumeVsJdMatchUncheckedUpdateManyInput>
    /**
     * Filter which ResumeVsJdMatches to update
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * Limit how many ResumeVsJdMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResumeVsJdMatch upsert
   */
  export type ResumeVsJdMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ResumeVsJdMatch to update in case it exists.
     */
    where: ResumeVsJdMatchWhereUniqueInput
    /**
     * In case the ResumeVsJdMatch found by the `where` argument doesn't exist, create a new ResumeVsJdMatch with this data.
     */
    create: XOR<ResumeVsJdMatchCreateInput, ResumeVsJdMatchUncheckedCreateInput>
    /**
     * In case the ResumeVsJdMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeVsJdMatchUpdateInput, ResumeVsJdMatchUncheckedUpdateInput>
  }

  /**
   * ResumeVsJdMatch delete
   */
  export type ResumeVsJdMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
    /**
     * Filter which ResumeVsJdMatch to delete.
     */
    where: ResumeVsJdMatchWhereUniqueInput
  }

  /**
   * ResumeVsJdMatch deleteMany
   */
  export type ResumeVsJdMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResumeVsJdMatches to delete
     */
    where?: ResumeVsJdMatchWhereInput
    /**
     * Limit how many ResumeVsJdMatches to delete.
     */
    limit?: number
  }

  /**
   * ResumeVsJdMatch without action
   */
  export type ResumeVsJdMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeVsJdMatch
     */
    select?: ResumeVsJdMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResumeVsJdMatch
     */
    omit?: ResumeVsJdMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeVsJdMatchInclude<ExtArgs> | null
  }


  /**
   * Model AiInterview
   */

  export type AggregateAiInterview = {
    _count: AiInterviewCountAggregateOutputType | null
    _avg: AiInterviewAvgAggregateOutputType | null
    _sum: AiInterviewSumAggregateOutputType | null
    _min: AiInterviewMinAggregateOutputType | null
    _max: AiInterviewMaxAggregateOutputType | null
  }

  export type AiInterviewAvgAggregateOutputType = {
    interview_id: number | null
    job_id: number | null
    candidate_id: number | null
  }

  export type AiInterviewSumAggregateOutputType = {
    interview_id: number | null
    job_id: number | null
    candidate_id: number | null
  }

  export type AiInterviewMinAggregateOutputType = {
    interview_id: number | null
    job_id: number | null
    candidate_id: number | null
    scheduled_at: Date | null
    status: string | null
    created_at: Date | null
  }

  export type AiInterviewMaxAggregateOutputType = {
    interview_id: number | null
    job_id: number | null
    candidate_id: number | null
    scheduled_at: Date | null
    status: string | null
    created_at: Date | null
  }

  export type AiInterviewCountAggregateOutputType = {
    interview_id: number
    job_id: number
    candidate_id: number
    scheduled_at: number
    status: number
    created_at: number
    _all: number
  }


  export type AiInterviewAvgAggregateInputType = {
    interview_id?: true
    job_id?: true
    candidate_id?: true
  }

  export type AiInterviewSumAggregateInputType = {
    interview_id?: true
    job_id?: true
    candidate_id?: true
  }

  export type AiInterviewMinAggregateInputType = {
    interview_id?: true
    job_id?: true
    candidate_id?: true
    scheduled_at?: true
    status?: true
    created_at?: true
  }

  export type AiInterviewMaxAggregateInputType = {
    interview_id?: true
    job_id?: true
    candidate_id?: true
    scheduled_at?: true
    status?: true
    created_at?: true
  }

  export type AiInterviewCountAggregateInputType = {
    interview_id?: true
    job_id?: true
    candidate_id?: true
    scheduled_at?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type AiInterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterview to aggregate.
     */
    where?: AiInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviews to fetch.
     */
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviews
    **/
    _count?: true | AiInterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewMaxAggregateInputType
  }

  export type GetAiInterviewAggregateType<T extends AiInterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterview[P]>
      : GetScalarType<T[P], AggregateAiInterview[P]>
  }




  export type AiInterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewWhereInput
    orderBy?: AiInterviewOrderByWithAggregationInput | AiInterviewOrderByWithAggregationInput[]
    by: AiInterviewScalarFieldEnum[] | AiInterviewScalarFieldEnum
    having?: AiInterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewCountAggregateInputType | true
    _avg?: AiInterviewAvgAggregateInputType
    _sum?: AiInterviewSumAggregateInputType
    _min?: AiInterviewMinAggregateInputType
    _max?: AiInterviewMaxAggregateInputType
  }

  export type AiInterviewGroupByOutputType = {
    interview_id: number
    job_id: number
    candidate_id: number
    scheduled_at: Date | null
    status: string | null
    created_at: Date | null
    _count: AiInterviewCountAggregateOutputType | null
    _avg: AiInterviewAvgAggregateOutputType | null
    _sum: AiInterviewSumAggregateOutputType | null
    _min: AiInterviewMinAggregateOutputType | null
    _max: AiInterviewMaxAggregateOutputType | null
  }

  type GetAiInterviewGroupByPayload<T extends AiInterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interview_id?: boolean
    job_id?: boolean
    candidate_id?: boolean
    scheduled_at?: boolean
    status?: boolean
    created_at?: boolean
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    analysis?: boolean | AiInterview$analysisArgs<ExtArgs>
    cheating_events?: boolean | AiInterview$cheating_eventsArgs<ExtArgs>
    posture_data?: boolean | AiInterview$posture_dataArgs<ExtArgs>
    questions?: boolean | AiInterview$questionsArgs<ExtArgs>
    responses?: boolean | AiInterview$responsesArgs<ExtArgs>
    voice_prompts?: boolean | AiInterview$voice_promptsArgs<ExtArgs>
    _count?: boolean | AiInterviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterview"]>

  export type AiInterviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interview_id?: boolean
    job_id?: boolean
    candidate_id?: boolean
    scheduled_at?: boolean
    status?: boolean
    created_at?: boolean
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterview"]>

  export type AiInterviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interview_id?: boolean
    job_id?: boolean
    candidate_id?: boolean
    scheduled_at?: boolean
    status?: boolean
    created_at?: boolean
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterview"]>

  export type AiInterviewSelectScalar = {
    interview_id?: boolean
    job_id?: boolean
    candidate_id?: boolean
    scheduled_at?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type AiInterviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"interview_id" | "job_id" | "candidate_id" | "scheduled_at" | "status" | "created_at", ExtArgs["result"]["aiInterview"]>
  export type AiInterviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
    analysis?: boolean | AiInterview$analysisArgs<ExtArgs>
    cheating_events?: boolean | AiInterview$cheating_eventsArgs<ExtArgs>
    posture_data?: boolean | AiInterview$posture_dataArgs<ExtArgs>
    questions?: boolean | AiInterview$questionsArgs<ExtArgs>
    responses?: boolean | AiInterview$responsesArgs<ExtArgs>
    voice_prompts?: boolean | AiInterview$voice_promptsArgs<ExtArgs>
    _count?: boolean | AiInterviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiInterviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
  }
  export type AiInterviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidate?: boolean | CandidateProfileDefaultArgs<ExtArgs>
    job?: boolean | JobPostingDefaultArgs<ExtArgs>
  }

  export type $AiInterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterview"
    objects: {
      candidate: Prisma.$CandidateProfilePayload<ExtArgs>
      job: Prisma.$JobPostingPayload<ExtArgs>
      analysis: Prisma.$AiInterviewAnalysisPayload<ExtArgs> | null
      cheating_events: Prisma.$AiInterviewCheatingEventPayload<ExtArgs>[]
      posture_data: Prisma.$AiInterviewPostureDataPayload<ExtArgs>[]
      questions: Prisma.$AiInterviewQuestionPayload<ExtArgs>[]
      responses: Prisma.$AiInterviewResponsePayload<ExtArgs>[]
      voice_prompts: Prisma.$AiVoicePromptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      interview_id: number
      job_id: number
      candidate_id: number
      scheduled_at: Date | null
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["aiInterview"]>
    composites: {}
  }

  type AiInterviewGetPayload<S extends boolean | null | undefined | AiInterviewDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewPayload, S>

  type AiInterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewCountAggregateInputType | true
    }

  export interface AiInterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterview'], meta: { name: 'AiInterview' } }
    /**
     * Find zero or one AiInterview that matches the filter.
     * @param {AiInterviewFindUniqueArgs} args - Arguments to find a AiInterview
     * @example
     * // Get one AiInterview
     * const aiInterview = await prisma.aiInterview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewFindUniqueArgs>(args: SelectSubset<T, AiInterviewFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewFindUniqueOrThrowArgs} args - Arguments to find a AiInterview
     * @example
     * // Get one AiInterview
     * const aiInterview = await prisma.aiInterview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewFindFirstArgs} args - Arguments to find a AiInterview
     * @example
     * // Get one AiInterview
     * const aiInterview = await prisma.aiInterview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewFindFirstArgs>(args?: SelectSubset<T, AiInterviewFindFirstArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewFindFirstOrThrowArgs} args - Arguments to find a AiInterview
     * @example
     * // Get one AiInterview
     * const aiInterview = await prisma.aiInterview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviews
     * const aiInterviews = await prisma.aiInterview.findMany()
     * 
     * // Get first 10 AiInterviews
     * const aiInterviews = await prisma.aiInterview.findMany({ take: 10 })
     * 
     * // Only select the `interview_id`
     * const aiInterviewWithInterview_idOnly = await prisma.aiInterview.findMany({ select: { interview_id: true } })
     * 
     */
    findMany<T extends AiInterviewFindManyArgs>(args?: SelectSubset<T, AiInterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterview.
     * @param {AiInterviewCreateArgs} args - Arguments to create a AiInterview.
     * @example
     * // Create one AiInterview
     * const AiInterview = await prisma.aiInterview.create({
     *   data: {
     *     // ... data to create a AiInterview
     *   }
     * })
     * 
     */
    create<T extends AiInterviewCreateArgs>(args: SelectSubset<T, AiInterviewCreateArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviews.
     * @param {AiInterviewCreateManyArgs} args - Arguments to create many AiInterviews.
     * @example
     * // Create many AiInterviews
     * const aiInterview = await prisma.aiInterview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewCreateManyArgs>(args?: SelectSubset<T, AiInterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviews and returns the data saved in the database.
     * @param {AiInterviewCreateManyAndReturnArgs} args - Arguments to create many AiInterviews.
     * @example
     * // Create many AiInterviews
     * const aiInterview = await prisma.aiInterview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviews and only return the `interview_id`
     * const aiInterviewWithInterview_idOnly = await prisma.aiInterview.createManyAndReturn({
     *   select: { interview_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterview.
     * @param {AiInterviewDeleteArgs} args - Arguments to delete one AiInterview.
     * @example
     * // Delete one AiInterview
     * const AiInterview = await prisma.aiInterview.delete({
     *   where: {
     *     // ... filter to delete one AiInterview
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewDeleteArgs>(args: SelectSubset<T, AiInterviewDeleteArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterview.
     * @param {AiInterviewUpdateArgs} args - Arguments to update one AiInterview.
     * @example
     * // Update one AiInterview
     * const aiInterview = await prisma.aiInterview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewUpdateArgs>(args: SelectSubset<T, AiInterviewUpdateArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviews.
     * @param {AiInterviewDeleteManyArgs} args - Arguments to filter AiInterviews to delete.
     * @example
     * // Delete a few AiInterviews
     * const { count } = await prisma.aiInterview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewDeleteManyArgs>(args?: SelectSubset<T, AiInterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviews
     * const aiInterview = await prisma.aiInterview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewUpdateManyArgs>(args: SelectSubset<T, AiInterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviews and returns the data updated in the database.
     * @param {AiInterviewUpdateManyAndReturnArgs} args - Arguments to update many AiInterviews.
     * @example
     * // Update many AiInterviews
     * const aiInterview = await prisma.aiInterview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviews and only return the `interview_id`
     * const aiInterviewWithInterview_idOnly = await prisma.aiInterview.updateManyAndReturn({
     *   select: { interview_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterview.
     * @param {AiInterviewUpsertArgs} args - Arguments to update or create a AiInterview.
     * @example
     * // Update or create a AiInterview
     * const aiInterview = await prisma.aiInterview.upsert({
     *   create: {
     *     // ... data to create a AiInterview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterview we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewUpsertArgs>(args: SelectSubset<T, AiInterviewUpsertArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCountArgs} args - Arguments to filter AiInterviews to count.
     * @example
     * // Count the number of AiInterviews
     * const count = await prisma.aiInterview.count({
     *   where: {
     *     // ... the filter for the AiInterviews we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewCountArgs>(
      args?: Subset<T, AiInterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewAggregateArgs>(args: Subset<T, AiInterviewAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewAggregateType<T>>

    /**
     * Group by AiInterview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterview model
   */
  readonly fields: AiInterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candidate<T extends CandidateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidateProfileDefaultArgs<ExtArgs>>): Prisma__CandidateProfileClient<$Result.GetResult<Prisma.$CandidateProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job<T extends JobPostingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobPostingDefaultArgs<ExtArgs>>): Prisma__JobPostingClient<$Result.GetResult<Prisma.$JobPostingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    analysis<T extends AiInterview$analysisArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$analysisArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cheating_events<T extends AiInterview$cheating_eventsArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$cheating_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posture_data<T extends AiInterview$posture_dataArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$posture_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends AiInterview$questionsArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends AiInterview$responsesArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voice_prompts<T extends AiInterview$voice_promptsArgs<ExtArgs> = {}>(args?: Subset<T, AiInterview$voice_promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterview model
   */
  interface AiInterviewFieldRefs {
    readonly interview_id: FieldRef<"AiInterview", 'Int'>
    readonly job_id: FieldRef<"AiInterview", 'Int'>
    readonly candidate_id: FieldRef<"AiInterview", 'Int'>
    readonly scheduled_at: FieldRef<"AiInterview", 'DateTime'>
    readonly status: FieldRef<"AiInterview", 'String'>
    readonly created_at: FieldRef<"AiInterview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiInterview findUnique
   */
  export type AiInterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter, which AiInterview to fetch.
     */
    where: AiInterviewWhereUniqueInput
  }

  /**
   * AiInterview findUniqueOrThrow
   */
  export type AiInterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter, which AiInterview to fetch.
     */
    where: AiInterviewWhereUniqueInput
  }

  /**
   * AiInterview findFirst
   */
  export type AiInterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter, which AiInterview to fetch.
     */
    where?: AiInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviews to fetch.
     */
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviews.
     */
    cursor?: AiInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviews.
     */
    distinct?: AiInterviewScalarFieldEnum | AiInterviewScalarFieldEnum[]
  }

  /**
   * AiInterview findFirstOrThrow
   */
  export type AiInterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter, which AiInterview to fetch.
     */
    where?: AiInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviews to fetch.
     */
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviews.
     */
    cursor?: AiInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviews.
     */
    distinct?: AiInterviewScalarFieldEnum | AiInterviewScalarFieldEnum[]
  }

  /**
   * AiInterview findMany
   */
  export type AiInterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviews to fetch.
     */
    where?: AiInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviews to fetch.
     */
    orderBy?: AiInterviewOrderByWithRelationInput | AiInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviews.
     */
    cursor?: AiInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviews.
     */
    skip?: number
    distinct?: AiInterviewScalarFieldEnum | AiInterviewScalarFieldEnum[]
  }

  /**
   * AiInterview create
   */
  export type AiInterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterview.
     */
    data: XOR<AiInterviewCreateInput, AiInterviewUncheckedCreateInput>
  }

  /**
   * AiInterview createMany
   */
  export type AiInterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviews.
     */
    data: AiInterviewCreateManyInput | AiInterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterview createManyAndReturn
   */
  export type AiInterviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviews.
     */
    data: AiInterviewCreateManyInput | AiInterviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterview update
   */
  export type AiInterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterview.
     */
    data: XOR<AiInterviewUpdateInput, AiInterviewUncheckedUpdateInput>
    /**
     * Choose, which AiInterview to update.
     */
    where: AiInterviewWhereUniqueInput
  }

  /**
   * AiInterview updateMany
   */
  export type AiInterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviews.
     */
    data: XOR<AiInterviewUpdateManyMutationInput, AiInterviewUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviews to update
     */
    where?: AiInterviewWhereInput
    /**
     * Limit how many AiInterviews to update.
     */
    limit?: number
  }

  /**
   * AiInterview updateManyAndReturn
   */
  export type AiInterviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviews.
     */
    data: XOR<AiInterviewUpdateManyMutationInput, AiInterviewUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviews to update
     */
    where?: AiInterviewWhereInput
    /**
     * Limit how many AiInterviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterview upsert
   */
  export type AiInterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterview to update in case it exists.
     */
    where: AiInterviewWhereUniqueInput
    /**
     * In case the AiInterview found by the `where` argument doesn't exist, create a new AiInterview with this data.
     */
    create: XOR<AiInterviewCreateInput, AiInterviewUncheckedCreateInput>
    /**
     * In case the AiInterview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewUpdateInput, AiInterviewUncheckedUpdateInput>
  }

  /**
   * AiInterview delete
   */
  export type AiInterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
    /**
     * Filter which AiInterview to delete.
     */
    where: AiInterviewWhereUniqueInput
  }

  /**
   * AiInterview deleteMany
   */
  export type AiInterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviews to delete
     */
    where?: AiInterviewWhereInput
    /**
     * Limit how many AiInterviews to delete.
     */
    limit?: number
  }

  /**
   * AiInterview.analysis
   */
  export type AiInterview$analysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    where?: AiInterviewAnalysisWhereInput
  }

  /**
   * AiInterview.cheating_events
   */
  export type AiInterview$cheating_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    where?: AiInterviewCheatingEventWhereInput
    orderBy?: AiInterviewCheatingEventOrderByWithRelationInput | AiInterviewCheatingEventOrderByWithRelationInput[]
    cursor?: AiInterviewCheatingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewCheatingEventScalarFieldEnum | AiInterviewCheatingEventScalarFieldEnum[]
  }

  /**
   * AiInterview.posture_data
   */
  export type AiInterview$posture_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    where?: AiInterviewPostureDataWhereInput
    orderBy?: AiInterviewPostureDataOrderByWithRelationInput | AiInterviewPostureDataOrderByWithRelationInput[]
    cursor?: AiInterviewPostureDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewPostureDataScalarFieldEnum | AiInterviewPostureDataScalarFieldEnum[]
  }

  /**
   * AiInterview.questions
   */
  export type AiInterview$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    where?: AiInterviewQuestionWhereInput
    orderBy?: AiInterviewQuestionOrderByWithRelationInput | AiInterviewQuestionOrderByWithRelationInput[]
    cursor?: AiInterviewQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewQuestionScalarFieldEnum | AiInterviewQuestionScalarFieldEnum[]
  }

  /**
   * AiInterview.responses
   */
  export type AiInterview$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    where?: AiInterviewResponseWhereInput
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    cursor?: AiInterviewResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewResponseScalarFieldEnum | AiInterviewResponseScalarFieldEnum[]
  }

  /**
   * AiInterview.voice_prompts
   */
  export type AiInterview$voice_promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    where?: AiVoicePromptWhereInput
    orderBy?: AiVoicePromptOrderByWithRelationInput | AiVoicePromptOrderByWithRelationInput[]
    cursor?: AiVoicePromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiVoicePromptScalarFieldEnum | AiVoicePromptScalarFieldEnum[]
  }

  /**
   * AiInterview without action
   */
  export type AiInterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterview
     */
    select?: AiInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterview
     */
    omit?: AiInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewInclude<ExtArgs> | null
  }


  /**
   * Model AiInterviewQuestion
   */

  export type AggregateAiInterviewQuestion = {
    _count: AiInterviewQuestionCountAggregateOutputType | null
    _avg: AiInterviewQuestionAvgAggregateOutputType | null
    _sum: AiInterviewQuestionSumAggregateOutputType | null
    _min: AiInterviewQuestionMinAggregateOutputType | null
    _max: AiInterviewQuestionMaxAggregateOutputType | null
  }

  export type AiInterviewQuestionAvgAggregateOutputType = {
    question_id: number | null
    interview_id: number | null
  }

  export type AiInterviewQuestionSumAggregateOutputType = {
    question_id: number | null
    interview_id: number | null
  }

  export type AiInterviewQuestionMinAggregateOutputType = {
    question_id: number | null
    interview_id: number | null
    question_text: string | null
    question_type: string | null
    ai_generated: boolean | null
    asked_at: Date | null
  }

  export type AiInterviewQuestionMaxAggregateOutputType = {
    question_id: number | null
    interview_id: number | null
    question_text: string | null
    question_type: string | null
    ai_generated: boolean | null
    asked_at: Date | null
  }

  export type AiInterviewQuestionCountAggregateOutputType = {
    question_id: number
    interview_id: number
    question_text: number
    question_type: number
    ai_generated: number
    asked_at: number
    _all: number
  }


  export type AiInterviewQuestionAvgAggregateInputType = {
    question_id?: true
    interview_id?: true
  }

  export type AiInterviewQuestionSumAggregateInputType = {
    question_id?: true
    interview_id?: true
  }

  export type AiInterviewQuestionMinAggregateInputType = {
    question_id?: true
    interview_id?: true
    question_text?: true
    question_type?: true
    ai_generated?: true
    asked_at?: true
  }

  export type AiInterviewQuestionMaxAggregateInputType = {
    question_id?: true
    interview_id?: true
    question_text?: true
    question_type?: true
    ai_generated?: true
    asked_at?: true
  }

  export type AiInterviewQuestionCountAggregateInputType = {
    question_id?: true
    interview_id?: true
    question_text?: true
    question_type?: true
    ai_generated?: true
    asked_at?: true
    _all?: true
  }

  export type AiInterviewQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewQuestion to aggregate.
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewQuestions to fetch.
     */
    orderBy?: AiInterviewQuestionOrderByWithRelationInput | AiInterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviewQuestions
    **/
    _count?: true | AiInterviewQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewQuestionMaxAggregateInputType
  }

  export type GetAiInterviewQuestionAggregateType<T extends AiInterviewQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterviewQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterviewQuestion[P]>
      : GetScalarType<T[P], AggregateAiInterviewQuestion[P]>
  }




  export type AiInterviewQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewQuestionWhereInput
    orderBy?: AiInterviewQuestionOrderByWithAggregationInput | AiInterviewQuestionOrderByWithAggregationInput[]
    by: AiInterviewQuestionScalarFieldEnum[] | AiInterviewQuestionScalarFieldEnum
    having?: AiInterviewQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewQuestionCountAggregateInputType | true
    _avg?: AiInterviewQuestionAvgAggregateInputType
    _sum?: AiInterviewQuestionSumAggregateInputType
    _min?: AiInterviewQuestionMinAggregateInputType
    _max?: AiInterviewQuestionMaxAggregateInputType
  }

  export type AiInterviewQuestionGroupByOutputType = {
    question_id: number
    interview_id: number
    question_text: string | null
    question_type: string | null
    ai_generated: boolean | null
    asked_at: Date | null
    _count: AiInterviewQuestionCountAggregateOutputType | null
    _avg: AiInterviewQuestionAvgAggregateOutputType | null
    _sum: AiInterviewQuestionSumAggregateOutputType | null
    _min: AiInterviewQuestionMinAggregateOutputType | null
    _max: AiInterviewQuestionMaxAggregateOutputType | null
  }

  type GetAiInterviewQuestionGroupByPayload<T extends AiInterviewQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewQuestionGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    interview_id?: boolean
    question_text?: boolean
    question_type?: boolean
    ai_generated?: boolean
    asked_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    responses?: boolean | AiInterviewQuestion$responsesArgs<ExtArgs>
    _count?: boolean | AiInterviewQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewQuestion"]>

  export type AiInterviewQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    interview_id?: boolean
    question_text?: boolean
    question_type?: boolean
    ai_generated?: boolean
    asked_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewQuestion"]>

  export type AiInterviewQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    interview_id?: boolean
    question_text?: boolean
    question_type?: boolean
    ai_generated?: boolean
    asked_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewQuestion"]>

  export type AiInterviewQuestionSelectScalar = {
    question_id?: boolean
    interview_id?: boolean
    question_text?: boolean
    question_type?: boolean
    ai_generated?: boolean
    asked_at?: boolean
  }

  export type AiInterviewQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"question_id" | "interview_id" | "question_text" | "question_type" | "ai_generated" | "asked_at", ExtArgs["result"]["aiInterviewQuestion"]>
  export type AiInterviewQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    responses?: boolean | AiInterviewQuestion$responsesArgs<ExtArgs>
    _count?: boolean | AiInterviewQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiInterviewQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }

  export type $AiInterviewQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterviewQuestion"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
      responses: Prisma.$AiInterviewResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      question_id: number
      interview_id: number
      question_text: string | null
      question_type: string | null
      ai_generated: boolean | null
      asked_at: Date | null
    }, ExtArgs["result"]["aiInterviewQuestion"]>
    composites: {}
  }

  type AiInterviewQuestionGetPayload<S extends boolean | null | undefined | AiInterviewQuestionDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewQuestionPayload, S>

  type AiInterviewQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewQuestionCountAggregateInputType | true
    }

  export interface AiInterviewQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterviewQuestion'], meta: { name: 'AiInterviewQuestion' } }
    /**
     * Find zero or one AiInterviewQuestion that matches the filter.
     * @param {AiInterviewQuestionFindUniqueArgs} args - Arguments to find a AiInterviewQuestion
     * @example
     * // Get one AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewQuestionFindUniqueArgs>(args: SelectSubset<T, AiInterviewQuestionFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterviewQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewQuestionFindUniqueOrThrowArgs} args - Arguments to find a AiInterviewQuestion
     * @example
     * // Get one AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionFindFirstArgs} args - Arguments to find a AiInterviewQuestion
     * @example
     * // Get one AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewQuestionFindFirstArgs>(args?: SelectSubset<T, AiInterviewQuestionFindFirstArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionFindFirstOrThrowArgs} args - Arguments to find a AiInterviewQuestion
     * @example
     * // Get one AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviewQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviewQuestions
     * const aiInterviewQuestions = await prisma.aiInterviewQuestion.findMany()
     * 
     * // Get first 10 AiInterviewQuestions
     * const aiInterviewQuestions = await prisma.aiInterviewQuestion.findMany({ take: 10 })
     * 
     * // Only select the `question_id`
     * const aiInterviewQuestionWithQuestion_idOnly = await prisma.aiInterviewQuestion.findMany({ select: { question_id: true } })
     * 
     */
    findMany<T extends AiInterviewQuestionFindManyArgs>(args?: SelectSubset<T, AiInterviewQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterviewQuestion.
     * @param {AiInterviewQuestionCreateArgs} args - Arguments to create a AiInterviewQuestion.
     * @example
     * // Create one AiInterviewQuestion
     * const AiInterviewQuestion = await prisma.aiInterviewQuestion.create({
     *   data: {
     *     // ... data to create a AiInterviewQuestion
     *   }
     * })
     * 
     */
    create<T extends AiInterviewQuestionCreateArgs>(args: SelectSubset<T, AiInterviewQuestionCreateArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviewQuestions.
     * @param {AiInterviewQuestionCreateManyArgs} args - Arguments to create many AiInterviewQuestions.
     * @example
     * // Create many AiInterviewQuestions
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewQuestionCreateManyArgs>(args?: SelectSubset<T, AiInterviewQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviewQuestions and returns the data saved in the database.
     * @param {AiInterviewQuestionCreateManyAndReturnArgs} args - Arguments to create many AiInterviewQuestions.
     * @example
     * // Create many AiInterviewQuestions
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviewQuestions and only return the `question_id`
     * const aiInterviewQuestionWithQuestion_idOnly = await prisma.aiInterviewQuestion.createManyAndReturn({
     *   select: { question_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterviewQuestion.
     * @param {AiInterviewQuestionDeleteArgs} args - Arguments to delete one AiInterviewQuestion.
     * @example
     * // Delete one AiInterviewQuestion
     * const AiInterviewQuestion = await prisma.aiInterviewQuestion.delete({
     *   where: {
     *     // ... filter to delete one AiInterviewQuestion
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewQuestionDeleteArgs>(args: SelectSubset<T, AiInterviewQuestionDeleteArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterviewQuestion.
     * @param {AiInterviewQuestionUpdateArgs} args - Arguments to update one AiInterviewQuestion.
     * @example
     * // Update one AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewQuestionUpdateArgs>(args: SelectSubset<T, AiInterviewQuestionUpdateArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviewQuestions.
     * @param {AiInterviewQuestionDeleteManyArgs} args - Arguments to filter AiInterviewQuestions to delete.
     * @example
     * // Delete a few AiInterviewQuestions
     * const { count } = await prisma.aiInterviewQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewQuestionDeleteManyArgs>(args?: SelectSubset<T, AiInterviewQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviewQuestions
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewQuestionUpdateManyArgs>(args: SelectSubset<T, AiInterviewQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewQuestions and returns the data updated in the database.
     * @param {AiInterviewQuestionUpdateManyAndReturnArgs} args - Arguments to update many AiInterviewQuestions.
     * @example
     * // Update many AiInterviewQuestions
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviewQuestions and only return the `question_id`
     * const aiInterviewQuestionWithQuestion_idOnly = await prisma.aiInterviewQuestion.updateManyAndReturn({
     *   select: { question_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterviewQuestion.
     * @param {AiInterviewQuestionUpsertArgs} args - Arguments to update or create a AiInterviewQuestion.
     * @example
     * // Update or create a AiInterviewQuestion
     * const aiInterviewQuestion = await prisma.aiInterviewQuestion.upsert({
     *   create: {
     *     // ... data to create a AiInterviewQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterviewQuestion we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewQuestionUpsertArgs>(args: SelectSubset<T, AiInterviewQuestionUpsertArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviewQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionCountArgs} args - Arguments to filter AiInterviewQuestions to count.
     * @example
     * // Count the number of AiInterviewQuestions
     * const count = await prisma.aiInterviewQuestion.count({
     *   where: {
     *     // ... the filter for the AiInterviewQuestions we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewQuestionCountArgs>(
      args?: Subset<T, AiInterviewQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterviewQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewQuestionAggregateArgs>(args: Subset<T, AiInterviewQuestionAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewQuestionAggregateType<T>>

    /**
     * Group by AiInterviewQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewQuestionGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterviewQuestion model
   */
  readonly fields: AiInterviewQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterviewQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responses<T extends AiInterviewQuestion$responsesArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewQuestion$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterviewQuestion model
   */
  interface AiInterviewQuestionFieldRefs {
    readonly question_id: FieldRef<"AiInterviewQuestion", 'Int'>
    readonly interview_id: FieldRef<"AiInterviewQuestion", 'Int'>
    readonly question_text: FieldRef<"AiInterviewQuestion", 'String'>
    readonly question_type: FieldRef<"AiInterviewQuestion", 'String'>
    readonly ai_generated: FieldRef<"AiInterviewQuestion", 'Boolean'>
    readonly asked_at: FieldRef<"AiInterviewQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiInterviewQuestion findUnique
   */
  export type AiInterviewQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewQuestion to fetch.
     */
    where: AiInterviewQuestionWhereUniqueInput
  }

  /**
   * AiInterviewQuestion findUniqueOrThrow
   */
  export type AiInterviewQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewQuestion to fetch.
     */
    where: AiInterviewQuestionWhereUniqueInput
  }

  /**
   * AiInterviewQuestion findFirst
   */
  export type AiInterviewQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewQuestion to fetch.
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewQuestions to fetch.
     */
    orderBy?: AiInterviewQuestionOrderByWithRelationInput | AiInterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewQuestions.
     */
    cursor?: AiInterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewQuestions.
     */
    distinct?: AiInterviewQuestionScalarFieldEnum | AiInterviewQuestionScalarFieldEnum[]
  }

  /**
   * AiInterviewQuestion findFirstOrThrow
   */
  export type AiInterviewQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewQuestion to fetch.
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewQuestions to fetch.
     */
    orderBy?: AiInterviewQuestionOrderByWithRelationInput | AiInterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewQuestions.
     */
    cursor?: AiInterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewQuestions.
     */
    distinct?: AiInterviewQuestionScalarFieldEnum | AiInterviewQuestionScalarFieldEnum[]
  }

  /**
   * AiInterviewQuestion findMany
   */
  export type AiInterviewQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewQuestions to fetch.
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewQuestions to fetch.
     */
    orderBy?: AiInterviewQuestionOrderByWithRelationInput | AiInterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviewQuestions.
     */
    cursor?: AiInterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewQuestions.
     */
    skip?: number
    distinct?: AiInterviewQuestionScalarFieldEnum | AiInterviewQuestionScalarFieldEnum[]
  }

  /**
   * AiInterviewQuestion create
   */
  export type AiInterviewQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterviewQuestion.
     */
    data: XOR<AiInterviewQuestionCreateInput, AiInterviewQuestionUncheckedCreateInput>
  }

  /**
   * AiInterviewQuestion createMany
   */
  export type AiInterviewQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviewQuestions.
     */
    data: AiInterviewQuestionCreateManyInput | AiInterviewQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterviewQuestion createManyAndReturn
   */
  export type AiInterviewQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviewQuestions.
     */
    data: AiInterviewQuestionCreateManyInput | AiInterviewQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewQuestion update
   */
  export type AiInterviewQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterviewQuestion.
     */
    data: XOR<AiInterviewQuestionUpdateInput, AiInterviewQuestionUncheckedUpdateInput>
    /**
     * Choose, which AiInterviewQuestion to update.
     */
    where: AiInterviewQuestionWhereUniqueInput
  }

  /**
   * AiInterviewQuestion updateMany
   */
  export type AiInterviewQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviewQuestions.
     */
    data: XOR<AiInterviewQuestionUpdateManyMutationInput, AiInterviewQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewQuestions to update
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * Limit how many AiInterviewQuestions to update.
     */
    limit?: number
  }

  /**
   * AiInterviewQuestion updateManyAndReturn
   */
  export type AiInterviewQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviewQuestions.
     */
    data: XOR<AiInterviewQuestionUpdateManyMutationInput, AiInterviewQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewQuestions to update
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * Limit how many AiInterviewQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewQuestion upsert
   */
  export type AiInterviewQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterviewQuestion to update in case it exists.
     */
    where: AiInterviewQuestionWhereUniqueInput
    /**
     * In case the AiInterviewQuestion found by the `where` argument doesn't exist, create a new AiInterviewQuestion with this data.
     */
    create: XOR<AiInterviewQuestionCreateInput, AiInterviewQuestionUncheckedCreateInput>
    /**
     * In case the AiInterviewQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewQuestionUpdateInput, AiInterviewQuestionUncheckedUpdateInput>
  }

  /**
   * AiInterviewQuestion delete
   */
  export type AiInterviewQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter which AiInterviewQuestion to delete.
     */
    where: AiInterviewQuestionWhereUniqueInput
  }

  /**
   * AiInterviewQuestion deleteMany
   */
  export type AiInterviewQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewQuestions to delete
     */
    where?: AiInterviewQuestionWhereInput
    /**
     * Limit how many AiInterviewQuestions to delete.
     */
    limit?: number
  }

  /**
   * AiInterviewQuestion.responses
   */
  export type AiInterviewQuestion$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    where?: AiInterviewResponseWhereInput
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    cursor?: AiInterviewResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiInterviewResponseScalarFieldEnum | AiInterviewResponseScalarFieldEnum[]
  }

  /**
   * AiInterviewQuestion without action
   */
  export type AiInterviewQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewQuestion
     */
    select?: AiInterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewQuestion
     */
    omit?: AiInterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewQuestionInclude<ExtArgs> | null
  }


  /**
   * Model AiInterviewResponse
   */

  export type AggregateAiInterviewResponse = {
    _count: AiInterviewResponseCountAggregateOutputType | null
    _avg: AiInterviewResponseAvgAggregateOutputType | null
    _sum: AiInterviewResponseSumAggregateOutputType | null
    _min: AiInterviewResponseMinAggregateOutputType | null
    _max: AiInterviewResponseMaxAggregateOutputType | null
  }

  export type AiInterviewResponseAvgAggregateOutputType = {
    response_id: number | null
    interview_id: number | null
    question_id: number | null
  }

  export type AiInterviewResponseSumAggregateOutputType = {
    response_id: number | null
    interview_id: number | null
    question_id: number | null
  }

  export type AiInterviewResponseMinAggregateOutputType = {
    response_id: number | null
    interview_id: number | null
    question_id: number | null
    response_text: string | null
    response_audio_path: string | null
    response_video_path: string | null
    transcript: string | null
    captured_at: Date | null
  }

  export type AiInterviewResponseMaxAggregateOutputType = {
    response_id: number | null
    interview_id: number | null
    question_id: number | null
    response_text: string | null
    response_audio_path: string | null
    response_video_path: string | null
    transcript: string | null
    captured_at: Date | null
  }

  export type AiInterviewResponseCountAggregateOutputType = {
    response_id: number
    interview_id: number
    question_id: number
    response_text: number
    response_audio_path: number
    response_video_path: number
    transcript: number
    captured_at: number
    _all: number
  }


  export type AiInterviewResponseAvgAggregateInputType = {
    response_id?: true
    interview_id?: true
    question_id?: true
  }

  export type AiInterviewResponseSumAggregateInputType = {
    response_id?: true
    interview_id?: true
    question_id?: true
  }

  export type AiInterviewResponseMinAggregateInputType = {
    response_id?: true
    interview_id?: true
    question_id?: true
    response_text?: true
    response_audio_path?: true
    response_video_path?: true
    transcript?: true
    captured_at?: true
  }

  export type AiInterviewResponseMaxAggregateInputType = {
    response_id?: true
    interview_id?: true
    question_id?: true
    response_text?: true
    response_audio_path?: true
    response_video_path?: true
    transcript?: true
    captured_at?: true
  }

  export type AiInterviewResponseCountAggregateInputType = {
    response_id?: true
    interview_id?: true
    question_id?: true
    response_text?: true
    response_audio_path?: true
    response_video_path?: true
    transcript?: true
    captured_at?: true
    _all?: true
  }

  export type AiInterviewResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewResponse to aggregate.
     */
    where?: AiInterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewResponses to fetch.
     */
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviewResponses
    **/
    _count?: true | AiInterviewResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewResponseMaxAggregateInputType
  }

  export type GetAiInterviewResponseAggregateType<T extends AiInterviewResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterviewResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterviewResponse[P]>
      : GetScalarType<T[P], AggregateAiInterviewResponse[P]>
  }




  export type AiInterviewResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewResponseWhereInput
    orderBy?: AiInterviewResponseOrderByWithAggregationInput | AiInterviewResponseOrderByWithAggregationInput[]
    by: AiInterviewResponseScalarFieldEnum[] | AiInterviewResponseScalarFieldEnum
    having?: AiInterviewResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewResponseCountAggregateInputType | true
    _avg?: AiInterviewResponseAvgAggregateInputType
    _sum?: AiInterviewResponseSumAggregateInputType
    _min?: AiInterviewResponseMinAggregateInputType
    _max?: AiInterviewResponseMaxAggregateInputType
  }

  export type AiInterviewResponseGroupByOutputType = {
    response_id: number
    interview_id: number
    question_id: number
    response_text: string | null
    response_audio_path: string | null
    response_video_path: string | null
    transcript: string | null
    captured_at: Date | null
    _count: AiInterviewResponseCountAggregateOutputType | null
    _avg: AiInterviewResponseAvgAggregateOutputType | null
    _sum: AiInterviewResponseSumAggregateOutputType | null
    _min: AiInterviewResponseMinAggregateOutputType | null
    _max: AiInterviewResponseMaxAggregateOutputType | null
  }

  type GetAiInterviewResponseGroupByPayload<T extends AiInterviewResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewResponseGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewResponseGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    response_id?: boolean
    interview_id?: boolean
    question_id?: boolean
    response_text?: boolean
    response_audio_path?: boolean
    response_video_path?: boolean
    transcript?: boolean
    captured_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewResponse"]>

  export type AiInterviewResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    response_id?: boolean
    interview_id?: boolean
    question_id?: boolean
    response_text?: boolean
    response_audio_path?: boolean
    response_video_path?: boolean
    transcript?: boolean
    captured_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewResponse"]>

  export type AiInterviewResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    response_id?: boolean
    interview_id?: boolean
    question_id?: boolean
    response_text?: boolean
    response_audio_path?: boolean
    response_video_path?: boolean
    transcript?: boolean
    captured_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewResponse"]>

  export type AiInterviewResponseSelectScalar = {
    response_id?: boolean
    interview_id?: boolean
    question_id?: boolean
    response_text?: boolean
    response_audio_path?: boolean
    response_video_path?: boolean
    transcript?: boolean
    captured_at?: boolean
  }

  export type AiInterviewResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"response_id" | "interview_id" | "question_id" | "response_text" | "response_audio_path" | "response_video_path" | "transcript" | "captured_at", ExtArgs["result"]["aiInterviewResponse"]>
  export type AiInterviewResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }
  export type AiInterviewResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }
  export type AiInterviewResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
    question?: boolean | AiInterviewQuestionDefaultArgs<ExtArgs>
  }

  export type $AiInterviewResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterviewResponse"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
      question: Prisma.$AiInterviewQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      response_id: number
      interview_id: number
      question_id: number
      response_text: string | null
      response_audio_path: string | null
      response_video_path: string | null
      transcript: string | null
      captured_at: Date | null
    }, ExtArgs["result"]["aiInterviewResponse"]>
    composites: {}
  }

  type AiInterviewResponseGetPayload<S extends boolean | null | undefined | AiInterviewResponseDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewResponsePayload, S>

  type AiInterviewResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewResponseCountAggregateInputType | true
    }

  export interface AiInterviewResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterviewResponse'], meta: { name: 'AiInterviewResponse' } }
    /**
     * Find zero or one AiInterviewResponse that matches the filter.
     * @param {AiInterviewResponseFindUniqueArgs} args - Arguments to find a AiInterviewResponse
     * @example
     * // Get one AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewResponseFindUniqueArgs>(args: SelectSubset<T, AiInterviewResponseFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterviewResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewResponseFindUniqueOrThrowArgs} args - Arguments to find a AiInterviewResponse
     * @example
     * // Get one AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseFindFirstArgs} args - Arguments to find a AiInterviewResponse
     * @example
     * // Get one AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewResponseFindFirstArgs>(args?: SelectSubset<T, AiInterviewResponseFindFirstArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseFindFirstOrThrowArgs} args - Arguments to find a AiInterviewResponse
     * @example
     * // Get one AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviewResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviewResponses
     * const aiInterviewResponses = await prisma.aiInterviewResponse.findMany()
     * 
     * // Get first 10 AiInterviewResponses
     * const aiInterviewResponses = await prisma.aiInterviewResponse.findMany({ take: 10 })
     * 
     * // Only select the `response_id`
     * const aiInterviewResponseWithResponse_idOnly = await prisma.aiInterviewResponse.findMany({ select: { response_id: true } })
     * 
     */
    findMany<T extends AiInterviewResponseFindManyArgs>(args?: SelectSubset<T, AiInterviewResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterviewResponse.
     * @param {AiInterviewResponseCreateArgs} args - Arguments to create a AiInterviewResponse.
     * @example
     * // Create one AiInterviewResponse
     * const AiInterviewResponse = await prisma.aiInterviewResponse.create({
     *   data: {
     *     // ... data to create a AiInterviewResponse
     *   }
     * })
     * 
     */
    create<T extends AiInterviewResponseCreateArgs>(args: SelectSubset<T, AiInterviewResponseCreateArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviewResponses.
     * @param {AiInterviewResponseCreateManyArgs} args - Arguments to create many AiInterviewResponses.
     * @example
     * // Create many AiInterviewResponses
     * const aiInterviewResponse = await prisma.aiInterviewResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewResponseCreateManyArgs>(args?: SelectSubset<T, AiInterviewResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviewResponses and returns the data saved in the database.
     * @param {AiInterviewResponseCreateManyAndReturnArgs} args - Arguments to create many AiInterviewResponses.
     * @example
     * // Create many AiInterviewResponses
     * const aiInterviewResponse = await prisma.aiInterviewResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviewResponses and only return the `response_id`
     * const aiInterviewResponseWithResponse_idOnly = await prisma.aiInterviewResponse.createManyAndReturn({
     *   select: { response_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterviewResponse.
     * @param {AiInterviewResponseDeleteArgs} args - Arguments to delete one AiInterviewResponse.
     * @example
     * // Delete one AiInterviewResponse
     * const AiInterviewResponse = await prisma.aiInterviewResponse.delete({
     *   where: {
     *     // ... filter to delete one AiInterviewResponse
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewResponseDeleteArgs>(args: SelectSubset<T, AiInterviewResponseDeleteArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterviewResponse.
     * @param {AiInterviewResponseUpdateArgs} args - Arguments to update one AiInterviewResponse.
     * @example
     * // Update one AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewResponseUpdateArgs>(args: SelectSubset<T, AiInterviewResponseUpdateArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviewResponses.
     * @param {AiInterviewResponseDeleteManyArgs} args - Arguments to filter AiInterviewResponses to delete.
     * @example
     * // Delete a few AiInterviewResponses
     * const { count } = await prisma.aiInterviewResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewResponseDeleteManyArgs>(args?: SelectSubset<T, AiInterviewResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviewResponses
     * const aiInterviewResponse = await prisma.aiInterviewResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewResponseUpdateManyArgs>(args: SelectSubset<T, AiInterviewResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewResponses and returns the data updated in the database.
     * @param {AiInterviewResponseUpdateManyAndReturnArgs} args - Arguments to update many AiInterviewResponses.
     * @example
     * // Update many AiInterviewResponses
     * const aiInterviewResponse = await prisma.aiInterviewResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviewResponses and only return the `response_id`
     * const aiInterviewResponseWithResponse_idOnly = await prisma.aiInterviewResponse.updateManyAndReturn({
     *   select: { response_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterviewResponse.
     * @param {AiInterviewResponseUpsertArgs} args - Arguments to update or create a AiInterviewResponse.
     * @example
     * // Update or create a AiInterviewResponse
     * const aiInterviewResponse = await prisma.aiInterviewResponse.upsert({
     *   create: {
     *     // ... data to create a AiInterviewResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterviewResponse we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewResponseUpsertArgs>(args: SelectSubset<T, AiInterviewResponseUpsertArgs<ExtArgs>>): Prisma__AiInterviewResponseClient<$Result.GetResult<Prisma.$AiInterviewResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviewResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseCountArgs} args - Arguments to filter AiInterviewResponses to count.
     * @example
     * // Count the number of AiInterviewResponses
     * const count = await prisma.aiInterviewResponse.count({
     *   where: {
     *     // ... the filter for the AiInterviewResponses we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewResponseCountArgs>(
      args?: Subset<T, AiInterviewResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterviewResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewResponseAggregateArgs>(args: Subset<T, AiInterviewResponseAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewResponseAggregateType<T>>

    /**
     * Group by AiInterviewResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewResponseGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterviewResponse model
   */
  readonly fields: AiInterviewResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterviewResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends AiInterviewQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewQuestionDefaultArgs<ExtArgs>>): Prisma__AiInterviewQuestionClient<$Result.GetResult<Prisma.$AiInterviewQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterviewResponse model
   */
  interface AiInterviewResponseFieldRefs {
    readonly response_id: FieldRef<"AiInterviewResponse", 'Int'>
    readonly interview_id: FieldRef<"AiInterviewResponse", 'Int'>
    readonly question_id: FieldRef<"AiInterviewResponse", 'Int'>
    readonly response_text: FieldRef<"AiInterviewResponse", 'String'>
    readonly response_audio_path: FieldRef<"AiInterviewResponse", 'String'>
    readonly response_video_path: FieldRef<"AiInterviewResponse", 'String'>
    readonly transcript: FieldRef<"AiInterviewResponse", 'String'>
    readonly captured_at: FieldRef<"AiInterviewResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiInterviewResponse findUnique
   */
  export type AiInterviewResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewResponse to fetch.
     */
    where: AiInterviewResponseWhereUniqueInput
  }

  /**
   * AiInterviewResponse findUniqueOrThrow
   */
  export type AiInterviewResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewResponse to fetch.
     */
    where: AiInterviewResponseWhereUniqueInput
  }

  /**
   * AiInterviewResponse findFirst
   */
  export type AiInterviewResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewResponse to fetch.
     */
    where?: AiInterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewResponses to fetch.
     */
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewResponses.
     */
    cursor?: AiInterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewResponses.
     */
    distinct?: AiInterviewResponseScalarFieldEnum | AiInterviewResponseScalarFieldEnum[]
  }

  /**
   * AiInterviewResponse findFirstOrThrow
   */
  export type AiInterviewResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewResponse to fetch.
     */
    where?: AiInterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewResponses to fetch.
     */
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewResponses.
     */
    cursor?: AiInterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewResponses.
     */
    distinct?: AiInterviewResponseScalarFieldEnum | AiInterviewResponseScalarFieldEnum[]
  }

  /**
   * AiInterviewResponse findMany
   */
  export type AiInterviewResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewResponses to fetch.
     */
    where?: AiInterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewResponses to fetch.
     */
    orderBy?: AiInterviewResponseOrderByWithRelationInput | AiInterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviewResponses.
     */
    cursor?: AiInterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewResponses.
     */
    skip?: number
    distinct?: AiInterviewResponseScalarFieldEnum | AiInterviewResponseScalarFieldEnum[]
  }

  /**
   * AiInterviewResponse create
   */
  export type AiInterviewResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterviewResponse.
     */
    data: XOR<AiInterviewResponseCreateInput, AiInterviewResponseUncheckedCreateInput>
  }

  /**
   * AiInterviewResponse createMany
   */
  export type AiInterviewResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviewResponses.
     */
    data: AiInterviewResponseCreateManyInput | AiInterviewResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterviewResponse createManyAndReturn
   */
  export type AiInterviewResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviewResponses.
     */
    data: AiInterviewResponseCreateManyInput | AiInterviewResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewResponse update
   */
  export type AiInterviewResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterviewResponse.
     */
    data: XOR<AiInterviewResponseUpdateInput, AiInterviewResponseUncheckedUpdateInput>
    /**
     * Choose, which AiInterviewResponse to update.
     */
    where: AiInterviewResponseWhereUniqueInput
  }

  /**
   * AiInterviewResponse updateMany
   */
  export type AiInterviewResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviewResponses.
     */
    data: XOR<AiInterviewResponseUpdateManyMutationInput, AiInterviewResponseUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewResponses to update
     */
    where?: AiInterviewResponseWhereInput
    /**
     * Limit how many AiInterviewResponses to update.
     */
    limit?: number
  }

  /**
   * AiInterviewResponse updateManyAndReturn
   */
  export type AiInterviewResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviewResponses.
     */
    data: XOR<AiInterviewResponseUpdateManyMutationInput, AiInterviewResponseUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewResponses to update
     */
    where?: AiInterviewResponseWhereInput
    /**
     * Limit how many AiInterviewResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewResponse upsert
   */
  export type AiInterviewResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterviewResponse to update in case it exists.
     */
    where: AiInterviewResponseWhereUniqueInput
    /**
     * In case the AiInterviewResponse found by the `where` argument doesn't exist, create a new AiInterviewResponse with this data.
     */
    create: XOR<AiInterviewResponseCreateInput, AiInterviewResponseUncheckedCreateInput>
    /**
     * In case the AiInterviewResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewResponseUpdateInput, AiInterviewResponseUncheckedUpdateInput>
  }

  /**
   * AiInterviewResponse delete
   */
  export type AiInterviewResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
    /**
     * Filter which AiInterviewResponse to delete.
     */
    where: AiInterviewResponseWhereUniqueInput
  }

  /**
   * AiInterviewResponse deleteMany
   */
  export type AiInterviewResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewResponses to delete
     */
    where?: AiInterviewResponseWhereInput
    /**
     * Limit how many AiInterviewResponses to delete.
     */
    limit?: number
  }

  /**
   * AiInterviewResponse without action
   */
  export type AiInterviewResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewResponse
     */
    select?: AiInterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewResponse
     */
    omit?: AiInterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewResponseInclude<ExtArgs> | null
  }


  /**
   * Model AiInterviewCheatingEvent
   */

  export type AggregateAiInterviewCheatingEvent = {
    _count: AiInterviewCheatingEventCountAggregateOutputType | null
    _avg: AiInterviewCheatingEventAvgAggregateOutputType | null
    _sum: AiInterviewCheatingEventSumAggregateOutputType | null
    _min: AiInterviewCheatingEventMinAggregateOutputType | null
    _max: AiInterviewCheatingEventMaxAggregateOutputType | null
  }

  export type AiInterviewCheatingEventAvgAggregateOutputType = {
    event_id: number | null
    interview_id: number | null
    confidence_score: number | null
  }

  export type AiInterviewCheatingEventSumAggregateOutputType = {
    event_id: number | null
    interview_id: number | null
    confidence_score: number | null
  }

  export type AiInterviewCheatingEventMinAggregateOutputType = {
    event_id: number | null
    interview_id: number | null
    event_type: string | null
    confidence_score: number | null
    detected_at: Date | null
  }

  export type AiInterviewCheatingEventMaxAggregateOutputType = {
    event_id: number | null
    interview_id: number | null
    event_type: string | null
    confidence_score: number | null
    detected_at: Date | null
  }

  export type AiInterviewCheatingEventCountAggregateOutputType = {
    event_id: number
    interview_id: number
    event_type: number
    confidence_score: number
    detected_at: number
    _all: number
  }


  export type AiInterviewCheatingEventAvgAggregateInputType = {
    event_id?: true
    interview_id?: true
    confidence_score?: true
  }

  export type AiInterviewCheatingEventSumAggregateInputType = {
    event_id?: true
    interview_id?: true
    confidence_score?: true
  }

  export type AiInterviewCheatingEventMinAggregateInputType = {
    event_id?: true
    interview_id?: true
    event_type?: true
    confidence_score?: true
    detected_at?: true
  }

  export type AiInterviewCheatingEventMaxAggregateInputType = {
    event_id?: true
    interview_id?: true
    event_type?: true
    confidence_score?: true
    detected_at?: true
  }

  export type AiInterviewCheatingEventCountAggregateInputType = {
    event_id?: true
    interview_id?: true
    event_type?: true
    confidence_score?: true
    detected_at?: true
    _all?: true
  }

  export type AiInterviewCheatingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewCheatingEvent to aggregate.
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewCheatingEvents to fetch.
     */
    orderBy?: AiInterviewCheatingEventOrderByWithRelationInput | AiInterviewCheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewCheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewCheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewCheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviewCheatingEvents
    **/
    _count?: true | AiInterviewCheatingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewCheatingEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewCheatingEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewCheatingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewCheatingEventMaxAggregateInputType
  }

  export type GetAiInterviewCheatingEventAggregateType<T extends AiInterviewCheatingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterviewCheatingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterviewCheatingEvent[P]>
      : GetScalarType<T[P], AggregateAiInterviewCheatingEvent[P]>
  }




  export type AiInterviewCheatingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewCheatingEventWhereInput
    orderBy?: AiInterviewCheatingEventOrderByWithAggregationInput | AiInterviewCheatingEventOrderByWithAggregationInput[]
    by: AiInterviewCheatingEventScalarFieldEnum[] | AiInterviewCheatingEventScalarFieldEnum
    having?: AiInterviewCheatingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewCheatingEventCountAggregateInputType | true
    _avg?: AiInterviewCheatingEventAvgAggregateInputType
    _sum?: AiInterviewCheatingEventSumAggregateInputType
    _min?: AiInterviewCheatingEventMinAggregateInputType
    _max?: AiInterviewCheatingEventMaxAggregateInputType
  }

  export type AiInterviewCheatingEventGroupByOutputType = {
    event_id: number
    interview_id: number
    event_type: string | null
    confidence_score: number | null
    detected_at: Date | null
    _count: AiInterviewCheatingEventCountAggregateOutputType | null
    _avg: AiInterviewCheatingEventAvgAggregateOutputType | null
    _sum: AiInterviewCheatingEventSumAggregateOutputType | null
    _min: AiInterviewCheatingEventMinAggregateOutputType | null
    _max: AiInterviewCheatingEventMaxAggregateOutputType | null
  }

  type GetAiInterviewCheatingEventGroupByPayload<T extends AiInterviewCheatingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewCheatingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewCheatingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewCheatingEventGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewCheatingEventGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewCheatingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    interview_id?: boolean
    event_type?: boolean
    confidence_score?: boolean
    detected_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewCheatingEvent"]>

  export type AiInterviewCheatingEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    interview_id?: boolean
    event_type?: boolean
    confidence_score?: boolean
    detected_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewCheatingEvent"]>

  export type AiInterviewCheatingEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    interview_id?: boolean
    event_type?: boolean
    confidence_score?: boolean
    detected_at?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewCheatingEvent"]>

  export type AiInterviewCheatingEventSelectScalar = {
    event_id?: boolean
    interview_id?: boolean
    event_type?: boolean
    confidence_score?: boolean
    detected_at?: boolean
  }

  export type AiInterviewCheatingEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_id" | "interview_id" | "event_type" | "confidence_score" | "detected_at", ExtArgs["result"]["aiInterviewCheatingEvent"]>
  export type AiInterviewCheatingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewCheatingEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewCheatingEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }

  export type $AiInterviewCheatingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterviewCheatingEvent"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: number
      interview_id: number
      event_type: string | null
      confidence_score: number | null
      detected_at: Date | null
    }, ExtArgs["result"]["aiInterviewCheatingEvent"]>
    composites: {}
  }

  type AiInterviewCheatingEventGetPayload<S extends boolean | null | undefined | AiInterviewCheatingEventDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewCheatingEventPayload, S>

  type AiInterviewCheatingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewCheatingEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewCheatingEventCountAggregateInputType | true
    }

  export interface AiInterviewCheatingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterviewCheatingEvent'], meta: { name: 'AiInterviewCheatingEvent' } }
    /**
     * Find zero or one AiInterviewCheatingEvent that matches the filter.
     * @param {AiInterviewCheatingEventFindUniqueArgs} args - Arguments to find a AiInterviewCheatingEvent
     * @example
     * // Get one AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewCheatingEventFindUniqueArgs>(args: SelectSubset<T, AiInterviewCheatingEventFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterviewCheatingEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewCheatingEventFindUniqueOrThrowArgs} args - Arguments to find a AiInterviewCheatingEvent
     * @example
     * // Get one AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewCheatingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewCheatingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewCheatingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventFindFirstArgs} args - Arguments to find a AiInterviewCheatingEvent
     * @example
     * // Get one AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewCheatingEventFindFirstArgs>(args?: SelectSubset<T, AiInterviewCheatingEventFindFirstArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewCheatingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventFindFirstOrThrowArgs} args - Arguments to find a AiInterviewCheatingEvent
     * @example
     * // Get one AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewCheatingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewCheatingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviewCheatingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviewCheatingEvents
     * const aiInterviewCheatingEvents = await prisma.aiInterviewCheatingEvent.findMany()
     * 
     * // Get first 10 AiInterviewCheatingEvents
     * const aiInterviewCheatingEvents = await prisma.aiInterviewCheatingEvent.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const aiInterviewCheatingEventWithEvent_idOnly = await prisma.aiInterviewCheatingEvent.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends AiInterviewCheatingEventFindManyArgs>(args?: SelectSubset<T, AiInterviewCheatingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterviewCheatingEvent.
     * @param {AiInterviewCheatingEventCreateArgs} args - Arguments to create a AiInterviewCheatingEvent.
     * @example
     * // Create one AiInterviewCheatingEvent
     * const AiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.create({
     *   data: {
     *     // ... data to create a AiInterviewCheatingEvent
     *   }
     * })
     * 
     */
    create<T extends AiInterviewCheatingEventCreateArgs>(args: SelectSubset<T, AiInterviewCheatingEventCreateArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviewCheatingEvents.
     * @param {AiInterviewCheatingEventCreateManyArgs} args - Arguments to create many AiInterviewCheatingEvents.
     * @example
     * // Create many AiInterviewCheatingEvents
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewCheatingEventCreateManyArgs>(args?: SelectSubset<T, AiInterviewCheatingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviewCheatingEvents and returns the data saved in the database.
     * @param {AiInterviewCheatingEventCreateManyAndReturnArgs} args - Arguments to create many AiInterviewCheatingEvents.
     * @example
     * // Create many AiInterviewCheatingEvents
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviewCheatingEvents and only return the `event_id`
     * const aiInterviewCheatingEventWithEvent_idOnly = await prisma.aiInterviewCheatingEvent.createManyAndReturn({
     *   select: { event_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewCheatingEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewCheatingEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterviewCheatingEvent.
     * @param {AiInterviewCheatingEventDeleteArgs} args - Arguments to delete one AiInterviewCheatingEvent.
     * @example
     * // Delete one AiInterviewCheatingEvent
     * const AiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.delete({
     *   where: {
     *     // ... filter to delete one AiInterviewCheatingEvent
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewCheatingEventDeleteArgs>(args: SelectSubset<T, AiInterviewCheatingEventDeleteArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterviewCheatingEvent.
     * @param {AiInterviewCheatingEventUpdateArgs} args - Arguments to update one AiInterviewCheatingEvent.
     * @example
     * // Update one AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewCheatingEventUpdateArgs>(args: SelectSubset<T, AiInterviewCheatingEventUpdateArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviewCheatingEvents.
     * @param {AiInterviewCheatingEventDeleteManyArgs} args - Arguments to filter AiInterviewCheatingEvents to delete.
     * @example
     * // Delete a few AiInterviewCheatingEvents
     * const { count } = await prisma.aiInterviewCheatingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewCheatingEventDeleteManyArgs>(args?: SelectSubset<T, AiInterviewCheatingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewCheatingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviewCheatingEvents
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewCheatingEventUpdateManyArgs>(args: SelectSubset<T, AiInterviewCheatingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewCheatingEvents and returns the data updated in the database.
     * @param {AiInterviewCheatingEventUpdateManyAndReturnArgs} args - Arguments to update many AiInterviewCheatingEvents.
     * @example
     * // Update many AiInterviewCheatingEvents
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviewCheatingEvents and only return the `event_id`
     * const aiInterviewCheatingEventWithEvent_idOnly = await prisma.aiInterviewCheatingEvent.updateManyAndReturn({
     *   select: { event_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewCheatingEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewCheatingEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterviewCheatingEvent.
     * @param {AiInterviewCheatingEventUpsertArgs} args - Arguments to update or create a AiInterviewCheatingEvent.
     * @example
     * // Update or create a AiInterviewCheatingEvent
     * const aiInterviewCheatingEvent = await prisma.aiInterviewCheatingEvent.upsert({
     *   create: {
     *     // ... data to create a AiInterviewCheatingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterviewCheatingEvent we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewCheatingEventUpsertArgs>(args: SelectSubset<T, AiInterviewCheatingEventUpsertArgs<ExtArgs>>): Prisma__AiInterviewCheatingEventClient<$Result.GetResult<Prisma.$AiInterviewCheatingEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviewCheatingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventCountArgs} args - Arguments to filter AiInterviewCheatingEvents to count.
     * @example
     * // Count the number of AiInterviewCheatingEvents
     * const count = await prisma.aiInterviewCheatingEvent.count({
     *   where: {
     *     // ... the filter for the AiInterviewCheatingEvents we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewCheatingEventCountArgs>(
      args?: Subset<T, AiInterviewCheatingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewCheatingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterviewCheatingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewCheatingEventAggregateArgs>(args: Subset<T, AiInterviewCheatingEventAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewCheatingEventAggregateType<T>>

    /**
     * Group by AiInterviewCheatingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewCheatingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewCheatingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewCheatingEventGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewCheatingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewCheatingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewCheatingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterviewCheatingEvent model
   */
  readonly fields: AiInterviewCheatingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterviewCheatingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewCheatingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterviewCheatingEvent model
   */
  interface AiInterviewCheatingEventFieldRefs {
    readonly event_id: FieldRef<"AiInterviewCheatingEvent", 'Int'>
    readonly interview_id: FieldRef<"AiInterviewCheatingEvent", 'Int'>
    readonly event_type: FieldRef<"AiInterviewCheatingEvent", 'String'>
    readonly confidence_score: FieldRef<"AiInterviewCheatingEvent", 'Float'>
    readonly detected_at: FieldRef<"AiInterviewCheatingEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiInterviewCheatingEvent findUnique
   */
  export type AiInterviewCheatingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewCheatingEvent to fetch.
     */
    where: AiInterviewCheatingEventWhereUniqueInput
  }

  /**
   * AiInterviewCheatingEvent findUniqueOrThrow
   */
  export type AiInterviewCheatingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewCheatingEvent to fetch.
     */
    where: AiInterviewCheatingEventWhereUniqueInput
  }

  /**
   * AiInterviewCheatingEvent findFirst
   */
  export type AiInterviewCheatingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewCheatingEvent to fetch.
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewCheatingEvents to fetch.
     */
    orderBy?: AiInterviewCheatingEventOrderByWithRelationInput | AiInterviewCheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewCheatingEvents.
     */
    cursor?: AiInterviewCheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewCheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewCheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewCheatingEvents.
     */
    distinct?: AiInterviewCheatingEventScalarFieldEnum | AiInterviewCheatingEventScalarFieldEnum[]
  }

  /**
   * AiInterviewCheatingEvent findFirstOrThrow
   */
  export type AiInterviewCheatingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewCheatingEvent to fetch.
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewCheatingEvents to fetch.
     */
    orderBy?: AiInterviewCheatingEventOrderByWithRelationInput | AiInterviewCheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewCheatingEvents.
     */
    cursor?: AiInterviewCheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewCheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewCheatingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewCheatingEvents.
     */
    distinct?: AiInterviewCheatingEventScalarFieldEnum | AiInterviewCheatingEventScalarFieldEnum[]
  }

  /**
   * AiInterviewCheatingEvent findMany
   */
  export type AiInterviewCheatingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewCheatingEvents to fetch.
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewCheatingEvents to fetch.
     */
    orderBy?: AiInterviewCheatingEventOrderByWithRelationInput | AiInterviewCheatingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviewCheatingEvents.
     */
    cursor?: AiInterviewCheatingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewCheatingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewCheatingEvents.
     */
    skip?: number
    distinct?: AiInterviewCheatingEventScalarFieldEnum | AiInterviewCheatingEventScalarFieldEnum[]
  }

  /**
   * AiInterviewCheatingEvent create
   */
  export type AiInterviewCheatingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterviewCheatingEvent.
     */
    data: XOR<AiInterviewCheatingEventCreateInput, AiInterviewCheatingEventUncheckedCreateInput>
  }

  /**
   * AiInterviewCheatingEvent createMany
   */
  export type AiInterviewCheatingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviewCheatingEvents.
     */
    data: AiInterviewCheatingEventCreateManyInput | AiInterviewCheatingEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterviewCheatingEvent createManyAndReturn
   */
  export type AiInterviewCheatingEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviewCheatingEvents.
     */
    data: AiInterviewCheatingEventCreateManyInput | AiInterviewCheatingEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewCheatingEvent update
   */
  export type AiInterviewCheatingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterviewCheatingEvent.
     */
    data: XOR<AiInterviewCheatingEventUpdateInput, AiInterviewCheatingEventUncheckedUpdateInput>
    /**
     * Choose, which AiInterviewCheatingEvent to update.
     */
    where: AiInterviewCheatingEventWhereUniqueInput
  }

  /**
   * AiInterviewCheatingEvent updateMany
   */
  export type AiInterviewCheatingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviewCheatingEvents.
     */
    data: XOR<AiInterviewCheatingEventUpdateManyMutationInput, AiInterviewCheatingEventUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewCheatingEvents to update
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * Limit how many AiInterviewCheatingEvents to update.
     */
    limit?: number
  }

  /**
   * AiInterviewCheatingEvent updateManyAndReturn
   */
  export type AiInterviewCheatingEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviewCheatingEvents.
     */
    data: XOR<AiInterviewCheatingEventUpdateManyMutationInput, AiInterviewCheatingEventUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewCheatingEvents to update
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * Limit how many AiInterviewCheatingEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewCheatingEvent upsert
   */
  export type AiInterviewCheatingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterviewCheatingEvent to update in case it exists.
     */
    where: AiInterviewCheatingEventWhereUniqueInput
    /**
     * In case the AiInterviewCheatingEvent found by the `where` argument doesn't exist, create a new AiInterviewCheatingEvent with this data.
     */
    create: XOR<AiInterviewCheatingEventCreateInput, AiInterviewCheatingEventUncheckedCreateInput>
    /**
     * In case the AiInterviewCheatingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewCheatingEventUpdateInput, AiInterviewCheatingEventUncheckedUpdateInput>
  }

  /**
   * AiInterviewCheatingEvent delete
   */
  export type AiInterviewCheatingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
    /**
     * Filter which AiInterviewCheatingEvent to delete.
     */
    where: AiInterviewCheatingEventWhereUniqueInput
  }

  /**
   * AiInterviewCheatingEvent deleteMany
   */
  export type AiInterviewCheatingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewCheatingEvents to delete
     */
    where?: AiInterviewCheatingEventWhereInput
    /**
     * Limit how many AiInterviewCheatingEvents to delete.
     */
    limit?: number
  }

  /**
   * AiInterviewCheatingEvent without action
   */
  export type AiInterviewCheatingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewCheatingEvent
     */
    select?: AiInterviewCheatingEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewCheatingEvent
     */
    omit?: AiInterviewCheatingEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewCheatingEventInclude<ExtArgs> | null
  }


  /**
   * Model AiInterviewPostureData
   */

  export type AggregateAiInterviewPostureData = {
    _count: AiInterviewPostureDataCountAggregateOutputType | null
    _avg: AiInterviewPostureDataAvgAggregateOutputType | null
    _sum: AiInterviewPostureDataSumAggregateOutputType | null
    _min: AiInterviewPostureDataMinAggregateOutputType | null
    _max: AiInterviewPostureDataMaxAggregateOutputType | null
  }

  export type AiInterviewPostureDataAvgAggregateOutputType = {
    posture_id: number | null
    interview_id: number | null
  }

  export type AiInterviewPostureDataSumAggregateOutputType = {
    posture_id: number | null
    interview_id: number | null
  }

  export type AiInterviewPostureDataMinAggregateOutputType = {
    posture_id: number | null
    interview_id: number | null
    timestamp: Date | null
  }

  export type AiInterviewPostureDataMaxAggregateOutputType = {
    posture_id: number | null
    interview_id: number | null
    timestamp: Date | null
  }

  export type AiInterviewPostureDataCountAggregateOutputType = {
    posture_id: number
    interview_id: number
    timestamp: number
    posture_data: number
    _all: number
  }


  export type AiInterviewPostureDataAvgAggregateInputType = {
    posture_id?: true
    interview_id?: true
  }

  export type AiInterviewPostureDataSumAggregateInputType = {
    posture_id?: true
    interview_id?: true
  }

  export type AiInterviewPostureDataMinAggregateInputType = {
    posture_id?: true
    interview_id?: true
    timestamp?: true
  }

  export type AiInterviewPostureDataMaxAggregateInputType = {
    posture_id?: true
    interview_id?: true
    timestamp?: true
  }

  export type AiInterviewPostureDataCountAggregateInputType = {
    posture_id?: true
    interview_id?: true
    timestamp?: true
    posture_data?: true
    _all?: true
  }

  export type AiInterviewPostureDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewPostureData to aggregate.
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewPostureData to fetch.
     */
    orderBy?: AiInterviewPostureDataOrderByWithRelationInput | AiInterviewPostureDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewPostureDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewPostureData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewPostureData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviewPostureData
    **/
    _count?: true | AiInterviewPostureDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewPostureDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewPostureDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewPostureDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewPostureDataMaxAggregateInputType
  }

  export type GetAiInterviewPostureDataAggregateType<T extends AiInterviewPostureDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterviewPostureData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterviewPostureData[P]>
      : GetScalarType<T[P], AggregateAiInterviewPostureData[P]>
  }




  export type AiInterviewPostureDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewPostureDataWhereInput
    orderBy?: AiInterviewPostureDataOrderByWithAggregationInput | AiInterviewPostureDataOrderByWithAggregationInput[]
    by: AiInterviewPostureDataScalarFieldEnum[] | AiInterviewPostureDataScalarFieldEnum
    having?: AiInterviewPostureDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewPostureDataCountAggregateInputType | true
    _avg?: AiInterviewPostureDataAvgAggregateInputType
    _sum?: AiInterviewPostureDataSumAggregateInputType
    _min?: AiInterviewPostureDataMinAggregateInputType
    _max?: AiInterviewPostureDataMaxAggregateInputType
  }

  export type AiInterviewPostureDataGroupByOutputType = {
    posture_id: number
    interview_id: number
    timestamp: Date | null
    posture_data: JsonValue | null
    _count: AiInterviewPostureDataCountAggregateOutputType | null
    _avg: AiInterviewPostureDataAvgAggregateOutputType | null
    _sum: AiInterviewPostureDataSumAggregateOutputType | null
    _min: AiInterviewPostureDataMinAggregateOutputType | null
    _max: AiInterviewPostureDataMaxAggregateOutputType | null
  }

  type GetAiInterviewPostureDataGroupByPayload<T extends AiInterviewPostureDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewPostureDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewPostureDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewPostureDataGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewPostureDataGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewPostureDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    posture_id?: boolean
    interview_id?: boolean
    timestamp?: boolean
    posture_data?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewPostureData"]>

  export type AiInterviewPostureDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    posture_id?: boolean
    interview_id?: boolean
    timestamp?: boolean
    posture_data?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewPostureData"]>

  export type AiInterviewPostureDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    posture_id?: boolean
    interview_id?: boolean
    timestamp?: boolean
    posture_data?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewPostureData"]>

  export type AiInterviewPostureDataSelectScalar = {
    posture_id?: boolean
    interview_id?: boolean
    timestamp?: boolean
    posture_data?: boolean
  }

  export type AiInterviewPostureDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"posture_id" | "interview_id" | "timestamp" | "posture_data", ExtArgs["result"]["aiInterviewPostureData"]>
  export type AiInterviewPostureDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewPostureDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewPostureDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }

  export type $AiInterviewPostureDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterviewPostureData"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      posture_id: number
      interview_id: number
      timestamp: Date | null
      posture_data: Prisma.JsonValue | null
    }, ExtArgs["result"]["aiInterviewPostureData"]>
    composites: {}
  }

  type AiInterviewPostureDataGetPayload<S extends boolean | null | undefined | AiInterviewPostureDataDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewPostureDataPayload, S>

  type AiInterviewPostureDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewPostureDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewPostureDataCountAggregateInputType | true
    }

  export interface AiInterviewPostureDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterviewPostureData'], meta: { name: 'AiInterviewPostureData' } }
    /**
     * Find zero or one AiInterviewPostureData that matches the filter.
     * @param {AiInterviewPostureDataFindUniqueArgs} args - Arguments to find a AiInterviewPostureData
     * @example
     * // Get one AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewPostureDataFindUniqueArgs>(args: SelectSubset<T, AiInterviewPostureDataFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterviewPostureData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewPostureDataFindUniqueOrThrowArgs} args - Arguments to find a AiInterviewPostureData
     * @example
     * // Get one AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewPostureDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewPostureDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewPostureData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataFindFirstArgs} args - Arguments to find a AiInterviewPostureData
     * @example
     * // Get one AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewPostureDataFindFirstArgs>(args?: SelectSubset<T, AiInterviewPostureDataFindFirstArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewPostureData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataFindFirstOrThrowArgs} args - Arguments to find a AiInterviewPostureData
     * @example
     * // Get one AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewPostureDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewPostureDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviewPostureData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findMany()
     * 
     * // Get first 10 AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.findMany({ take: 10 })
     * 
     * // Only select the `posture_id`
     * const aiInterviewPostureDataWithPosture_idOnly = await prisma.aiInterviewPostureData.findMany({ select: { posture_id: true } })
     * 
     */
    findMany<T extends AiInterviewPostureDataFindManyArgs>(args?: SelectSubset<T, AiInterviewPostureDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterviewPostureData.
     * @param {AiInterviewPostureDataCreateArgs} args - Arguments to create a AiInterviewPostureData.
     * @example
     * // Create one AiInterviewPostureData
     * const AiInterviewPostureData = await prisma.aiInterviewPostureData.create({
     *   data: {
     *     // ... data to create a AiInterviewPostureData
     *   }
     * })
     * 
     */
    create<T extends AiInterviewPostureDataCreateArgs>(args: SelectSubset<T, AiInterviewPostureDataCreateArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviewPostureData.
     * @param {AiInterviewPostureDataCreateManyArgs} args - Arguments to create many AiInterviewPostureData.
     * @example
     * // Create many AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewPostureDataCreateManyArgs>(args?: SelectSubset<T, AiInterviewPostureDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviewPostureData and returns the data saved in the database.
     * @param {AiInterviewPostureDataCreateManyAndReturnArgs} args - Arguments to create many AiInterviewPostureData.
     * @example
     * // Create many AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviewPostureData and only return the `posture_id`
     * const aiInterviewPostureDataWithPosture_idOnly = await prisma.aiInterviewPostureData.createManyAndReturn({
     *   select: { posture_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewPostureDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewPostureDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterviewPostureData.
     * @param {AiInterviewPostureDataDeleteArgs} args - Arguments to delete one AiInterviewPostureData.
     * @example
     * // Delete one AiInterviewPostureData
     * const AiInterviewPostureData = await prisma.aiInterviewPostureData.delete({
     *   where: {
     *     // ... filter to delete one AiInterviewPostureData
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewPostureDataDeleteArgs>(args: SelectSubset<T, AiInterviewPostureDataDeleteArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterviewPostureData.
     * @param {AiInterviewPostureDataUpdateArgs} args - Arguments to update one AiInterviewPostureData.
     * @example
     * // Update one AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewPostureDataUpdateArgs>(args: SelectSubset<T, AiInterviewPostureDataUpdateArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviewPostureData.
     * @param {AiInterviewPostureDataDeleteManyArgs} args - Arguments to filter AiInterviewPostureData to delete.
     * @example
     * // Delete a few AiInterviewPostureData
     * const { count } = await prisma.aiInterviewPostureData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewPostureDataDeleteManyArgs>(args?: SelectSubset<T, AiInterviewPostureDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewPostureData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewPostureDataUpdateManyArgs>(args: SelectSubset<T, AiInterviewPostureDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewPostureData and returns the data updated in the database.
     * @param {AiInterviewPostureDataUpdateManyAndReturnArgs} args - Arguments to update many AiInterviewPostureData.
     * @example
     * // Update many AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviewPostureData and only return the `posture_id`
     * const aiInterviewPostureDataWithPosture_idOnly = await prisma.aiInterviewPostureData.updateManyAndReturn({
     *   select: { posture_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewPostureDataUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewPostureDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterviewPostureData.
     * @param {AiInterviewPostureDataUpsertArgs} args - Arguments to update or create a AiInterviewPostureData.
     * @example
     * // Update or create a AiInterviewPostureData
     * const aiInterviewPostureData = await prisma.aiInterviewPostureData.upsert({
     *   create: {
     *     // ... data to create a AiInterviewPostureData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterviewPostureData we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewPostureDataUpsertArgs>(args: SelectSubset<T, AiInterviewPostureDataUpsertArgs<ExtArgs>>): Prisma__AiInterviewPostureDataClient<$Result.GetResult<Prisma.$AiInterviewPostureDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviewPostureData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataCountArgs} args - Arguments to filter AiInterviewPostureData to count.
     * @example
     * // Count the number of AiInterviewPostureData
     * const count = await prisma.aiInterviewPostureData.count({
     *   where: {
     *     // ... the filter for the AiInterviewPostureData we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewPostureDataCountArgs>(
      args?: Subset<T, AiInterviewPostureDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewPostureDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterviewPostureData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewPostureDataAggregateArgs>(args: Subset<T, AiInterviewPostureDataAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewPostureDataAggregateType<T>>

    /**
     * Group by AiInterviewPostureData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewPostureDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewPostureDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewPostureDataGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewPostureDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewPostureDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewPostureDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterviewPostureData model
   */
  readonly fields: AiInterviewPostureDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterviewPostureData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewPostureDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterviewPostureData model
   */
  interface AiInterviewPostureDataFieldRefs {
    readonly posture_id: FieldRef<"AiInterviewPostureData", 'Int'>
    readonly interview_id: FieldRef<"AiInterviewPostureData", 'Int'>
    readonly timestamp: FieldRef<"AiInterviewPostureData", 'DateTime'>
    readonly posture_data: FieldRef<"AiInterviewPostureData", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AiInterviewPostureData findUnique
   */
  export type AiInterviewPostureDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewPostureData to fetch.
     */
    where: AiInterviewPostureDataWhereUniqueInput
  }

  /**
   * AiInterviewPostureData findUniqueOrThrow
   */
  export type AiInterviewPostureDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewPostureData to fetch.
     */
    where: AiInterviewPostureDataWhereUniqueInput
  }

  /**
   * AiInterviewPostureData findFirst
   */
  export type AiInterviewPostureDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewPostureData to fetch.
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewPostureData to fetch.
     */
    orderBy?: AiInterviewPostureDataOrderByWithRelationInput | AiInterviewPostureDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewPostureData.
     */
    cursor?: AiInterviewPostureDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewPostureData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewPostureData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewPostureData.
     */
    distinct?: AiInterviewPostureDataScalarFieldEnum | AiInterviewPostureDataScalarFieldEnum[]
  }

  /**
   * AiInterviewPostureData findFirstOrThrow
   */
  export type AiInterviewPostureDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewPostureData to fetch.
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewPostureData to fetch.
     */
    orderBy?: AiInterviewPostureDataOrderByWithRelationInput | AiInterviewPostureDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewPostureData.
     */
    cursor?: AiInterviewPostureDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewPostureData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewPostureData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewPostureData.
     */
    distinct?: AiInterviewPostureDataScalarFieldEnum | AiInterviewPostureDataScalarFieldEnum[]
  }

  /**
   * AiInterviewPostureData findMany
   */
  export type AiInterviewPostureDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewPostureData to fetch.
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewPostureData to fetch.
     */
    orderBy?: AiInterviewPostureDataOrderByWithRelationInput | AiInterviewPostureDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviewPostureData.
     */
    cursor?: AiInterviewPostureDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewPostureData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewPostureData.
     */
    skip?: number
    distinct?: AiInterviewPostureDataScalarFieldEnum | AiInterviewPostureDataScalarFieldEnum[]
  }

  /**
   * AiInterviewPostureData create
   */
  export type AiInterviewPostureDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterviewPostureData.
     */
    data: XOR<AiInterviewPostureDataCreateInput, AiInterviewPostureDataUncheckedCreateInput>
  }

  /**
   * AiInterviewPostureData createMany
   */
  export type AiInterviewPostureDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviewPostureData.
     */
    data: AiInterviewPostureDataCreateManyInput | AiInterviewPostureDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterviewPostureData createManyAndReturn
   */
  export type AiInterviewPostureDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviewPostureData.
     */
    data: AiInterviewPostureDataCreateManyInput | AiInterviewPostureDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewPostureData update
   */
  export type AiInterviewPostureDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterviewPostureData.
     */
    data: XOR<AiInterviewPostureDataUpdateInput, AiInterviewPostureDataUncheckedUpdateInput>
    /**
     * Choose, which AiInterviewPostureData to update.
     */
    where: AiInterviewPostureDataWhereUniqueInput
  }

  /**
   * AiInterviewPostureData updateMany
   */
  export type AiInterviewPostureDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviewPostureData.
     */
    data: XOR<AiInterviewPostureDataUpdateManyMutationInput, AiInterviewPostureDataUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewPostureData to update
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * Limit how many AiInterviewPostureData to update.
     */
    limit?: number
  }

  /**
   * AiInterviewPostureData updateManyAndReturn
   */
  export type AiInterviewPostureDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviewPostureData.
     */
    data: XOR<AiInterviewPostureDataUpdateManyMutationInput, AiInterviewPostureDataUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewPostureData to update
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * Limit how many AiInterviewPostureData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewPostureData upsert
   */
  export type AiInterviewPostureDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterviewPostureData to update in case it exists.
     */
    where: AiInterviewPostureDataWhereUniqueInput
    /**
     * In case the AiInterviewPostureData found by the `where` argument doesn't exist, create a new AiInterviewPostureData with this data.
     */
    create: XOR<AiInterviewPostureDataCreateInput, AiInterviewPostureDataUncheckedCreateInput>
    /**
     * In case the AiInterviewPostureData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewPostureDataUpdateInput, AiInterviewPostureDataUncheckedUpdateInput>
  }

  /**
   * AiInterviewPostureData delete
   */
  export type AiInterviewPostureDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
    /**
     * Filter which AiInterviewPostureData to delete.
     */
    where: AiInterviewPostureDataWhereUniqueInput
  }

  /**
   * AiInterviewPostureData deleteMany
   */
  export type AiInterviewPostureDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewPostureData to delete
     */
    where?: AiInterviewPostureDataWhereInput
    /**
     * Limit how many AiInterviewPostureData to delete.
     */
    limit?: number
  }

  /**
   * AiInterviewPostureData without action
   */
  export type AiInterviewPostureDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewPostureData
     */
    select?: AiInterviewPostureDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewPostureData
     */
    omit?: AiInterviewPostureDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewPostureDataInclude<ExtArgs> | null
  }


  /**
   * Model AiVoicePrompt
   */

  export type AggregateAiVoicePrompt = {
    _count: AiVoicePromptCountAggregateOutputType | null
    _avg: AiVoicePromptAvgAggregateOutputType | null
    _sum: AiVoicePromptSumAggregateOutputType | null
    _min: AiVoicePromptMinAggregateOutputType | null
    _max: AiVoicePromptMaxAggregateOutputType | null
  }

  export type AiVoicePromptAvgAggregateOutputType = {
    prompt_id: number | null
    interview_id: number | null
  }

  export type AiVoicePromptSumAggregateOutputType = {
    prompt_id: number | null
    interview_id: number | null
  }

  export type AiVoicePromptMinAggregateOutputType = {
    prompt_id: number | null
    interview_id: number | null
    prompt_text: string | null
    prompt_audio_path: string | null
  }

  export type AiVoicePromptMaxAggregateOutputType = {
    prompt_id: number | null
    interview_id: number | null
    prompt_text: string | null
    prompt_audio_path: string | null
  }

  export type AiVoicePromptCountAggregateOutputType = {
    prompt_id: number
    interview_id: number
    prompt_text: number
    prompt_audio_path: number
    _all: number
  }


  export type AiVoicePromptAvgAggregateInputType = {
    prompt_id?: true
    interview_id?: true
  }

  export type AiVoicePromptSumAggregateInputType = {
    prompt_id?: true
    interview_id?: true
  }

  export type AiVoicePromptMinAggregateInputType = {
    prompt_id?: true
    interview_id?: true
    prompt_text?: true
    prompt_audio_path?: true
  }

  export type AiVoicePromptMaxAggregateInputType = {
    prompt_id?: true
    interview_id?: true
    prompt_text?: true
    prompt_audio_path?: true
  }

  export type AiVoicePromptCountAggregateInputType = {
    prompt_id?: true
    interview_id?: true
    prompt_text?: true
    prompt_audio_path?: true
    _all?: true
  }

  export type AiVoicePromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiVoicePrompt to aggregate.
     */
    where?: AiVoicePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiVoicePrompts to fetch.
     */
    orderBy?: AiVoicePromptOrderByWithRelationInput | AiVoicePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiVoicePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiVoicePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiVoicePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiVoicePrompts
    **/
    _count?: true | AiVoicePromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiVoicePromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiVoicePromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiVoicePromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiVoicePromptMaxAggregateInputType
  }

  export type GetAiVoicePromptAggregateType<T extends AiVoicePromptAggregateArgs> = {
        [P in keyof T & keyof AggregateAiVoicePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiVoicePrompt[P]>
      : GetScalarType<T[P], AggregateAiVoicePrompt[P]>
  }




  export type AiVoicePromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiVoicePromptWhereInput
    orderBy?: AiVoicePromptOrderByWithAggregationInput | AiVoicePromptOrderByWithAggregationInput[]
    by: AiVoicePromptScalarFieldEnum[] | AiVoicePromptScalarFieldEnum
    having?: AiVoicePromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiVoicePromptCountAggregateInputType | true
    _avg?: AiVoicePromptAvgAggregateInputType
    _sum?: AiVoicePromptSumAggregateInputType
    _min?: AiVoicePromptMinAggregateInputType
    _max?: AiVoicePromptMaxAggregateInputType
  }

  export type AiVoicePromptGroupByOutputType = {
    prompt_id: number
    interview_id: number
    prompt_text: string | null
    prompt_audio_path: string | null
    _count: AiVoicePromptCountAggregateOutputType | null
    _avg: AiVoicePromptAvgAggregateOutputType | null
    _sum: AiVoicePromptSumAggregateOutputType | null
    _min: AiVoicePromptMinAggregateOutputType | null
    _max: AiVoicePromptMaxAggregateOutputType | null
  }

  type GetAiVoicePromptGroupByPayload<T extends AiVoicePromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiVoicePromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiVoicePromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiVoicePromptGroupByOutputType[P]>
            : GetScalarType<T[P], AiVoicePromptGroupByOutputType[P]>
        }
      >
    >


  export type AiVoicePromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prompt_id?: boolean
    interview_id?: boolean
    prompt_text?: boolean
    prompt_audio_path?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiVoicePrompt"]>

  export type AiVoicePromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prompt_id?: boolean
    interview_id?: boolean
    prompt_text?: boolean
    prompt_audio_path?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiVoicePrompt"]>

  export type AiVoicePromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prompt_id?: boolean
    interview_id?: boolean
    prompt_text?: boolean
    prompt_audio_path?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiVoicePrompt"]>

  export type AiVoicePromptSelectScalar = {
    prompt_id?: boolean
    interview_id?: boolean
    prompt_text?: boolean
    prompt_audio_path?: boolean
  }

  export type AiVoicePromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"prompt_id" | "interview_id" | "prompt_text" | "prompt_audio_path", ExtArgs["result"]["aiVoicePrompt"]>
  export type AiVoicePromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiVoicePromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiVoicePromptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }

  export type $AiVoicePromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiVoicePrompt"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      prompt_id: number
      interview_id: number
      prompt_text: string | null
      prompt_audio_path: string | null
    }, ExtArgs["result"]["aiVoicePrompt"]>
    composites: {}
  }

  type AiVoicePromptGetPayload<S extends boolean | null | undefined | AiVoicePromptDefaultArgs> = $Result.GetResult<Prisma.$AiVoicePromptPayload, S>

  type AiVoicePromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiVoicePromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiVoicePromptCountAggregateInputType | true
    }

  export interface AiVoicePromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiVoicePrompt'], meta: { name: 'AiVoicePrompt' } }
    /**
     * Find zero or one AiVoicePrompt that matches the filter.
     * @param {AiVoicePromptFindUniqueArgs} args - Arguments to find a AiVoicePrompt
     * @example
     * // Get one AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiVoicePromptFindUniqueArgs>(args: SelectSubset<T, AiVoicePromptFindUniqueArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiVoicePrompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiVoicePromptFindUniqueOrThrowArgs} args - Arguments to find a AiVoicePrompt
     * @example
     * // Get one AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiVoicePromptFindUniqueOrThrowArgs>(args: SelectSubset<T, AiVoicePromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiVoicePrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptFindFirstArgs} args - Arguments to find a AiVoicePrompt
     * @example
     * // Get one AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiVoicePromptFindFirstArgs>(args?: SelectSubset<T, AiVoicePromptFindFirstArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiVoicePrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptFindFirstOrThrowArgs} args - Arguments to find a AiVoicePrompt
     * @example
     * // Get one AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiVoicePromptFindFirstOrThrowArgs>(args?: SelectSubset<T, AiVoicePromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiVoicePrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiVoicePrompts
     * const aiVoicePrompts = await prisma.aiVoicePrompt.findMany()
     * 
     * // Get first 10 AiVoicePrompts
     * const aiVoicePrompts = await prisma.aiVoicePrompt.findMany({ take: 10 })
     * 
     * // Only select the `prompt_id`
     * const aiVoicePromptWithPrompt_idOnly = await prisma.aiVoicePrompt.findMany({ select: { prompt_id: true } })
     * 
     */
    findMany<T extends AiVoicePromptFindManyArgs>(args?: SelectSubset<T, AiVoicePromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiVoicePrompt.
     * @param {AiVoicePromptCreateArgs} args - Arguments to create a AiVoicePrompt.
     * @example
     * // Create one AiVoicePrompt
     * const AiVoicePrompt = await prisma.aiVoicePrompt.create({
     *   data: {
     *     // ... data to create a AiVoicePrompt
     *   }
     * })
     * 
     */
    create<T extends AiVoicePromptCreateArgs>(args: SelectSubset<T, AiVoicePromptCreateArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiVoicePrompts.
     * @param {AiVoicePromptCreateManyArgs} args - Arguments to create many AiVoicePrompts.
     * @example
     * // Create many AiVoicePrompts
     * const aiVoicePrompt = await prisma.aiVoicePrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiVoicePromptCreateManyArgs>(args?: SelectSubset<T, AiVoicePromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiVoicePrompts and returns the data saved in the database.
     * @param {AiVoicePromptCreateManyAndReturnArgs} args - Arguments to create many AiVoicePrompts.
     * @example
     * // Create many AiVoicePrompts
     * const aiVoicePrompt = await prisma.aiVoicePrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiVoicePrompts and only return the `prompt_id`
     * const aiVoicePromptWithPrompt_idOnly = await prisma.aiVoicePrompt.createManyAndReturn({
     *   select: { prompt_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiVoicePromptCreateManyAndReturnArgs>(args?: SelectSubset<T, AiVoicePromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiVoicePrompt.
     * @param {AiVoicePromptDeleteArgs} args - Arguments to delete one AiVoicePrompt.
     * @example
     * // Delete one AiVoicePrompt
     * const AiVoicePrompt = await prisma.aiVoicePrompt.delete({
     *   where: {
     *     // ... filter to delete one AiVoicePrompt
     *   }
     * })
     * 
     */
    delete<T extends AiVoicePromptDeleteArgs>(args: SelectSubset<T, AiVoicePromptDeleteArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiVoicePrompt.
     * @param {AiVoicePromptUpdateArgs} args - Arguments to update one AiVoicePrompt.
     * @example
     * // Update one AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiVoicePromptUpdateArgs>(args: SelectSubset<T, AiVoicePromptUpdateArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiVoicePrompts.
     * @param {AiVoicePromptDeleteManyArgs} args - Arguments to filter AiVoicePrompts to delete.
     * @example
     * // Delete a few AiVoicePrompts
     * const { count } = await prisma.aiVoicePrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiVoicePromptDeleteManyArgs>(args?: SelectSubset<T, AiVoicePromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiVoicePrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiVoicePrompts
     * const aiVoicePrompt = await prisma.aiVoicePrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiVoicePromptUpdateManyArgs>(args: SelectSubset<T, AiVoicePromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiVoicePrompts and returns the data updated in the database.
     * @param {AiVoicePromptUpdateManyAndReturnArgs} args - Arguments to update many AiVoicePrompts.
     * @example
     * // Update many AiVoicePrompts
     * const aiVoicePrompt = await prisma.aiVoicePrompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiVoicePrompts and only return the `prompt_id`
     * const aiVoicePromptWithPrompt_idOnly = await prisma.aiVoicePrompt.updateManyAndReturn({
     *   select: { prompt_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiVoicePromptUpdateManyAndReturnArgs>(args: SelectSubset<T, AiVoicePromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiVoicePrompt.
     * @param {AiVoicePromptUpsertArgs} args - Arguments to update or create a AiVoicePrompt.
     * @example
     * // Update or create a AiVoicePrompt
     * const aiVoicePrompt = await prisma.aiVoicePrompt.upsert({
     *   create: {
     *     // ... data to create a AiVoicePrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiVoicePrompt we want to update
     *   }
     * })
     */
    upsert<T extends AiVoicePromptUpsertArgs>(args: SelectSubset<T, AiVoicePromptUpsertArgs<ExtArgs>>): Prisma__AiVoicePromptClient<$Result.GetResult<Prisma.$AiVoicePromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiVoicePrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptCountArgs} args - Arguments to filter AiVoicePrompts to count.
     * @example
     * // Count the number of AiVoicePrompts
     * const count = await prisma.aiVoicePrompt.count({
     *   where: {
     *     // ... the filter for the AiVoicePrompts we want to count
     *   }
     * })
    **/
    count<T extends AiVoicePromptCountArgs>(
      args?: Subset<T, AiVoicePromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiVoicePromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiVoicePrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiVoicePromptAggregateArgs>(args: Subset<T, AiVoicePromptAggregateArgs>): Prisma.PrismaPromise<GetAiVoicePromptAggregateType<T>>

    /**
     * Group by AiVoicePrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiVoicePromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiVoicePromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiVoicePromptGroupByArgs['orderBy'] }
        : { orderBy?: AiVoicePromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiVoicePromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiVoicePromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiVoicePrompt model
   */
  readonly fields: AiVoicePromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiVoicePrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiVoicePromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiVoicePrompt model
   */
  interface AiVoicePromptFieldRefs {
    readonly prompt_id: FieldRef<"AiVoicePrompt", 'Int'>
    readonly interview_id: FieldRef<"AiVoicePrompt", 'Int'>
    readonly prompt_text: FieldRef<"AiVoicePrompt", 'String'>
    readonly prompt_audio_path: FieldRef<"AiVoicePrompt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AiVoicePrompt findUnique
   */
  export type AiVoicePromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter, which AiVoicePrompt to fetch.
     */
    where: AiVoicePromptWhereUniqueInput
  }

  /**
   * AiVoicePrompt findUniqueOrThrow
   */
  export type AiVoicePromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter, which AiVoicePrompt to fetch.
     */
    where: AiVoicePromptWhereUniqueInput
  }

  /**
   * AiVoicePrompt findFirst
   */
  export type AiVoicePromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter, which AiVoicePrompt to fetch.
     */
    where?: AiVoicePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiVoicePrompts to fetch.
     */
    orderBy?: AiVoicePromptOrderByWithRelationInput | AiVoicePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiVoicePrompts.
     */
    cursor?: AiVoicePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiVoicePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiVoicePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiVoicePrompts.
     */
    distinct?: AiVoicePromptScalarFieldEnum | AiVoicePromptScalarFieldEnum[]
  }

  /**
   * AiVoicePrompt findFirstOrThrow
   */
  export type AiVoicePromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter, which AiVoicePrompt to fetch.
     */
    where?: AiVoicePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiVoicePrompts to fetch.
     */
    orderBy?: AiVoicePromptOrderByWithRelationInput | AiVoicePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiVoicePrompts.
     */
    cursor?: AiVoicePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiVoicePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiVoicePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiVoicePrompts.
     */
    distinct?: AiVoicePromptScalarFieldEnum | AiVoicePromptScalarFieldEnum[]
  }

  /**
   * AiVoicePrompt findMany
   */
  export type AiVoicePromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter, which AiVoicePrompts to fetch.
     */
    where?: AiVoicePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiVoicePrompts to fetch.
     */
    orderBy?: AiVoicePromptOrderByWithRelationInput | AiVoicePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiVoicePrompts.
     */
    cursor?: AiVoicePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiVoicePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiVoicePrompts.
     */
    skip?: number
    distinct?: AiVoicePromptScalarFieldEnum | AiVoicePromptScalarFieldEnum[]
  }

  /**
   * AiVoicePrompt create
   */
  export type AiVoicePromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * The data needed to create a AiVoicePrompt.
     */
    data: XOR<AiVoicePromptCreateInput, AiVoicePromptUncheckedCreateInput>
  }

  /**
   * AiVoicePrompt createMany
   */
  export type AiVoicePromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiVoicePrompts.
     */
    data: AiVoicePromptCreateManyInput | AiVoicePromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiVoicePrompt createManyAndReturn
   */
  export type AiVoicePromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * The data used to create many AiVoicePrompts.
     */
    data: AiVoicePromptCreateManyInput | AiVoicePromptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiVoicePrompt update
   */
  export type AiVoicePromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * The data needed to update a AiVoicePrompt.
     */
    data: XOR<AiVoicePromptUpdateInput, AiVoicePromptUncheckedUpdateInput>
    /**
     * Choose, which AiVoicePrompt to update.
     */
    where: AiVoicePromptWhereUniqueInput
  }

  /**
   * AiVoicePrompt updateMany
   */
  export type AiVoicePromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiVoicePrompts.
     */
    data: XOR<AiVoicePromptUpdateManyMutationInput, AiVoicePromptUncheckedUpdateManyInput>
    /**
     * Filter which AiVoicePrompts to update
     */
    where?: AiVoicePromptWhereInput
    /**
     * Limit how many AiVoicePrompts to update.
     */
    limit?: number
  }

  /**
   * AiVoicePrompt updateManyAndReturn
   */
  export type AiVoicePromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * The data used to update AiVoicePrompts.
     */
    data: XOR<AiVoicePromptUpdateManyMutationInput, AiVoicePromptUncheckedUpdateManyInput>
    /**
     * Filter which AiVoicePrompts to update
     */
    where?: AiVoicePromptWhereInput
    /**
     * Limit how many AiVoicePrompts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiVoicePrompt upsert
   */
  export type AiVoicePromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * The filter to search for the AiVoicePrompt to update in case it exists.
     */
    where: AiVoicePromptWhereUniqueInput
    /**
     * In case the AiVoicePrompt found by the `where` argument doesn't exist, create a new AiVoicePrompt with this data.
     */
    create: XOR<AiVoicePromptCreateInput, AiVoicePromptUncheckedCreateInput>
    /**
     * In case the AiVoicePrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiVoicePromptUpdateInput, AiVoicePromptUncheckedUpdateInput>
  }

  /**
   * AiVoicePrompt delete
   */
  export type AiVoicePromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
    /**
     * Filter which AiVoicePrompt to delete.
     */
    where: AiVoicePromptWhereUniqueInput
  }

  /**
   * AiVoicePrompt deleteMany
   */
  export type AiVoicePromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiVoicePrompts to delete
     */
    where?: AiVoicePromptWhereInput
    /**
     * Limit how many AiVoicePrompts to delete.
     */
    limit?: number
  }

  /**
   * AiVoicePrompt without action
   */
  export type AiVoicePromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiVoicePrompt
     */
    select?: AiVoicePromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiVoicePrompt
     */
    omit?: AiVoicePromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiVoicePromptInclude<ExtArgs> | null
  }


  /**
   * Model AiInterviewAnalysis
   */

  export type AggregateAiInterviewAnalysis = {
    _count: AiInterviewAnalysisCountAggregateOutputType | null
    _avg: AiInterviewAnalysisAvgAggregateOutputType | null
    _sum: AiInterviewAnalysisSumAggregateOutputType | null
    _min: AiInterviewAnalysisMinAggregateOutputType | null
    _max: AiInterviewAnalysisMaxAggregateOutputType | null
  }

  export type AiInterviewAnalysisAvgAggregateOutputType = {
    analysis_id: number | null
    interview_id: number | null
    technical_score: number | null
    communication_score: number | null
    confidence_score: number | null
    overall_score: number | null
  }

  export type AiInterviewAnalysisSumAggregateOutputType = {
    analysis_id: number | null
    interview_id: number | null
    technical_score: number | null
    communication_score: number | null
    confidence_score: number | null
    overall_score: number | null
  }

  export type AiInterviewAnalysisMinAggregateOutputType = {
    analysis_id: number | null
    interview_id: number | null
    technical_score: number | null
    communication_score: number | null
    confidence_score: number | null
    overall_score: number | null
    strengths: string | null
    weaknesses: string | null
    improvement_suggestions: string | null
  }

  export type AiInterviewAnalysisMaxAggregateOutputType = {
    analysis_id: number | null
    interview_id: number | null
    technical_score: number | null
    communication_score: number | null
    confidence_score: number | null
    overall_score: number | null
    strengths: string | null
    weaknesses: string | null
    improvement_suggestions: string | null
  }

  export type AiInterviewAnalysisCountAggregateOutputType = {
    analysis_id: number
    interview_id: number
    technical_score: number
    communication_score: number
    confidence_score: number
    overall_score: number
    strengths: number
    weaknesses: number
    improvement_suggestions: number
    analysis_json: number
    _all: number
  }


  export type AiInterviewAnalysisAvgAggregateInputType = {
    analysis_id?: true
    interview_id?: true
    technical_score?: true
    communication_score?: true
    confidence_score?: true
    overall_score?: true
  }

  export type AiInterviewAnalysisSumAggregateInputType = {
    analysis_id?: true
    interview_id?: true
    technical_score?: true
    communication_score?: true
    confidence_score?: true
    overall_score?: true
  }

  export type AiInterviewAnalysisMinAggregateInputType = {
    analysis_id?: true
    interview_id?: true
    technical_score?: true
    communication_score?: true
    confidence_score?: true
    overall_score?: true
    strengths?: true
    weaknesses?: true
    improvement_suggestions?: true
  }

  export type AiInterviewAnalysisMaxAggregateInputType = {
    analysis_id?: true
    interview_id?: true
    technical_score?: true
    communication_score?: true
    confidence_score?: true
    overall_score?: true
    strengths?: true
    weaknesses?: true
    improvement_suggestions?: true
  }

  export type AiInterviewAnalysisCountAggregateInputType = {
    analysis_id?: true
    interview_id?: true
    technical_score?: true
    communication_score?: true
    confidence_score?: true
    overall_score?: true
    strengths?: true
    weaknesses?: true
    improvement_suggestions?: true
    analysis_json?: true
    _all?: true
  }

  export type AiInterviewAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewAnalysis to aggregate.
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewAnalyses to fetch.
     */
    orderBy?: AiInterviewAnalysisOrderByWithRelationInput | AiInterviewAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiInterviewAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiInterviewAnalyses
    **/
    _count?: true | AiInterviewAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiInterviewAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiInterviewAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiInterviewAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiInterviewAnalysisMaxAggregateInputType
  }

  export type GetAiInterviewAnalysisAggregateType<T extends AiInterviewAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateAiInterviewAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiInterviewAnalysis[P]>
      : GetScalarType<T[P], AggregateAiInterviewAnalysis[P]>
  }




  export type AiInterviewAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiInterviewAnalysisWhereInput
    orderBy?: AiInterviewAnalysisOrderByWithAggregationInput | AiInterviewAnalysisOrderByWithAggregationInput[]
    by: AiInterviewAnalysisScalarFieldEnum[] | AiInterviewAnalysisScalarFieldEnum
    having?: AiInterviewAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiInterviewAnalysisCountAggregateInputType | true
    _avg?: AiInterviewAnalysisAvgAggregateInputType
    _sum?: AiInterviewAnalysisSumAggregateInputType
    _min?: AiInterviewAnalysisMinAggregateInputType
    _max?: AiInterviewAnalysisMaxAggregateInputType
  }

  export type AiInterviewAnalysisGroupByOutputType = {
    analysis_id: number
    interview_id: number
    technical_score: number | null
    communication_score: number | null
    confidence_score: number | null
    overall_score: number | null
    strengths: string | null
    weaknesses: string | null
    improvement_suggestions: string | null
    analysis_json: JsonValue | null
    _count: AiInterviewAnalysisCountAggregateOutputType | null
    _avg: AiInterviewAnalysisAvgAggregateOutputType | null
    _sum: AiInterviewAnalysisSumAggregateOutputType | null
    _min: AiInterviewAnalysisMinAggregateOutputType | null
    _max: AiInterviewAnalysisMaxAggregateOutputType | null
  }

  type GetAiInterviewAnalysisGroupByPayload<T extends AiInterviewAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiInterviewAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiInterviewAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiInterviewAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], AiInterviewAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type AiInterviewAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    analysis_id?: boolean
    interview_id?: boolean
    technical_score?: boolean
    communication_score?: boolean
    confidence_score?: boolean
    overall_score?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvement_suggestions?: boolean
    analysis_json?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewAnalysis"]>

  export type AiInterviewAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    analysis_id?: boolean
    interview_id?: boolean
    technical_score?: boolean
    communication_score?: boolean
    confidence_score?: boolean
    overall_score?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvement_suggestions?: boolean
    analysis_json?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewAnalysis"]>

  export type AiInterviewAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    analysis_id?: boolean
    interview_id?: boolean
    technical_score?: boolean
    communication_score?: boolean
    confidence_score?: boolean
    overall_score?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvement_suggestions?: boolean
    analysis_json?: boolean
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiInterviewAnalysis"]>

  export type AiInterviewAnalysisSelectScalar = {
    analysis_id?: boolean
    interview_id?: boolean
    technical_score?: boolean
    communication_score?: boolean
    confidence_score?: boolean
    overall_score?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvement_suggestions?: boolean
    analysis_json?: boolean
  }

  export type AiInterviewAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"analysis_id" | "interview_id" | "technical_score" | "communication_score" | "confidence_score" | "overall_score" | "strengths" | "weaknesses" | "improvement_suggestions" | "analysis_json", ExtArgs["result"]["aiInterviewAnalysis"]>
  export type AiInterviewAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }
  export type AiInterviewAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | AiInterviewDefaultArgs<ExtArgs>
  }

  export type $AiInterviewAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiInterviewAnalysis"
    objects: {
      interview: Prisma.$AiInterviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      analysis_id: number
      interview_id: number
      technical_score: number | null
      communication_score: number | null
      confidence_score: number | null
      overall_score: number | null
      strengths: string | null
      weaknesses: string | null
      improvement_suggestions: string | null
      analysis_json: Prisma.JsonValue | null
    }, ExtArgs["result"]["aiInterviewAnalysis"]>
    composites: {}
  }

  type AiInterviewAnalysisGetPayload<S extends boolean | null | undefined | AiInterviewAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AiInterviewAnalysisPayload, S>

  type AiInterviewAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiInterviewAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiInterviewAnalysisCountAggregateInputType | true
    }

  export interface AiInterviewAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiInterviewAnalysis'], meta: { name: 'AiInterviewAnalysis' } }
    /**
     * Find zero or one AiInterviewAnalysis that matches the filter.
     * @param {AiInterviewAnalysisFindUniqueArgs} args - Arguments to find a AiInterviewAnalysis
     * @example
     * // Get one AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiInterviewAnalysisFindUniqueArgs>(args: SelectSubset<T, AiInterviewAnalysisFindUniqueArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiInterviewAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiInterviewAnalysisFindUniqueOrThrowArgs} args - Arguments to find a AiInterviewAnalysis
     * @example
     * // Get one AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiInterviewAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, AiInterviewAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisFindFirstArgs} args - Arguments to find a AiInterviewAnalysis
     * @example
     * // Get one AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiInterviewAnalysisFindFirstArgs>(args?: SelectSubset<T, AiInterviewAnalysisFindFirstArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiInterviewAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisFindFirstOrThrowArgs} args - Arguments to find a AiInterviewAnalysis
     * @example
     * // Get one AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiInterviewAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, AiInterviewAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiInterviewAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiInterviewAnalyses
     * const aiInterviewAnalyses = await prisma.aiInterviewAnalysis.findMany()
     * 
     * // Get first 10 AiInterviewAnalyses
     * const aiInterviewAnalyses = await prisma.aiInterviewAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `analysis_id`
     * const aiInterviewAnalysisWithAnalysis_idOnly = await prisma.aiInterviewAnalysis.findMany({ select: { analysis_id: true } })
     * 
     */
    findMany<T extends AiInterviewAnalysisFindManyArgs>(args?: SelectSubset<T, AiInterviewAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiInterviewAnalysis.
     * @param {AiInterviewAnalysisCreateArgs} args - Arguments to create a AiInterviewAnalysis.
     * @example
     * // Create one AiInterviewAnalysis
     * const AiInterviewAnalysis = await prisma.aiInterviewAnalysis.create({
     *   data: {
     *     // ... data to create a AiInterviewAnalysis
     *   }
     * })
     * 
     */
    create<T extends AiInterviewAnalysisCreateArgs>(args: SelectSubset<T, AiInterviewAnalysisCreateArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiInterviewAnalyses.
     * @param {AiInterviewAnalysisCreateManyArgs} args - Arguments to create many AiInterviewAnalyses.
     * @example
     * // Create many AiInterviewAnalyses
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiInterviewAnalysisCreateManyArgs>(args?: SelectSubset<T, AiInterviewAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiInterviewAnalyses and returns the data saved in the database.
     * @param {AiInterviewAnalysisCreateManyAndReturnArgs} args - Arguments to create many AiInterviewAnalyses.
     * @example
     * // Create many AiInterviewAnalyses
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiInterviewAnalyses and only return the `analysis_id`
     * const aiInterviewAnalysisWithAnalysis_idOnly = await prisma.aiInterviewAnalysis.createManyAndReturn({
     *   select: { analysis_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiInterviewAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, AiInterviewAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiInterviewAnalysis.
     * @param {AiInterviewAnalysisDeleteArgs} args - Arguments to delete one AiInterviewAnalysis.
     * @example
     * // Delete one AiInterviewAnalysis
     * const AiInterviewAnalysis = await prisma.aiInterviewAnalysis.delete({
     *   where: {
     *     // ... filter to delete one AiInterviewAnalysis
     *   }
     * })
     * 
     */
    delete<T extends AiInterviewAnalysisDeleteArgs>(args: SelectSubset<T, AiInterviewAnalysisDeleteArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiInterviewAnalysis.
     * @param {AiInterviewAnalysisUpdateArgs} args - Arguments to update one AiInterviewAnalysis.
     * @example
     * // Update one AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiInterviewAnalysisUpdateArgs>(args: SelectSubset<T, AiInterviewAnalysisUpdateArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiInterviewAnalyses.
     * @param {AiInterviewAnalysisDeleteManyArgs} args - Arguments to filter AiInterviewAnalyses to delete.
     * @example
     * // Delete a few AiInterviewAnalyses
     * const { count } = await prisma.aiInterviewAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiInterviewAnalysisDeleteManyArgs>(args?: SelectSubset<T, AiInterviewAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiInterviewAnalyses
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiInterviewAnalysisUpdateManyArgs>(args: SelectSubset<T, AiInterviewAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiInterviewAnalyses and returns the data updated in the database.
     * @param {AiInterviewAnalysisUpdateManyAndReturnArgs} args - Arguments to update many AiInterviewAnalyses.
     * @example
     * // Update many AiInterviewAnalyses
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiInterviewAnalyses and only return the `analysis_id`
     * const aiInterviewAnalysisWithAnalysis_idOnly = await prisma.aiInterviewAnalysis.updateManyAndReturn({
     *   select: { analysis_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiInterviewAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, AiInterviewAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiInterviewAnalysis.
     * @param {AiInterviewAnalysisUpsertArgs} args - Arguments to update or create a AiInterviewAnalysis.
     * @example
     * // Update or create a AiInterviewAnalysis
     * const aiInterviewAnalysis = await prisma.aiInterviewAnalysis.upsert({
     *   create: {
     *     // ... data to create a AiInterviewAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiInterviewAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends AiInterviewAnalysisUpsertArgs>(args: SelectSubset<T, AiInterviewAnalysisUpsertArgs<ExtArgs>>): Prisma__AiInterviewAnalysisClient<$Result.GetResult<Prisma.$AiInterviewAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiInterviewAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisCountArgs} args - Arguments to filter AiInterviewAnalyses to count.
     * @example
     * // Count the number of AiInterviewAnalyses
     * const count = await prisma.aiInterviewAnalysis.count({
     *   where: {
     *     // ... the filter for the AiInterviewAnalyses we want to count
     *   }
     * })
    **/
    count<T extends AiInterviewAnalysisCountArgs>(
      args?: Subset<T, AiInterviewAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiInterviewAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiInterviewAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiInterviewAnalysisAggregateArgs>(args: Subset<T, AiInterviewAnalysisAggregateArgs>): Prisma.PrismaPromise<GetAiInterviewAnalysisAggregateType<T>>

    /**
     * Group by AiInterviewAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiInterviewAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiInterviewAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiInterviewAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: AiInterviewAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiInterviewAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiInterviewAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiInterviewAnalysis model
   */
  readonly fields: AiInterviewAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiInterviewAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiInterviewAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends AiInterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiInterviewDefaultArgs<ExtArgs>>): Prisma__AiInterviewClient<$Result.GetResult<Prisma.$AiInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiInterviewAnalysis model
   */
  interface AiInterviewAnalysisFieldRefs {
    readonly analysis_id: FieldRef<"AiInterviewAnalysis", 'Int'>
    readonly interview_id: FieldRef<"AiInterviewAnalysis", 'Int'>
    readonly technical_score: FieldRef<"AiInterviewAnalysis", 'Float'>
    readonly communication_score: FieldRef<"AiInterviewAnalysis", 'Float'>
    readonly confidence_score: FieldRef<"AiInterviewAnalysis", 'Float'>
    readonly overall_score: FieldRef<"AiInterviewAnalysis", 'Float'>
    readonly strengths: FieldRef<"AiInterviewAnalysis", 'String'>
    readonly weaknesses: FieldRef<"AiInterviewAnalysis", 'String'>
    readonly improvement_suggestions: FieldRef<"AiInterviewAnalysis", 'String'>
    readonly analysis_json: FieldRef<"AiInterviewAnalysis", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AiInterviewAnalysis findUnique
   */
  export type AiInterviewAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewAnalysis to fetch.
     */
    where: AiInterviewAnalysisWhereUniqueInput
  }

  /**
   * AiInterviewAnalysis findUniqueOrThrow
   */
  export type AiInterviewAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewAnalysis to fetch.
     */
    where: AiInterviewAnalysisWhereUniqueInput
  }

  /**
   * AiInterviewAnalysis findFirst
   */
  export type AiInterviewAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewAnalysis to fetch.
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewAnalyses to fetch.
     */
    orderBy?: AiInterviewAnalysisOrderByWithRelationInput | AiInterviewAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewAnalyses.
     */
    cursor?: AiInterviewAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewAnalyses.
     */
    distinct?: AiInterviewAnalysisScalarFieldEnum | AiInterviewAnalysisScalarFieldEnum[]
  }

  /**
   * AiInterviewAnalysis findFirstOrThrow
   */
  export type AiInterviewAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewAnalysis to fetch.
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewAnalyses to fetch.
     */
    orderBy?: AiInterviewAnalysisOrderByWithRelationInput | AiInterviewAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiInterviewAnalyses.
     */
    cursor?: AiInterviewAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiInterviewAnalyses.
     */
    distinct?: AiInterviewAnalysisScalarFieldEnum | AiInterviewAnalysisScalarFieldEnum[]
  }

  /**
   * AiInterviewAnalysis findMany
   */
  export type AiInterviewAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiInterviewAnalyses to fetch.
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiInterviewAnalyses to fetch.
     */
    orderBy?: AiInterviewAnalysisOrderByWithRelationInput | AiInterviewAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiInterviewAnalyses.
     */
    cursor?: AiInterviewAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiInterviewAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiInterviewAnalyses.
     */
    skip?: number
    distinct?: AiInterviewAnalysisScalarFieldEnum | AiInterviewAnalysisScalarFieldEnum[]
  }

  /**
   * AiInterviewAnalysis create
   */
  export type AiInterviewAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a AiInterviewAnalysis.
     */
    data: XOR<AiInterviewAnalysisCreateInput, AiInterviewAnalysisUncheckedCreateInput>
  }

  /**
   * AiInterviewAnalysis createMany
   */
  export type AiInterviewAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiInterviewAnalyses.
     */
    data: AiInterviewAnalysisCreateManyInput | AiInterviewAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiInterviewAnalysis createManyAndReturn
   */
  export type AiInterviewAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many AiInterviewAnalyses.
     */
    data: AiInterviewAnalysisCreateManyInput | AiInterviewAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewAnalysis update
   */
  export type AiInterviewAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a AiInterviewAnalysis.
     */
    data: XOR<AiInterviewAnalysisUpdateInput, AiInterviewAnalysisUncheckedUpdateInput>
    /**
     * Choose, which AiInterviewAnalysis to update.
     */
    where: AiInterviewAnalysisWhereUniqueInput
  }

  /**
   * AiInterviewAnalysis updateMany
   */
  export type AiInterviewAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiInterviewAnalyses.
     */
    data: XOR<AiInterviewAnalysisUpdateManyMutationInput, AiInterviewAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewAnalyses to update
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * Limit how many AiInterviewAnalyses to update.
     */
    limit?: number
  }

  /**
   * AiInterviewAnalysis updateManyAndReturn
   */
  export type AiInterviewAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update AiInterviewAnalyses.
     */
    data: XOR<AiInterviewAnalysisUpdateManyMutationInput, AiInterviewAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiInterviewAnalyses to update
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * Limit how many AiInterviewAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiInterviewAnalysis upsert
   */
  export type AiInterviewAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the AiInterviewAnalysis to update in case it exists.
     */
    where: AiInterviewAnalysisWhereUniqueInput
    /**
     * In case the AiInterviewAnalysis found by the `where` argument doesn't exist, create a new AiInterviewAnalysis with this data.
     */
    create: XOR<AiInterviewAnalysisCreateInput, AiInterviewAnalysisUncheckedCreateInput>
    /**
     * In case the AiInterviewAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiInterviewAnalysisUpdateInput, AiInterviewAnalysisUncheckedUpdateInput>
  }

  /**
   * AiInterviewAnalysis delete
   */
  export type AiInterviewAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
    /**
     * Filter which AiInterviewAnalysis to delete.
     */
    where: AiInterviewAnalysisWhereUniqueInput
  }

  /**
   * AiInterviewAnalysis deleteMany
   */
  export type AiInterviewAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiInterviewAnalyses to delete
     */
    where?: AiInterviewAnalysisWhereInput
    /**
     * Limit how many AiInterviewAnalyses to delete.
     */
    limit?: number
  }

  /**
   * AiInterviewAnalysis without action
   */
  export type AiInterviewAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiInterviewAnalysis
     */
    select?: AiInterviewAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiInterviewAnalysis
     */
    omit?: AiInterviewAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiInterviewAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model AiGenerationLog
   */

  export type AggregateAiGenerationLog = {
    _count: AiGenerationLogCountAggregateOutputType | null
    _avg: AiGenerationLogAvgAggregateOutputType | null
    _sum: AiGenerationLogSumAggregateOutputType | null
    _min: AiGenerationLogMinAggregateOutputType | null
    _max: AiGenerationLogMaxAggregateOutputType | null
  }

  export type AiGenerationLogAvgAggregateOutputType = {
    log_id: number | null
    user_id: number | null
  }

  export type AiGenerationLogSumAggregateOutputType = {
    log_id: number | null
    user_id: number | null
  }

  export type AiGenerationLogMinAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    service_used: string | null
    created_at: Date | null
  }

  export type AiGenerationLogMaxAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    service_used: string | null
    created_at: Date | null
  }

  export type AiGenerationLogCountAggregateOutputType = {
    log_id: number
    user_id: number
    service_used: number
    request_payload: number
    response_payload: number
    created_at: number
    _all: number
  }


  export type AiGenerationLogAvgAggregateInputType = {
    log_id?: true
    user_id?: true
  }

  export type AiGenerationLogSumAggregateInputType = {
    log_id?: true
    user_id?: true
  }

  export type AiGenerationLogMinAggregateInputType = {
    log_id?: true
    user_id?: true
    service_used?: true
    created_at?: true
  }

  export type AiGenerationLogMaxAggregateInputType = {
    log_id?: true
    user_id?: true
    service_used?: true
    created_at?: true
  }

  export type AiGenerationLogCountAggregateInputType = {
    log_id?: true
    user_id?: true
    service_used?: true
    request_payload?: true
    response_payload?: true
    created_at?: true
    _all?: true
  }

  export type AiGenerationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGenerationLog to aggregate.
     */
    where?: AiGenerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGenerationLogs to fetch.
     */
    orderBy?: AiGenerationLogOrderByWithRelationInput | AiGenerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiGenerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGenerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGenerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiGenerationLogs
    **/
    _count?: true | AiGenerationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiGenerationLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiGenerationLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiGenerationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiGenerationLogMaxAggregateInputType
  }

  export type GetAiGenerationLogAggregateType<T extends AiGenerationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAiGenerationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiGenerationLog[P]>
      : GetScalarType<T[P], AggregateAiGenerationLog[P]>
  }




  export type AiGenerationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGenerationLogWhereInput
    orderBy?: AiGenerationLogOrderByWithAggregationInput | AiGenerationLogOrderByWithAggregationInput[]
    by: AiGenerationLogScalarFieldEnum[] | AiGenerationLogScalarFieldEnum
    having?: AiGenerationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiGenerationLogCountAggregateInputType | true
    _avg?: AiGenerationLogAvgAggregateInputType
    _sum?: AiGenerationLogSumAggregateInputType
    _min?: AiGenerationLogMinAggregateInputType
    _max?: AiGenerationLogMaxAggregateInputType
  }

  export type AiGenerationLogGroupByOutputType = {
    log_id: number
    user_id: number
    service_used: string | null
    request_payload: JsonValue | null
    response_payload: JsonValue | null
    created_at: Date | null
    _count: AiGenerationLogCountAggregateOutputType | null
    _avg: AiGenerationLogAvgAggregateOutputType | null
    _sum: AiGenerationLogSumAggregateOutputType | null
    _min: AiGenerationLogMinAggregateOutputType | null
    _max: AiGenerationLogMaxAggregateOutputType | null
  }

  type GetAiGenerationLogGroupByPayload<T extends AiGenerationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiGenerationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiGenerationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiGenerationLogGroupByOutputType[P]>
            : GetScalarType<T[P], AiGenerationLogGroupByOutputType[P]>
        }
      >
    >


  export type AiGenerationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    service_used?: boolean
    request_payload?: boolean
    response_payload?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiGenerationLog"]>

  export type AiGenerationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    service_used?: boolean
    request_payload?: boolean
    response_payload?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiGenerationLog"]>

  export type AiGenerationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    service_used?: boolean
    request_payload?: boolean
    response_payload?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiGenerationLog"]>

  export type AiGenerationLogSelectScalar = {
    log_id?: boolean
    user_id?: boolean
    service_used?: boolean
    request_payload?: boolean
    response_payload?: boolean
    created_at?: boolean
  }

  export type AiGenerationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"log_id" | "user_id" | "service_used" | "request_payload" | "response_payload" | "created_at", ExtArgs["result"]["aiGenerationLog"]>
  export type AiGenerationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AiGenerationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AiGenerationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AiGenerationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiGenerationLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      log_id: number
      user_id: number
      service_used: string | null
      request_payload: Prisma.JsonValue | null
      response_payload: Prisma.JsonValue | null
      created_at: Date | null
    }, ExtArgs["result"]["aiGenerationLog"]>
    composites: {}
  }

  type AiGenerationLogGetPayload<S extends boolean | null | undefined | AiGenerationLogDefaultArgs> = $Result.GetResult<Prisma.$AiGenerationLogPayload, S>

  type AiGenerationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiGenerationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiGenerationLogCountAggregateInputType | true
    }

  export interface AiGenerationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiGenerationLog'], meta: { name: 'AiGenerationLog' } }
    /**
     * Find zero or one AiGenerationLog that matches the filter.
     * @param {AiGenerationLogFindUniqueArgs} args - Arguments to find a AiGenerationLog
     * @example
     * // Get one AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiGenerationLogFindUniqueArgs>(args: SelectSubset<T, AiGenerationLogFindUniqueArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiGenerationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiGenerationLogFindUniqueOrThrowArgs} args - Arguments to find a AiGenerationLog
     * @example
     * // Get one AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiGenerationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AiGenerationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiGenerationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogFindFirstArgs} args - Arguments to find a AiGenerationLog
     * @example
     * // Get one AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiGenerationLogFindFirstArgs>(args?: SelectSubset<T, AiGenerationLogFindFirstArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiGenerationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogFindFirstOrThrowArgs} args - Arguments to find a AiGenerationLog
     * @example
     * // Get one AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiGenerationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AiGenerationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiGenerationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiGenerationLogs
     * const aiGenerationLogs = await prisma.aiGenerationLog.findMany()
     * 
     * // Get first 10 AiGenerationLogs
     * const aiGenerationLogs = await prisma.aiGenerationLog.findMany({ take: 10 })
     * 
     * // Only select the `log_id`
     * const aiGenerationLogWithLog_idOnly = await prisma.aiGenerationLog.findMany({ select: { log_id: true } })
     * 
     */
    findMany<T extends AiGenerationLogFindManyArgs>(args?: SelectSubset<T, AiGenerationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiGenerationLog.
     * @param {AiGenerationLogCreateArgs} args - Arguments to create a AiGenerationLog.
     * @example
     * // Create one AiGenerationLog
     * const AiGenerationLog = await prisma.aiGenerationLog.create({
     *   data: {
     *     // ... data to create a AiGenerationLog
     *   }
     * })
     * 
     */
    create<T extends AiGenerationLogCreateArgs>(args: SelectSubset<T, AiGenerationLogCreateArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiGenerationLogs.
     * @param {AiGenerationLogCreateManyArgs} args - Arguments to create many AiGenerationLogs.
     * @example
     * // Create many AiGenerationLogs
     * const aiGenerationLog = await prisma.aiGenerationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiGenerationLogCreateManyArgs>(args?: SelectSubset<T, AiGenerationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiGenerationLogs and returns the data saved in the database.
     * @param {AiGenerationLogCreateManyAndReturnArgs} args - Arguments to create many AiGenerationLogs.
     * @example
     * // Create many AiGenerationLogs
     * const aiGenerationLog = await prisma.aiGenerationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiGenerationLogs and only return the `log_id`
     * const aiGenerationLogWithLog_idOnly = await prisma.aiGenerationLog.createManyAndReturn({
     *   select: { log_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiGenerationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AiGenerationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiGenerationLog.
     * @param {AiGenerationLogDeleteArgs} args - Arguments to delete one AiGenerationLog.
     * @example
     * // Delete one AiGenerationLog
     * const AiGenerationLog = await prisma.aiGenerationLog.delete({
     *   where: {
     *     // ... filter to delete one AiGenerationLog
     *   }
     * })
     * 
     */
    delete<T extends AiGenerationLogDeleteArgs>(args: SelectSubset<T, AiGenerationLogDeleteArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiGenerationLog.
     * @param {AiGenerationLogUpdateArgs} args - Arguments to update one AiGenerationLog.
     * @example
     * // Update one AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiGenerationLogUpdateArgs>(args: SelectSubset<T, AiGenerationLogUpdateArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiGenerationLogs.
     * @param {AiGenerationLogDeleteManyArgs} args - Arguments to filter AiGenerationLogs to delete.
     * @example
     * // Delete a few AiGenerationLogs
     * const { count } = await prisma.aiGenerationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiGenerationLogDeleteManyArgs>(args?: SelectSubset<T, AiGenerationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiGenerationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiGenerationLogs
     * const aiGenerationLog = await prisma.aiGenerationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiGenerationLogUpdateManyArgs>(args: SelectSubset<T, AiGenerationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiGenerationLogs and returns the data updated in the database.
     * @param {AiGenerationLogUpdateManyAndReturnArgs} args - Arguments to update many AiGenerationLogs.
     * @example
     * // Update many AiGenerationLogs
     * const aiGenerationLog = await prisma.aiGenerationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiGenerationLogs and only return the `log_id`
     * const aiGenerationLogWithLog_idOnly = await prisma.aiGenerationLog.updateManyAndReturn({
     *   select: { log_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiGenerationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AiGenerationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiGenerationLog.
     * @param {AiGenerationLogUpsertArgs} args - Arguments to update or create a AiGenerationLog.
     * @example
     * // Update or create a AiGenerationLog
     * const aiGenerationLog = await prisma.aiGenerationLog.upsert({
     *   create: {
     *     // ... data to create a AiGenerationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiGenerationLog we want to update
     *   }
     * })
     */
    upsert<T extends AiGenerationLogUpsertArgs>(args: SelectSubset<T, AiGenerationLogUpsertArgs<ExtArgs>>): Prisma__AiGenerationLogClient<$Result.GetResult<Prisma.$AiGenerationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiGenerationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogCountArgs} args - Arguments to filter AiGenerationLogs to count.
     * @example
     * // Count the number of AiGenerationLogs
     * const count = await prisma.aiGenerationLog.count({
     *   where: {
     *     // ... the filter for the AiGenerationLogs we want to count
     *   }
     * })
    **/
    count<T extends AiGenerationLogCountArgs>(
      args?: Subset<T, AiGenerationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiGenerationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiGenerationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiGenerationLogAggregateArgs>(args: Subset<T, AiGenerationLogAggregateArgs>): Prisma.PrismaPromise<GetAiGenerationLogAggregateType<T>>

    /**
     * Group by AiGenerationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGenerationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiGenerationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiGenerationLogGroupByArgs['orderBy'] }
        : { orderBy?: AiGenerationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiGenerationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiGenerationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiGenerationLog model
   */
  readonly fields: AiGenerationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiGenerationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiGenerationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiGenerationLog model
   */
  interface AiGenerationLogFieldRefs {
    readonly log_id: FieldRef<"AiGenerationLog", 'Int'>
    readonly user_id: FieldRef<"AiGenerationLog", 'Int'>
    readonly service_used: FieldRef<"AiGenerationLog", 'String'>
    readonly request_payload: FieldRef<"AiGenerationLog", 'Json'>
    readonly response_payload: FieldRef<"AiGenerationLog", 'Json'>
    readonly created_at: FieldRef<"AiGenerationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiGenerationLog findUnique
   */
  export type AiGenerationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter, which AiGenerationLog to fetch.
     */
    where: AiGenerationLogWhereUniqueInput
  }

  /**
   * AiGenerationLog findUniqueOrThrow
   */
  export type AiGenerationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter, which AiGenerationLog to fetch.
     */
    where: AiGenerationLogWhereUniqueInput
  }

  /**
   * AiGenerationLog findFirst
   */
  export type AiGenerationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter, which AiGenerationLog to fetch.
     */
    where?: AiGenerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGenerationLogs to fetch.
     */
    orderBy?: AiGenerationLogOrderByWithRelationInput | AiGenerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGenerationLogs.
     */
    cursor?: AiGenerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGenerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGenerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGenerationLogs.
     */
    distinct?: AiGenerationLogScalarFieldEnum | AiGenerationLogScalarFieldEnum[]
  }

  /**
   * AiGenerationLog findFirstOrThrow
   */
  export type AiGenerationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter, which AiGenerationLog to fetch.
     */
    where?: AiGenerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGenerationLogs to fetch.
     */
    orderBy?: AiGenerationLogOrderByWithRelationInput | AiGenerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGenerationLogs.
     */
    cursor?: AiGenerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGenerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGenerationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGenerationLogs.
     */
    distinct?: AiGenerationLogScalarFieldEnum | AiGenerationLogScalarFieldEnum[]
  }

  /**
   * AiGenerationLog findMany
   */
  export type AiGenerationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter, which AiGenerationLogs to fetch.
     */
    where?: AiGenerationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGenerationLogs to fetch.
     */
    orderBy?: AiGenerationLogOrderByWithRelationInput | AiGenerationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiGenerationLogs.
     */
    cursor?: AiGenerationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGenerationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGenerationLogs.
     */
    skip?: number
    distinct?: AiGenerationLogScalarFieldEnum | AiGenerationLogScalarFieldEnum[]
  }

  /**
   * AiGenerationLog create
   */
  export type AiGenerationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AiGenerationLog.
     */
    data: XOR<AiGenerationLogCreateInput, AiGenerationLogUncheckedCreateInput>
  }

  /**
   * AiGenerationLog createMany
   */
  export type AiGenerationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiGenerationLogs.
     */
    data: AiGenerationLogCreateManyInput | AiGenerationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiGenerationLog createManyAndReturn
   */
  export type AiGenerationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * The data used to create many AiGenerationLogs.
     */
    data: AiGenerationLogCreateManyInput | AiGenerationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiGenerationLog update
   */
  export type AiGenerationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AiGenerationLog.
     */
    data: XOR<AiGenerationLogUpdateInput, AiGenerationLogUncheckedUpdateInput>
    /**
     * Choose, which AiGenerationLog to update.
     */
    where: AiGenerationLogWhereUniqueInput
  }

  /**
   * AiGenerationLog updateMany
   */
  export type AiGenerationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiGenerationLogs.
     */
    data: XOR<AiGenerationLogUpdateManyMutationInput, AiGenerationLogUncheckedUpdateManyInput>
    /**
     * Filter which AiGenerationLogs to update
     */
    where?: AiGenerationLogWhereInput
    /**
     * Limit how many AiGenerationLogs to update.
     */
    limit?: number
  }

  /**
   * AiGenerationLog updateManyAndReturn
   */
  export type AiGenerationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * The data used to update AiGenerationLogs.
     */
    data: XOR<AiGenerationLogUpdateManyMutationInput, AiGenerationLogUncheckedUpdateManyInput>
    /**
     * Filter which AiGenerationLogs to update
     */
    where?: AiGenerationLogWhereInput
    /**
     * Limit how many AiGenerationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiGenerationLog upsert
   */
  export type AiGenerationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AiGenerationLog to update in case it exists.
     */
    where: AiGenerationLogWhereUniqueInput
    /**
     * In case the AiGenerationLog found by the `where` argument doesn't exist, create a new AiGenerationLog with this data.
     */
    create: XOR<AiGenerationLogCreateInput, AiGenerationLogUncheckedCreateInput>
    /**
     * In case the AiGenerationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiGenerationLogUpdateInput, AiGenerationLogUncheckedUpdateInput>
  }

  /**
   * AiGenerationLog delete
   */
  export type AiGenerationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
    /**
     * Filter which AiGenerationLog to delete.
     */
    where: AiGenerationLogWhereUniqueInput
  }

  /**
   * AiGenerationLog deleteMany
   */
  export type AiGenerationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGenerationLogs to delete
     */
    where?: AiGenerationLogWhereInput
    /**
     * Limit how many AiGenerationLogs to delete.
     */
    limit?: number
  }

  /**
   * AiGenerationLog without action
   */
  export type AiGenerationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGenerationLog
     */
    select?: AiGenerationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGenerationLog
     */
    omit?: AiGenerationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGenerationLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    phone: 'phone',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    company_id: 'company_id',
    name: 'name',
    website: 'website',
    created_at: 'created_at'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const JobPostingScalarFieldEnum: {
    job_id: 'job_id',
    company_id: 'company_id',
    title: 'title',
    description: 'description',
    location: 'location',
    posted_at: 'posted_at'
  };

  export type JobPostingScalarFieldEnum = (typeof JobPostingScalarFieldEnum)[keyof typeof JobPostingScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    skill_id: 'skill_id',
    skill_name: 'skill_name'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const JobRequirementScalarFieldEnum: {
    req_id: 'req_id',
    job_id: 'job_id',
    skill_id: 'skill_id',
    required_level: 'required_level'
  };

  export type JobRequirementScalarFieldEnum = (typeof JobRequirementScalarFieldEnum)[keyof typeof JobRequirementScalarFieldEnum]


  export const CandidateProfileScalarFieldEnum: {
    candidate_id: 'candidate_id',
    education: 'education',
    experience: 'experience'
  };

  export type CandidateProfileScalarFieldEnum = (typeof CandidateProfileScalarFieldEnum)[keyof typeof CandidateProfileScalarFieldEnum]


  export const ResumeScalarFieldEnum: {
    resume_id: 'resume_id',
    candidate_id: 'candidate_id',
    file_path: 'file_path',
    parsed_text: 'parsed_text',
    parsed_json: 'parsed_json',
    uploaded_at: 'uploaded_at'
  };

  export type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]


  export const ParsedResumeSkillScalarFieldEnum: {
    resume_id: 'resume_id',
    skill_id: 'skill_id'
  };

  export type ParsedResumeSkillScalarFieldEnum = (typeof ParsedResumeSkillScalarFieldEnum)[keyof typeof ParsedResumeSkillScalarFieldEnum]


  export const ResumeVsJdMatchScalarFieldEnum: {
    match_id: 'match_id',
    resume_id: 'resume_id',
    job_id: 'job_id',
    match_score: 'match_score',
    matched_skills: 'matched_skills',
    missing_skills: 'missing_skills'
  };

  export type ResumeVsJdMatchScalarFieldEnum = (typeof ResumeVsJdMatchScalarFieldEnum)[keyof typeof ResumeVsJdMatchScalarFieldEnum]


  export const AiInterviewScalarFieldEnum: {
    interview_id: 'interview_id',
    job_id: 'job_id',
    candidate_id: 'candidate_id',
    scheduled_at: 'scheduled_at',
    status: 'status',
    created_at: 'created_at'
  };

  export type AiInterviewScalarFieldEnum = (typeof AiInterviewScalarFieldEnum)[keyof typeof AiInterviewScalarFieldEnum]


  export const AiInterviewQuestionScalarFieldEnum: {
    question_id: 'question_id',
    interview_id: 'interview_id',
    question_text: 'question_text',
    question_type: 'question_type',
    ai_generated: 'ai_generated',
    asked_at: 'asked_at'
  };

  export type AiInterviewQuestionScalarFieldEnum = (typeof AiInterviewQuestionScalarFieldEnum)[keyof typeof AiInterviewQuestionScalarFieldEnum]


  export const AiInterviewResponseScalarFieldEnum: {
    response_id: 'response_id',
    interview_id: 'interview_id',
    question_id: 'question_id',
    response_text: 'response_text',
    response_audio_path: 'response_audio_path',
    response_video_path: 'response_video_path',
    transcript: 'transcript',
    captured_at: 'captured_at'
  };

  export type AiInterviewResponseScalarFieldEnum = (typeof AiInterviewResponseScalarFieldEnum)[keyof typeof AiInterviewResponseScalarFieldEnum]


  export const AiInterviewCheatingEventScalarFieldEnum: {
    event_id: 'event_id',
    interview_id: 'interview_id',
    event_type: 'event_type',
    confidence_score: 'confidence_score',
    detected_at: 'detected_at'
  };

  export type AiInterviewCheatingEventScalarFieldEnum = (typeof AiInterviewCheatingEventScalarFieldEnum)[keyof typeof AiInterviewCheatingEventScalarFieldEnum]


  export const AiInterviewPostureDataScalarFieldEnum: {
    posture_id: 'posture_id',
    interview_id: 'interview_id',
    timestamp: 'timestamp',
    posture_data: 'posture_data'
  };

  export type AiInterviewPostureDataScalarFieldEnum = (typeof AiInterviewPostureDataScalarFieldEnum)[keyof typeof AiInterviewPostureDataScalarFieldEnum]


  export const AiVoicePromptScalarFieldEnum: {
    prompt_id: 'prompt_id',
    interview_id: 'interview_id',
    prompt_text: 'prompt_text',
    prompt_audio_path: 'prompt_audio_path'
  };

  export type AiVoicePromptScalarFieldEnum = (typeof AiVoicePromptScalarFieldEnum)[keyof typeof AiVoicePromptScalarFieldEnum]


  export const AiInterviewAnalysisScalarFieldEnum: {
    analysis_id: 'analysis_id',
    interview_id: 'interview_id',
    technical_score: 'technical_score',
    communication_score: 'communication_score',
    confidence_score: 'confidence_score',
    overall_score: 'overall_score',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    improvement_suggestions: 'improvement_suggestions',
    analysis_json: 'analysis_json'
  };

  export type AiInterviewAnalysisScalarFieldEnum = (typeof AiInterviewAnalysisScalarFieldEnum)[keyof typeof AiInterviewAnalysisScalarFieldEnum]


  export const AiGenerationLogScalarFieldEnum: {
    log_id: 'log_id',
    user_id: 'user_id',
    service_used: 'service_used',
    request_payload: 'request_payload',
    response_payload: 'response_payload',
    created_at: 'created_at'
  };

  export type AiGenerationLogScalarFieldEnum = (typeof AiGenerationLogScalarFieldEnum)[keyof typeof AiGenerationLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_id?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    ai_generation_logs?: AiGenerationLogListRelationFilter
    CandidateProfile?: XOR<CandidateProfileNullableScalarRelationFilter, CandidateProfileWhereInput> | null
    roles?: UserRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    ai_generation_logs?: AiGenerationLogOrderByRelationAggregateInput
    CandidateProfile?: CandidateProfileOrderByWithRelationInput
    roles?: UserRoleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password_hash?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    ai_generation_logs?: AiGenerationLogListRelationFilter
    CandidateProfile?: XOR<CandidateProfileNullableScalarRelationFilter, CandidateProfileWhereInput> | null
    roles?: UserRoleListRelationFilter
  }, "user_id" | "email">

  export type UserOrderByWithAggregationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"User"> | number
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_id?: IntFilter<"Role"> | number
    role_name?: StringFilter<"Role"> | string
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    role_name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserRoleListRelationFilter
  }, "role_id" | "role_name">

  export type RoleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"Role"> | number
    role_name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    user_id?: IntFilter<"UserRole"> | number
    role_id?: IntFilter<"UserRole"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    user_id_role_id?: UserRoleUser_idRole_idCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    user_id?: IntFilter<"UserRole"> | number
    role_id?: IntFilter<"UserRole"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_role_id">

  export type UserRoleOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"UserRole"> | number
    role_id?: IntWithAggregatesFilter<"UserRole"> | number
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    company_id?: IntFilter<"Company"> | number
    name?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    created_at?: DateTimeNullableFilter<"Company"> | Date | string | null
    job_postings?: JobPostingListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    company_id?: SortOrder
    name?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    job_postings?: JobPostingOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    company_id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringNullableFilter<"Company"> | string | null
    website?: StringNullableFilter<"Company"> | string | null
    created_at?: DateTimeNullableFilter<"Company"> | Date | string | null
    job_postings?: JobPostingListRelationFilter
  }, "company_id">

  export type CompanyOrderByWithAggregationInput = {
    company_id?: SortOrder
    name?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    company_id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringNullableWithAggregatesFilter<"Company"> | string | null
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
  }

  export type JobPostingWhereInput = {
    AND?: JobPostingWhereInput | JobPostingWhereInput[]
    OR?: JobPostingWhereInput[]
    NOT?: JobPostingWhereInput | JobPostingWhereInput[]
    job_id?: IntFilter<"JobPosting"> | number
    company_id?: IntFilter<"JobPosting"> | number
    title?: StringNullableFilter<"JobPosting"> | string | null
    description?: StringNullableFilter<"JobPosting"> | string | null
    location?: StringNullableFilter<"JobPosting"> | string | null
    posted_at?: DateTimeNullableFilter<"JobPosting"> | Date | string | null
    interviews?: AiInterviewListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    requirements?: JobRequirementListRelationFilter
    matches?: ResumeVsJdMatchListRelationFilter
  }

  export type JobPostingOrderByWithRelationInput = {
    job_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    interviews?: AiInterviewOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    requirements?: JobRequirementOrderByRelationAggregateInput
    matches?: ResumeVsJdMatchOrderByRelationAggregateInput
  }

  export type JobPostingWhereUniqueInput = Prisma.AtLeast<{
    job_id?: number
    AND?: JobPostingWhereInput | JobPostingWhereInput[]
    OR?: JobPostingWhereInput[]
    NOT?: JobPostingWhereInput | JobPostingWhereInput[]
    company_id?: IntFilter<"JobPosting"> | number
    title?: StringNullableFilter<"JobPosting"> | string | null
    description?: StringNullableFilter<"JobPosting"> | string | null
    location?: StringNullableFilter<"JobPosting"> | string | null
    posted_at?: DateTimeNullableFilter<"JobPosting"> | Date | string | null
    interviews?: AiInterviewListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    requirements?: JobRequirementListRelationFilter
    matches?: ResumeVsJdMatchListRelationFilter
  }, "job_id">

  export type JobPostingOrderByWithAggregationInput = {
    job_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    posted_at?: SortOrderInput | SortOrder
    _count?: JobPostingCountOrderByAggregateInput
    _avg?: JobPostingAvgOrderByAggregateInput
    _max?: JobPostingMaxOrderByAggregateInput
    _min?: JobPostingMinOrderByAggregateInput
    _sum?: JobPostingSumOrderByAggregateInput
  }

  export type JobPostingScalarWhereWithAggregatesInput = {
    AND?: JobPostingScalarWhereWithAggregatesInput | JobPostingScalarWhereWithAggregatesInput[]
    OR?: JobPostingScalarWhereWithAggregatesInput[]
    NOT?: JobPostingScalarWhereWithAggregatesInput | JobPostingScalarWhereWithAggregatesInput[]
    job_id?: IntWithAggregatesFilter<"JobPosting"> | number
    company_id?: IntWithAggregatesFilter<"JobPosting"> | number
    title?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
    description?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
    location?: StringNullableWithAggregatesFilter<"JobPosting"> | string | null
    posted_at?: DateTimeNullableWithAggregatesFilter<"JobPosting"> | Date | string | null
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    skill_id?: IntFilter<"Skill"> | number
    skill_name?: StringFilter<"Skill"> | string
    job_requirements?: JobRequirementListRelationFilter
    parsed_resume_skills?: ParsedResumeSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    skill_id?: SortOrder
    skill_name?: SortOrder
    job_requirements?: JobRequirementOrderByRelationAggregateInput
    parsed_resume_skills?: ParsedResumeSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    skill_id?: number
    skill_name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    job_requirements?: JobRequirementListRelationFilter
    parsed_resume_skills?: ParsedResumeSkillListRelationFilter
  }, "skill_id" | "skill_name">

  export type SkillOrderByWithAggregationInput = {
    skill_id?: SortOrder
    skill_name?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    skill_id?: IntWithAggregatesFilter<"Skill"> | number
    skill_name?: StringWithAggregatesFilter<"Skill"> | string
  }

  export type JobRequirementWhereInput = {
    AND?: JobRequirementWhereInput | JobRequirementWhereInput[]
    OR?: JobRequirementWhereInput[]
    NOT?: JobRequirementWhereInput | JobRequirementWhereInput[]
    req_id?: IntFilter<"JobRequirement"> | number
    job_id?: IntFilter<"JobRequirement"> | number
    skill_id?: IntFilter<"JobRequirement"> | number
    required_level?: StringNullableFilter<"JobRequirement"> | string | null
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type JobRequirementOrderByWithRelationInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    required_level?: SortOrderInput | SortOrder
    job?: JobPostingOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type JobRequirementWhereUniqueInput = Prisma.AtLeast<{
    req_id?: number
    AND?: JobRequirementWhereInput | JobRequirementWhereInput[]
    OR?: JobRequirementWhereInput[]
    NOT?: JobRequirementWhereInput | JobRequirementWhereInput[]
    job_id?: IntFilter<"JobRequirement"> | number
    skill_id?: IntFilter<"JobRequirement"> | number
    required_level?: StringNullableFilter<"JobRequirement"> | string | null
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "req_id">

  export type JobRequirementOrderByWithAggregationInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    required_level?: SortOrderInput | SortOrder
    _count?: JobRequirementCountOrderByAggregateInput
    _avg?: JobRequirementAvgOrderByAggregateInput
    _max?: JobRequirementMaxOrderByAggregateInput
    _min?: JobRequirementMinOrderByAggregateInput
    _sum?: JobRequirementSumOrderByAggregateInput
  }

  export type JobRequirementScalarWhereWithAggregatesInput = {
    AND?: JobRequirementScalarWhereWithAggregatesInput | JobRequirementScalarWhereWithAggregatesInput[]
    OR?: JobRequirementScalarWhereWithAggregatesInput[]
    NOT?: JobRequirementScalarWhereWithAggregatesInput | JobRequirementScalarWhereWithAggregatesInput[]
    req_id?: IntWithAggregatesFilter<"JobRequirement"> | number
    job_id?: IntWithAggregatesFilter<"JobRequirement"> | number
    skill_id?: IntWithAggregatesFilter<"JobRequirement"> | number
    required_level?: StringNullableWithAggregatesFilter<"JobRequirement"> | string | null
  }

  export type CandidateProfileWhereInput = {
    AND?: CandidateProfileWhereInput | CandidateProfileWhereInput[]
    OR?: CandidateProfileWhereInput[]
    NOT?: CandidateProfileWhereInput | CandidateProfileWhereInput[]
    candidate_id?: IntFilter<"CandidateProfile"> | number
    education?: StringNullableFilter<"CandidateProfile"> | string | null
    experience?: StringNullableFilter<"CandidateProfile"> | string | null
    interviews?: AiInterviewListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resumes?: ResumeListRelationFilter
  }

  export type CandidateProfileOrderByWithRelationInput = {
    candidate_id?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    interviews?: AiInterviewOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    resumes?: ResumeOrderByRelationAggregateInput
  }

  export type CandidateProfileWhereUniqueInput = Prisma.AtLeast<{
    candidate_id?: number
    AND?: CandidateProfileWhereInput | CandidateProfileWhereInput[]
    OR?: CandidateProfileWhereInput[]
    NOT?: CandidateProfileWhereInput | CandidateProfileWhereInput[]
    education?: StringNullableFilter<"CandidateProfile"> | string | null
    experience?: StringNullableFilter<"CandidateProfile"> | string | null
    interviews?: AiInterviewListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resumes?: ResumeListRelationFilter
  }, "candidate_id">

  export type CandidateProfileOrderByWithAggregationInput = {
    candidate_id?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    _count?: CandidateProfileCountOrderByAggregateInput
    _avg?: CandidateProfileAvgOrderByAggregateInput
    _max?: CandidateProfileMaxOrderByAggregateInput
    _min?: CandidateProfileMinOrderByAggregateInput
    _sum?: CandidateProfileSumOrderByAggregateInput
  }

  export type CandidateProfileScalarWhereWithAggregatesInput = {
    AND?: CandidateProfileScalarWhereWithAggregatesInput | CandidateProfileScalarWhereWithAggregatesInput[]
    OR?: CandidateProfileScalarWhereWithAggregatesInput[]
    NOT?: CandidateProfileScalarWhereWithAggregatesInput | CandidateProfileScalarWhereWithAggregatesInput[]
    candidate_id?: IntWithAggregatesFilter<"CandidateProfile"> | number
    education?: StringNullableWithAggregatesFilter<"CandidateProfile"> | string | null
    experience?: StringNullableWithAggregatesFilter<"CandidateProfile"> | string | null
  }

  export type ResumeWhereInput = {
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    resume_id?: IntFilter<"Resume"> | number
    candidate_id?: IntFilter<"Resume"> | number
    file_path?: StringNullableFilter<"Resume"> | string | null
    parsed_text?: StringNullableFilter<"Resume"> | string | null
    parsed_json?: JsonNullableFilter<"Resume">
    uploaded_at?: DateTimeNullableFilter<"Resume"> | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillListRelationFilter
    candidate?: XOR<CandidateProfileScalarRelationFilter, CandidateProfileWhereInput>
    matches?: ResumeVsJdMatchListRelationFilter
  }

  export type ResumeOrderByWithRelationInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
    file_path?: SortOrderInput | SortOrder
    parsed_text?: SortOrderInput | SortOrder
    parsed_json?: SortOrderInput | SortOrder
    uploaded_at?: SortOrderInput | SortOrder
    parsed_resume_skills?: ParsedResumeSkillOrderByRelationAggregateInput
    candidate?: CandidateProfileOrderByWithRelationInput
    matches?: ResumeVsJdMatchOrderByRelationAggregateInput
  }

  export type ResumeWhereUniqueInput = Prisma.AtLeast<{
    resume_id?: number
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    candidate_id?: IntFilter<"Resume"> | number
    file_path?: StringNullableFilter<"Resume"> | string | null
    parsed_text?: StringNullableFilter<"Resume"> | string | null
    parsed_json?: JsonNullableFilter<"Resume">
    uploaded_at?: DateTimeNullableFilter<"Resume"> | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillListRelationFilter
    candidate?: XOR<CandidateProfileScalarRelationFilter, CandidateProfileWhereInput>
    matches?: ResumeVsJdMatchListRelationFilter
  }, "resume_id">

  export type ResumeOrderByWithAggregationInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
    file_path?: SortOrderInput | SortOrder
    parsed_text?: SortOrderInput | SortOrder
    parsed_json?: SortOrderInput | SortOrder
    uploaded_at?: SortOrderInput | SortOrder
    _count?: ResumeCountOrderByAggregateInput
    _avg?: ResumeAvgOrderByAggregateInput
    _max?: ResumeMaxOrderByAggregateInput
    _min?: ResumeMinOrderByAggregateInput
    _sum?: ResumeSumOrderByAggregateInput
  }

  export type ResumeScalarWhereWithAggregatesInput = {
    AND?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    OR?: ResumeScalarWhereWithAggregatesInput[]
    NOT?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    resume_id?: IntWithAggregatesFilter<"Resume"> | number
    candidate_id?: IntWithAggregatesFilter<"Resume"> | number
    file_path?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    parsed_text?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    parsed_json?: JsonNullableWithAggregatesFilter<"Resume">
    uploaded_at?: DateTimeNullableWithAggregatesFilter<"Resume"> | Date | string | null
  }

  export type ParsedResumeSkillWhereInput = {
    AND?: ParsedResumeSkillWhereInput | ParsedResumeSkillWhereInput[]
    OR?: ParsedResumeSkillWhereInput[]
    NOT?: ParsedResumeSkillWhereInput | ParsedResumeSkillWhereInput[]
    resume_id?: IntFilter<"ParsedResumeSkill"> | number
    skill_id?: IntFilter<"ParsedResumeSkill"> | number
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type ParsedResumeSkillOrderByWithRelationInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type ParsedResumeSkillWhereUniqueInput = Prisma.AtLeast<{
    resume_id_skill_id?: ParsedResumeSkillResume_idSkill_idCompoundUniqueInput
    AND?: ParsedResumeSkillWhereInput | ParsedResumeSkillWhereInput[]
    OR?: ParsedResumeSkillWhereInput[]
    NOT?: ParsedResumeSkillWhereInput | ParsedResumeSkillWhereInput[]
    resume_id?: IntFilter<"ParsedResumeSkill"> | number
    skill_id?: IntFilter<"ParsedResumeSkill"> | number
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "resume_id_skill_id">

  export type ParsedResumeSkillOrderByWithAggregationInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
    _count?: ParsedResumeSkillCountOrderByAggregateInput
    _avg?: ParsedResumeSkillAvgOrderByAggregateInput
    _max?: ParsedResumeSkillMaxOrderByAggregateInput
    _min?: ParsedResumeSkillMinOrderByAggregateInput
    _sum?: ParsedResumeSkillSumOrderByAggregateInput
  }

  export type ParsedResumeSkillScalarWhereWithAggregatesInput = {
    AND?: ParsedResumeSkillScalarWhereWithAggregatesInput | ParsedResumeSkillScalarWhereWithAggregatesInput[]
    OR?: ParsedResumeSkillScalarWhereWithAggregatesInput[]
    NOT?: ParsedResumeSkillScalarWhereWithAggregatesInput | ParsedResumeSkillScalarWhereWithAggregatesInput[]
    resume_id?: IntWithAggregatesFilter<"ParsedResumeSkill"> | number
    skill_id?: IntWithAggregatesFilter<"ParsedResumeSkill"> | number
  }

  export type ResumeVsJdMatchWhereInput = {
    AND?: ResumeVsJdMatchWhereInput | ResumeVsJdMatchWhereInput[]
    OR?: ResumeVsJdMatchWhereInput[]
    NOT?: ResumeVsJdMatchWhereInput | ResumeVsJdMatchWhereInput[]
    match_id?: IntFilter<"ResumeVsJdMatch"> | number
    resume_id?: IntFilter<"ResumeVsJdMatch"> | number
    job_id?: IntFilter<"ResumeVsJdMatch"> | number
    match_score?: FloatNullableFilter<"ResumeVsJdMatch"> | number | null
    matched_skills?: JsonNullableFilter<"ResumeVsJdMatch">
    missing_skills?: JsonNullableFilter<"ResumeVsJdMatch">
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }

  export type ResumeVsJdMatchOrderByWithRelationInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrderInput | SortOrder
    matched_skills?: SortOrderInput | SortOrder
    missing_skills?: SortOrderInput | SortOrder
    job?: JobPostingOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
  }

  export type ResumeVsJdMatchWhereUniqueInput = Prisma.AtLeast<{
    match_id?: number
    AND?: ResumeVsJdMatchWhereInput | ResumeVsJdMatchWhereInput[]
    OR?: ResumeVsJdMatchWhereInput[]
    NOT?: ResumeVsJdMatchWhereInput | ResumeVsJdMatchWhereInput[]
    resume_id?: IntFilter<"ResumeVsJdMatch"> | number
    job_id?: IntFilter<"ResumeVsJdMatch"> | number
    match_score?: FloatNullableFilter<"ResumeVsJdMatch"> | number | null
    matched_skills?: JsonNullableFilter<"ResumeVsJdMatch">
    missing_skills?: JsonNullableFilter<"ResumeVsJdMatch">
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
  }, "match_id">

  export type ResumeVsJdMatchOrderByWithAggregationInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrderInput | SortOrder
    matched_skills?: SortOrderInput | SortOrder
    missing_skills?: SortOrderInput | SortOrder
    _count?: ResumeVsJdMatchCountOrderByAggregateInput
    _avg?: ResumeVsJdMatchAvgOrderByAggregateInput
    _max?: ResumeVsJdMatchMaxOrderByAggregateInput
    _min?: ResumeVsJdMatchMinOrderByAggregateInput
    _sum?: ResumeVsJdMatchSumOrderByAggregateInput
  }

  export type ResumeVsJdMatchScalarWhereWithAggregatesInput = {
    AND?: ResumeVsJdMatchScalarWhereWithAggregatesInput | ResumeVsJdMatchScalarWhereWithAggregatesInput[]
    OR?: ResumeVsJdMatchScalarWhereWithAggregatesInput[]
    NOT?: ResumeVsJdMatchScalarWhereWithAggregatesInput | ResumeVsJdMatchScalarWhereWithAggregatesInput[]
    match_id?: IntWithAggregatesFilter<"ResumeVsJdMatch"> | number
    resume_id?: IntWithAggregatesFilter<"ResumeVsJdMatch"> | number
    job_id?: IntWithAggregatesFilter<"ResumeVsJdMatch"> | number
    match_score?: FloatNullableWithAggregatesFilter<"ResumeVsJdMatch"> | number | null
    matched_skills?: JsonNullableWithAggregatesFilter<"ResumeVsJdMatch">
    missing_skills?: JsonNullableWithAggregatesFilter<"ResumeVsJdMatch">
  }

  export type AiInterviewWhereInput = {
    AND?: AiInterviewWhereInput | AiInterviewWhereInput[]
    OR?: AiInterviewWhereInput[]
    NOT?: AiInterviewWhereInput | AiInterviewWhereInput[]
    interview_id?: IntFilter<"AiInterview"> | number
    job_id?: IntFilter<"AiInterview"> | number
    candidate_id?: IntFilter<"AiInterview"> | number
    scheduled_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
    status?: StringNullableFilter<"AiInterview"> | string | null
    created_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
    candidate?: XOR<CandidateProfileScalarRelationFilter, CandidateProfileWhereInput>
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    analysis?: XOR<AiInterviewAnalysisNullableScalarRelationFilter, AiInterviewAnalysisWhereInput> | null
    cheating_events?: AiInterviewCheatingEventListRelationFilter
    posture_data?: AiInterviewPostureDataListRelationFilter
    questions?: AiInterviewQuestionListRelationFilter
    responses?: AiInterviewResponseListRelationFilter
    voice_prompts?: AiVoicePromptListRelationFilter
  }

  export type AiInterviewOrderByWithRelationInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    candidate?: CandidateProfileOrderByWithRelationInput
    job?: JobPostingOrderByWithRelationInput
    analysis?: AiInterviewAnalysisOrderByWithRelationInput
    cheating_events?: AiInterviewCheatingEventOrderByRelationAggregateInput
    posture_data?: AiInterviewPostureDataOrderByRelationAggregateInput
    questions?: AiInterviewQuestionOrderByRelationAggregateInput
    responses?: AiInterviewResponseOrderByRelationAggregateInput
    voice_prompts?: AiVoicePromptOrderByRelationAggregateInput
  }

  export type AiInterviewWhereUniqueInput = Prisma.AtLeast<{
    interview_id?: number
    AND?: AiInterviewWhereInput | AiInterviewWhereInput[]
    OR?: AiInterviewWhereInput[]
    NOT?: AiInterviewWhereInput | AiInterviewWhereInput[]
    job_id?: IntFilter<"AiInterview"> | number
    candidate_id?: IntFilter<"AiInterview"> | number
    scheduled_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
    status?: StringNullableFilter<"AiInterview"> | string | null
    created_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
    candidate?: XOR<CandidateProfileScalarRelationFilter, CandidateProfileWhereInput>
    job?: XOR<JobPostingScalarRelationFilter, JobPostingWhereInput>
    analysis?: XOR<AiInterviewAnalysisNullableScalarRelationFilter, AiInterviewAnalysisWhereInput> | null
    cheating_events?: AiInterviewCheatingEventListRelationFilter
    posture_data?: AiInterviewPostureDataListRelationFilter
    questions?: AiInterviewQuestionListRelationFilter
    responses?: AiInterviewResponseListRelationFilter
    voice_prompts?: AiVoicePromptListRelationFilter
  }, "interview_id">

  export type AiInterviewOrderByWithAggregationInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
    scheduled_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: AiInterviewCountOrderByAggregateInput
    _avg?: AiInterviewAvgOrderByAggregateInput
    _max?: AiInterviewMaxOrderByAggregateInput
    _min?: AiInterviewMinOrderByAggregateInput
    _sum?: AiInterviewSumOrderByAggregateInput
  }

  export type AiInterviewScalarWhereWithAggregatesInput = {
    AND?: AiInterviewScalarWhereWithAggregatesInput | AiInterviewScalarWhereWithAggregatesInput[]
    OR?: AiInterviewScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewScalarWhereWithAggregatesInput | AiInterviewScalarWhereWithAggregatesInput[]
    interview_id?: IntWithAggregatesFilter<"AiInterview"> | number
    job_id?: IntWithAggregatesFilter<"AiInterview"> | number
    candidate_id?: IntWithAggregatesFilter<"AiInterview"> | number
    scheduled_at?: DateTimeNullableWithAggregatesFilter<"AiInterview"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"AiInterview"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"AiInterview"> | Date | string | null
  }

  export type AiInterviewQuestionWhereInput = {
    AND?: AiInterviewQuestionWhereInput | AiInterviewQuestionWhereInput[]
    OR?: AiInterviewQuestionWhereInput[]
    NOT?: AiInterviewQuestionWhereInput | AiInterviewQuestionWhereInput[]
    question_id?: IntFilter<"AiInterviewQuestion"> | number
    interview_id?: IntFilter<"AiInterviewQuestion"> | number
    question_text?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    question_type?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    ai_generated?: BoolNullableFilter<"AiInterviewQuestion"> | boolean | null
    asked_at?: DateTimeNullableFilter<"AiInterviewQuestion"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
    responses?: AiInterviewResponseListRelationFilter
  }

  export type AiInterviewQuestionOrderByWithRelationInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
    question_text?: SortOrderInput | SortOrder
    question_type?: SortOrderInput | SortOrder
    ai_generated?: SortOrderInput | SortOrder
    asked_at?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
    responses?: AiInterviewResponseOrderByRelationAggregateInput
  }

  export type AiInterviewQuestionWhereUniqueInput = Prisma.AtLeast<{
    question_id?: number
    AND?: AiInterviewQuestionWhereInput | AiInterviewQuestionWhereInput[]
    OR?: AiInterviewQuestionWhereInput[]
    NOT?: AiInterviewQuestionWhereInput | AiInterviewQuestionWhereInput[]
    interview_id?: IntFilter<"AiInterviewQuestion"> | number
    question_text?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    question_type?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    ai_generated?: BoolNullableFilter<"AiInterviewQuestion"> | boolean | null
    asked_at?: DateTimeNullableFilter<"AiInterviewQuestion"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
    responses?: AiInterviewResponseListRelationFilter
  }, "question_id">

  export type AiInterviewQuestionOrderByWithAggregationInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
    question_text?: SortOrderInput | SortOrder
    question_type?: SortOrderInput | SortOrder
    ai_generated?: SortOrderInput | SortOrder
    asked_at?: SortOrderInput | SortOrder
    _count?: AiInterviewQuestionCountOrderByAggregateInput
    _avg?: AiInterviewQuestionAvgOrderByAggregateInput
    _max?: AiInterviewQuestionMaxOrderByAggregateInput
    _min?: AiInterviewQuestionMinOrderByAggregateInput
    _sum?: AiInterviewQuestionSumOrderByAggregateInput
  }

  export type AiInterviewQuestionScalarWhereWithAggregatesInput = {
    AND?: AiInterviewQuestionScalarWhereWithAggregatesInput | AiInterviewQuestionScalarWhereWithAggregatesInput[]
    OR?: AiInterviewQuestionScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewQuestionScalarWhereWithAggregatesInput | AiInterviewQuestionScalarWhereWithAggregatesInput[]
    question_id?: IntWithAggregatesFilter<"AiInterviewQuestion"> | number
    interview_id?: IntWithAggregatesFilter<"AiInterviewQuestion"> | number
    question_text?: StringNullableWithAggregatesFilter<"AiInterviewQuestion"> | string | null
    question_type?: StringNullableWithAggregatesFilter<"AiInterviewQuestion"> | string | null
    ai_generated?: BoolNullableWithAggregatesFilter<"AiInterviewQuestion"> | boolean | null
    asked_at?: DateTimeNullableWithAggregatesFilter<"AiInterviewQuestion"> | Date | string | null
  }

  export type AiInterviewResponseWhereInput = {
    AND?: AiInterviewResponseWhereInput | AiInterviewResponseWhereInput[]
    OR?: AiInterviewResponseWhereInput[]
    NOT?: AiInterviewResponseWhereInput | AiInterviewResponseWhereInput[]
    response_id?: IntFilter<"AiInterviewResponse"> | number
    interview_id?: IntFilter<"AiInterviewResponse"> | number
    question_id?: IntFilter<"AiInterviewResponse"> | number
    response_text?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_audio_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_video_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    transcript?: StringNullableFilter<"AiInterviewResponse"> | string | null
    captured_at?: DateTimeNullableFilter<"AiInterviewResponse"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
    question?: XOR<AiInterviewQuestionScalarRelationFilter, AiInterviewQuestionWhereInput>
  }

  export type AiInterviewResponseOrderByWithRelationInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
    response_text?: SortOrderInput | SortOrder
    response_audio_path?: SortOrderInput | SortOrder
    response_video_path?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    captured_at?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
    question?: AiInterviewQuestionOrderByWithRelationInput
  }

  export type AiInterviewResponseWhereUniqueInput = Prisma.AtLeast<{
    response_id?: number
    AND?: AiInterviewResponseWhereInput | AiInterviewResponseWhereInput[]
    OR?: AiInterviewResponseWhereInput[]
    NOT?: AiInterviewResponseWhereInput | AiInterviewResponseWhereInput[]
    interview_id?: IntFilter<"AiInterviewResponse"> | number
    question_id?: IntFilter<"AiInterviewResponse"> | number
    response_text?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_audio_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_video_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    transcript?: StringNullableFilter<"AiInterviewResponse"> | string | null
    captured_at?: DateTimeNullableFilter<"AiInterviewResponse"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
    question?: XOR<AiInterviewQuestionScalarRelationFilter, AiInterviewQuestionWhereInput>
  }, "response_id">

  export type AiInterviewResponseOrderByWithAggregationInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
    response_text?: SortOrderInput | SortOrder
    response_audio_path?: SortOrderInput | SortOrder
    response_video_path?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    captured_at?: SortOrderInput | SortOrder
    _count?: AiInterviewResponseCountOrderByAggregateInput
    _avg?: AiInterviewResponseAvgOrderByAggregateInput
    _max?: AiInterviewResponseMaxOrderByAggregateInput
    _min?: AiInterviewResponseMinOrderByAggregateInput
    _sum?: AiInterviewResponseSumOrderByAggregateInput
  }

  export type AiInterviewResponseScalarWhereWithAggregatesInput = {
    AND?: AiInterviewResponseScalarWhereWithAggregatesInput | AiInterviewResponseScalarWhereWithAggregatesInput[]
    OR?: AiInterviewResponseScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewResponseScalarWhereWithAggregatesInput | AiInterviewResponseScalarWhereWithAggregatesInput[]
    response_id?: IntWithAggregatesFilter<"AiInterviewResponse"> | number
    interview_id?: IntWithAggregatesFilter<"AiInterviewResponse"> | number
    question_id?: IntWithAggregatesFilter<"AiInterviewResponse"> | number
    response_text?: StringNullableWithAggregatesFilter<"AiInterviewResponse"> | string | null
    response_audio_path?: StringNullableWithAggregatesFilter<"AiInterviewResponse"> | string | null
    response_video_path?: StringNullableWithAggregatesFilter<"AiInterviewResponse"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"AiInterviewResponse"> | string | null
    captured_at?: DateTimeNullableWithAggregatesFilter<"AiInterviewResponse"> | Date | string | null
  }

  export type AiInterviewCheatingEventWhereInput = {
    AND?: AiInterviewCheatingEventWhereInput | AiInterviewCheatingEventWhereInput[]
    OR?: AiInterviewCheatingEventWhereInput[]
    NOT?: AiInterviewCheatingEventWhereInput | AiInterviewCheatingEventWhereInput[]
    event_id?: IntFilter<"AiInterviewCheatingEvent"> | number
    interview_id?: IntFilter<"AiInterviewCheatingEvent"> | number
    event_type?: StringNullableFilter<"AiInterviewCheatingEvent"> | string | null
    confidence_score?: FloatNullableFilter<"AiInterviewCheatingEvent"> | number | null
    detected_at?: DateTimeNullableFilter<"AiInterviewCheatingEvent"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }

  export type AiInterviewCheatingEventOrderByWithRelationInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    event_type?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    detected_at?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
  }

  export type AiInterviewCheatingEventWhereUniqueInput = Prisma.AtLeast<{
    event_id?: number
    AND?: AiInterviewCheatingEventWhereInput | AiInterviewCheatingEventWhereInput[]
    OR?: AiInterviewCheatingEventWhereInput[]
    NOT?: AiInterviewCheatingEventWhereInput | AiInterviewCheatingEventWhereInput[]
    interview_id?: IntFilter<"AiInterviewCheatingEvent"> | number
    event_type?: StringNullableFilter<"AiInterviewCheatingEvent"> | string | null
    confidence_score?: FloatNullableFilter<"AiInterviewCheatingEvent"> | number | null
    detected_at?: DateTimeNullableFilter<"AiInterviewCheatingEvent"> | Date | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }, "event_id">

  export type AiInterviewCheatingEventOrderByWithAggregationInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    event_type?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    detected_at?: SortOrderInput | SortOrder
    _count?: AiInterviewCheatingEventCountOrderByAggregateInput
    _avg?: AiInterviewCheatingEventAvgOrderByAggregateInput
    _max?: AiInterviewCheatingEventMaxOrderByAggregateInput
    _min?: AiInterviewCheatingEventMinOrderByAggregateInput
    _sum?: AiInterviewCheatingEventSumOrderByAggregateInput
  }

  export type AiInterviewCheatingEventScalarWhereWithAggregatesInput = {
    AND?: AiInterviewCheatingEventScalarWhereWithAggregatesInput | AiInterviewCheatingEventScalarWhereWithAggregatesInput[]
    OR?: AiInterviewCheatingEventScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewCheatingEventScalarWhereWithAggregatesInput | AiInterviewCheatingEventScalarWhereWithAggregatesInput[]
    event_id?: IntWithAggregatesFilter<"AiInterviewCheatingEvent"> | number
    interview_id?: IntWithAggregatesFilter<"AiInterviewCheatingEvent"> | number
    event_type?: StringNullableWithAggregatesFilter<"AiInterviewCheatingEvent"> | string | null
    confidence_score?: FloatNullableWithAggregatesFilter<"AiInterviewCheatingEvent"> | number | null
    detected_at?: DateTimeNullableWithAggregatesFilter<"AiInterviewCheatingEvent"> | Date | string | null
  }

  export type AiInterviewPostureDataWhereInput = {
    AND?: AiInterviewPostureDataWhereInput | AiInterviewPostureDataWhereInput[]
    OR?: AiInterviewPostureDataWhereInput[]
    NOT?: AiInterviewPostureDataWhereInput | AiInterviewPostureDataWhereInput[]
    posture_id?: IntFilter<"AiInterviewPostureData"> | number
    interview_id?: IntFilter<"AiInterviewPostureData"> | number
    timestamp?: DateTimeNullableFilter<"AiInterviewPostureData"> | Date | string | null
    posture_data?: JsonNullableFilter<"AiInterviewPostureData">
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }

  export type AiInterviewPostureDataOrderByWithRelationInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    posture_data?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
  }

  export type AiInterviewPostureDataWhereUniqueInput = Prisma.AtLeast<{
    posture_id?: number
    AND?: AiInterviewPostureDataWhereInput | AiInterviewPostureDataWhereInput[]
    OR?: AiInterviewPostureDataWhereInput[]
    NOT?: AiInterviewPostureDataWhereInput | AiInterviewPostureDataWhereInput[]
    interview_id?: IntFilter<"AiInterviewPostureData"> | number
    timestamp?: DateTimeNullableFilter<"AiInterviewPostureData"> | Date | string | null
    posture_data?: JsonNullableFilter<"AiInterviewPostureData">
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }, "posture_id">

  export type AiInterviewPostureDataOrderByWithAggregationInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    posture_data?: SortOrderInput | SortOrder
    _count?: AiInterviewPostureDataCountOrderByAggregateInput
    _avg?: AiInterviewPostureDataAvgOrderByAggregateInput
    _max?: AiInterviewPostureDataMaxOrderByAggregateInput
    _min?: AiInterviewPostureDataMinOrderByAggregateInput
    _sum?: AiInterviewPostureDataSumOrderByAggregateInput
  }

  export type AiInterviewPostureDataScalarWhereWithAggregatesInput = {
    AND?: AiInterviewPostureDataScalarWhereWithAggregatesInput | AiInterviewPostureDataScalarWhereWithAggregatesInput[]
    OR?: AiInterviewPostureDataScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewPostureDataScalarWhereWithAggregatesInput | AiInterviewPostureDataScalarWhereWithAggregatesInput[]
    posture_id?: IntWithAggregatesFilter<"AiInterviewPostureData"> | number
    interview_id?: IntWithAggregatesFilter<"AiInterviewPostureData"> | number
    timestamp?: DateTimeNullableWithAggregatesFilter<"AiInterviewPostureData"> | Date | string | null
    posture_data?: JsonNullableWithAggregatesFilter<"AiInterviewPostureData">
  }

  export type AiVoicePromptWhereInput = {
    AND?: AiVoicePromptWhereInput | AiVoicePromptWhereInput[]
    OR?: AiVoicePromptWhereInput[]
    NOT?: AiVoicePromptWhereInput | AiVoicePromptWhereInput[]
    prompt_id?: IntFilter<"AiVoicePrompt"> | number
    interview_id?: IntFilter<"AiVoicePrompt"> | number
    prompt_text?: StringNullableFilter<"AiVoicePrompt"> | string | null
    prompt_audio_path?: StringNullableFilter<"AiVoicePrompt"> | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }

  export type AiVoicePromptOrderByWithRelationInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
    prompt_text?: SortOrderInput | SortOrder
    prompt_audio_path?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
  }

  export type AiVoicePromptWhereUniqueInput = Prisma.AtLeast<{
    prompt_id?: number
    AND?: AiVoicePromptWhereInput | AiVoicePromptWhereInput[]
    OR?: AiVoicePromptWhereInput[]
    NOT?: AiVoicePromptWhereInput | AiVoicePromptWhereInput[]
    interview_id?: IntFilter<"AiVoicePrompt"> | number
    prompt_text?: StringNullableFilter<"AiVoicePrompt"> | string | null
    prompt_audio_path?: StringNullableFilter<"AiVoicePrompt"> | string | null
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }, "prompt_id">

  export type AiVoicePromptOrderByWithAggregationInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
    prompt_text?: SortOrderInput | SortOrder
    prompt_audio_path?: SortOrderInput | SortOrder
    _count?: AiVoicePromptCountOrderByAggregateInput
    _avg?: AiVoicePromptAvgOrderByAggregateInput
    _max?: AiVoicePromptMaxOrderByAggregateInput
    _min?: AiVoicePromptMinOrderByAggregateInput
    _sum?: AiVoicePromptSumOrderByAggregateInput
  }

  export type AiVoicePromptScalarWhereWithAggregatesInput = {
    AND?: AiVoicePromptScalarWhereWithAggregatesInput | AiVoicePromptScalarWhereWithAggregatesInput[]
    OR?: AiVoicePromptScalarWhereWithAggregatesInput[]
    NOT?: AiVoicePromptScalarWhereWithAggregatesInput | AiVoicePromptScalarWhereWithAggregatesInput[]
    prompt_id?: IntWithAggregatesFilter<"AiVoicePrompt"> | number
    interview_id?: IntWithAggregatesFilter<"AiVoicePrompt"> | number
    prompt_text?: StringNullableWithAggregatesFilter<"AiVoicePrompt"> | string | null
    prompt_audio_path?: StringNullableWithAggregatesFilter<"AiVoicePrompt"> | string | null
  }

  export type AiInterviewAnalysisWhereInput = {
    AND?: AiInterviewAnalysisWhereInput | AiInterviewAnalysisWhereInput[]
    OR?: AiInterviewAnalysisWhereInput[]
    NOT?: AiInterviewAnalysisWhereInput | AiInterviewAnalysisWhereInput[]
    analysis_id?: IntFilter<"AiInterviewAnalysis"> | number
    interview_id?: IntFilter<"AiInterviewAnalysis"> | number
    technical_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    communication_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    confidence_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    overall_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    strengths?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    weaknesses?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    improvement_suggestions?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    analysis_json?: JsonNullableFilter<"AiInterviewAnalysis">
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }

  export type AiInterviewAnalysisOrderByWithRelationInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrderInput | SortOrder
    communication_score?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    overall_score?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    improvement_suggestions?: SortOrderInput | SortOrder
    analysis_json?: SortOrderInput | SortOrder
    interview?: AiInterviewOrderByWithRelationInput
  }

  export type AiInterviewAnalysisWhereUniqueInput = Prisma.AtLeast<{
    analysis_id?: number
    interview_id?: number
    AND?: AiInterviewAnalysisWhereInput | AiInterviewAnalysisWhereInput[]
    OR?: AiInterviewAnalysisWhereInput[]
    NOT?: AiInterviewAnalysisWhereInput | AiInterviewAnalysisWhereInput[]
    technical_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    communication_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    confidence_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    overall_score?: FloatNullableFilter<"AiInterviewAnalysis"> | number | null
    strengths?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    weaknesses?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    improvement_suggestions?: StringNullableFilter<"AiInterviewAnalysis"> | string | null
    analysis_json?: JsonNullableFilter<"AiInterviewAnalysis">
    interview?: XOR<AiInterviewScalarRelationFilter, AiInterviewWhereInput>
  }, "analysis_id" | "interview_id">

  export type AiInterviewAnalysisOrderByWithAggregationInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrderInput | SortOrder
    communication_score?: SortOrderInput | SortOrder
    confidence_score?: SortOrderInput | SortOrder
    overall_score?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    improvement_suggestions?: SortOrderInput | SortOrder
    analysis_json?: SortOrderInput | SortOrder
    _count?: AiInterviewAnalysisCountOrderByAggregateInput
    _avg?: AiInterviewAnalysisAvgOrderByAggregateInput
    _max?: AiInterviewAnalysisMaxOrderByAggregateInput
    _min?: AiInterviewAnalysisMinOrderByAggregateInput
    _sum?: AiInterviewAnalysisSumOrderByAggregateInput
  }

  export type AiInterviewAnalysisScalarWhereWithAggregatesInput = {
    AND?: AiInterviewAnalysisScalarWhereWithAggregatesInput | AiInterviewAnalysisScalarWhereWithAggregatesInput[]
    OR?: AiInterviewAnalysisScalarWhereWithAggregatesInput[]
    NOT?: AiInterviewAnalysisScalarWhereWithAggregatesInput | AiInterviewAnalysisScalarWhereWithAggregatesInput[]
    analysis_id?: IntWithAggregatesFilter<"AiInterviewAnalysis"> | number
    interview_id?: IntWithAggregatesFilter<"AiInterviewAnalysis"> | number
    technical_score?: FloatNullableWithAggregatesFilter<"AiInterviewAnalysis"> | number | null
    communication_score?: FloatNullableWithAggregatesFilter<"AiInterviewAnalysis"> | number | null
    confidence_score?: FloatNullableWithAggregatesFilter<"AiInterviewAnalysis"> | number | null
    overall_score?: FloatNullableWithAggregatesFilter<"AiInterviewAnalysis"> | number | null
    strengths?: StringNullableWithAggregatesFilter<"AiInterviewAnalysis"> | string | null
    weaknesses?: StringNullableWithAggregatesFilter<"AiInterviewAnalysis"> | string | null
    improvement_suggestions?: StringNullableWithAggregatesFilter<"AiInterviewAnalysis"> | string | null
    analysis_json?: JsonNullableWithAggregatesFilter<"AiInterviewAnalysis">
  }

  export type AiGenerationLogWhereInput = {
    AND?: AiGenerationLogWhereInput | AiGenerationLogWhereInput[]
    OR?: AiGenerationLogWhereInput[]
    NOT?: AiGenerationLogWhereInput | AiGenerationLogWhereInput[]
    log_id?: IntFilter<"AiGenerationLog"> | number
    user_id?: IntFilter<"AiGenerationLog"> | number
    service_used?: StringNullableFilter<"AiGenerationLog"> | string | null
    request_payload?: JsonNullableFilter<"AiGenerationLog">
    response_payload?: JsonNullableFilter<"AiGenerationLog">
    created_at?: DateTimeNullableFilter<"AiGenerationLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AiGenerationLogOrderByWithRelationInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    service_used?: SortOrderInput | SortOrder
    request_payload?: SortOrderInput | SortOrder
    response_payload?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AiGenerationLogWhereUniqueInput = Prisma.AtLeast<{
    log_id?: number
    AND?: AiGenerationLogWhereInput | AiGenerationLogWhereInput[]
    OR?: AiGenerationLogWhereInput[]
    NOT?: AiGenerationLogWhereInput | AiGenerationLogWhereInput[]
    user_id?: IntFilter<"AiGenerationLog"> | number
    service_used?: StringNullableFilter<"AiGenerationLog"> | string | null
    request_payload?: JsonNullableFilter<"AiGenerationLog">
    response_payload?: JsonNullableFilter<"AiGenerationLog">
    created_at?: DateTimeNullableFilter<"AiGenerationLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "log_id">

  export type AiGenerationLogOrderByWithAggregationInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    service_used?: SortOrderInput | SortOrder
    request_payload?: SortOrderInput | SortOrder
    response_payload?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: AiGenerationLogCountOrderByAggregateInput
    _avg?: AiGenerationLogAvgOrderByAggregateInput
    _max?: AiGenerationLogMaxOrderByAggregateInput
    _min?: AiGenerationLogMinOrderByAggregateInput
    _sum?: AiGenerationLogSumOrderByAggregateInput
  }

  export type AiGenerationLogScalarWhereWithAggregatesInput = {
    AND?: AiGenerationLogScalarWhereWithAggregatesInput | AiGenerationLogScalarWhereWithAggregatesInput[]
    OR?: AiGenerationLogScalarWhereWithAggregatesInput[]
    NOT?: AiGenerationLogScalarWhereWithAggregatesInput | AiGenerationLogScalarWhereWithAggregatesInput[]
    log_id?: IntWithAggregatesFilter<"AiGenerationLog"> | number
    user_id?: IntWithAggregatesFilter<"AiGenerationLog"> | number
    service_used?: StringNullableWithAggregatesFilter<"AiGenerationLog"> | string | null
    request_payload?: JsonNullableWithAggregatesFilter<"AiGenerationLog">
    response_payload?: JsonNullableWithAggregatesFilter<"AiGenerationLog">
    created_at?: DateTimeNullableWithAggregatesFilter<"AiGenerationLog"> | Date | string | null
  }

  export type UserCreateInput = {
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogCreateNestedManyWithoutUserInput
    CandidateProfile?: CandidateProfileCreateNestedOneWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_id?: number
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedCreateNestedManyWithoutUserInput
    CandidateProfile?: CandidateProfileUncheckedCreateNestedOneWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUpdateManyWithoutUserNestedInput
    CandidateProfile?: CandidateProfileUpdateOneWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedUpdateManyWithoutUserNestedInput
    CandidateProfile?: CandidateProfileUncheckedUpdateOneWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_id?: number
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    role_name: string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    role_id?: number
    role_name: string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    role_id?: number
    role_name: string
  }

  export type RoleUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateInput = {
    role: RoleCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    user_id: number
    role_id: number
  }

  export type UserRoleUpdateInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyInput = {
    user_id: number
    role_id: number
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyCreateInput = {
    name?: string | null
    website?: string | null
    created_at?: Date | string | null
    job_postings?: JobPostingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    company_id?: number
    name?: string | null
    website?: string | null
    created_at?: Date | string | null
    job_postings?: JobPostingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_postings?: JobPostingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job_postings?: JobPostingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    company_id?: number
    name?: string | null
    website?: string | null
    created_at?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobPostingCreateInput = {
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewCreateNestedManyWithoutJobInput
    company: CompanyCreateNestedOneWithoutJob_postingsInput
    requirements?: JobRequirementCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutJobInput
  }

  export type JobPostingUncheckedCreateInput = {
    job_id?: number
    company_id: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutJobInput
    requirements?: JobRequirementUncheckedCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobPostingUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUpdateManyWithoutJobNestedInput
    company?: CompanyUpdateOneRequiredWithoutJob_postingsNestedInput
    requirements?: JobRequirementUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutJobNestedInput
    requirements?: JobRequirementUncheckedUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobPostingCreateManyInput = {
    job_id?: number
    company_id: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
  }

  export type JobPostingUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobPostingUncheckedUpdateManyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillCreateInput = {
    skill_name: string
    job_requirements?: JobRequirementCreateNestedManyWithoutSkillInput
    parsed_resume_skills?: ParsedResumeSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    skill_id?: number
    skill_name: string
    job_requirements?: JobRequirementUncheckedCreateNestedManyWithoutSkillInput
    parsed_resume_skills?: ParsedResumeSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    job_requirements?: JobRequirementUpdateManyWithoutSkillNestedInput
    parsed_resume_skills?: ParsedResumeSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    job_requirements?: JobRequirementUncheckedUpdateManyWithoutSkillNestedInput
    parsed_resume_skills?: ParsedResumeSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    skill_id?: number
    skill_name: string
  }

  export type SkillUpdateManyMutationInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillUncheckedUpdateManyInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
  }

  export type JobRequirementCreateInput = {
    required_level?: string | null
    job: JobPostingCreateNestedOneWithoutRequirementsInput
    skill: SkillCreateNestedOneWithoutJob_requirementsInput
  }

  export type JobRequirementUncheckedCreateInput = {
    req_id?: number
    job_id: number
    skill_id: number
    required_level?: string | null
  }

  export type JobRequirementUpdateInput = {
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
    job?: JobPostingUpdateOneRequiredWithoutRequirementsNestedInput
    skill?: SkillUpdateOneRequiredWithoutJob_requirementsNestedInput
  }

  export type JobRequirementUncheckedUpdateInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementCreateManyInput = {
    req_id?: number
    job_id: number
    skill_id: number
    required_level?: string | null
  }

  export type JobRequirementUpdateManyMutationInput = {
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateManyInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateProfileCreateInput = {
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewCreateNestedManyWithoutCandidateInput
    user: UserCreateNestedOneWithoutCandidateProfileInput
    resumes?: ResumeCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileUncheckedCreateInput = {
    candidate_id: number
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutCandidateInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileUpdateInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUpdateManyWithoutCandidateNestedInput
    user?: UserUpdateOneRequiredWithoutCandidateProfileNestedInput
    resumes?: ResumeUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateProfileUncheckedUpdateInput = {
    candidate_id?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutCandidateNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateProfileCreateManyInput = {
    candidate_id: number
    education?: string | null
    experience?: string | null
  }

  export type CandidateProfileUpdateManyMutationInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CandidateProfileUncheckedUpdateManyInput = {
    candidate_id?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResumeCreateInput = {
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillCreateNestedManyWithoutResumeInput
    candidate: CandidateProfileCreateNestedOneWithoutResumesInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateInput = {
    resume_id?: number
    candidate_id: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedCreateNestedManyWithoutResumeInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeUpdateInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUpdateManyWithoutResumeNestedInput
    candidate?: CandidateProfileUpdateOneRequiredWithoutResumesNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedUpdateManyWithoutResumeNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateManyInput = {
    resume_id?: number
    candidate_id: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
  }

  export type ResumeUpdateManyMutationInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResumeUncheckedUpdateManyInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParsedResumeSkillCreateInput = {
    resume: ResumeCreateNestedOneWithoutParsed_resume_skillsInput
    skill: SkillCreateNestedOneWithoutParsed_resume_skillsInput
  }

  export type ParsedResumeSkillUncheckedCreateInput = {
    resume_id: number
    skill_id: number
  }

  export type ParsedResumeSkillUpdateInput = {
    resume?: ResumeUpdateOneRequiredWithoutParsed_resume_skillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutParsed_resume_skillsNestedInput
  }

  export type ParsedResumeSkillUncheckedUpdateInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
  }

  export type ParsedResumeSkillCreateManyInput = {
    resume_id: number
    skill_id: number
  }

  export type ParsedResumeSkillUpdateManyMutationInput = {

  }

  export type ParsedResumeSkillUncheckedUpdateManyInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
  }

  export type ResumeVsJdMatchCreateInput = {
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    job: JobPostingCreateNestedOneWithoutMatchesInput
    resume: ResumeCreateNestedOneWithoutMatchesInput
  }

  export type ResumeVsJdMatchUncheckedCreateInput = {
    match_id?: number
    resume_id: number
    job_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchUpdateInput = {
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    job?: JobPostingUpdateOneRequiredWithoutMatchesNestedInput
    resume?: ResumeUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type ResumeVsJdMatchUncheckedUpdateInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchCreateManyInput = {
    match_id?: number
    resume_id: number
    job_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchUpdateManyMutationInput = {
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchUncheckedUpdateManyInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewCreateInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUpdateInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewCreateManyInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type AiInterviewUpdateManyMutationInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewUncheckedUpdateManyInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewQuestionCreateInput = {
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
    interview: AiInterviewCreateNestedOneWithoutQuestionsInput
    responses?: AiInterviewResponseCreateNestedManyWithoutQuestionInput
  }

  export type AiInterviewQuestionUncheckedCreateInput = {
    question_id?: number
    interview_id: number
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type AiInterviewQuestionUpdateInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutQuestionsNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutQuestionNestedInput
  }

  export type AiInterviewQuestionUncheckedUpdateInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AiInterviewQuestionCreateManyInput = {
    question_id?: number
    interview_id: number
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
  }

  export type AiInterviewQuestionUpdateManyMutationInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewQuestionUncheckedUpdateManyInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseCreateInput = {
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
    interview: AiInterviewCreateNestedOneWithoutResponsesInput
    question: AiInterviewQuestionCreateNestedOneWithoutResponsesInput
  }

  export type AiInterviewResponseUncheckedCreateInput = {
    response_id?: number
    interview_id: number
    question_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiInterviewResponseUpdateInput = {
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutResponsesNestedInput
    question?: AiInterviewQuestionUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type AiInterviewResponseUncheckedUpdateInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseCreateManyInput = {
    response_id?: number
    interview_id: number
    question_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiInterviewResponseUpdateManyMutationInput = {
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseUncheckedUpdateManyInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCheatingEventCreateInput = {
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
    interview: AiInterviewCreateNestedOneWithoutCheating_eventsInput
  }

  export type AiInterviewCheatingEventUncheckedCreateInput = {
    event_id?: number
    interview_id: number
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
  }

  export type AiInterviewCheatingEventUpdateInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutCheating_eventsNestedInput
  }

  export type AiInterviewCheatingEventUncheckedUpdateInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCheatingEventCreateManyInput = {
    event_id?: number
    interview_id: number
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
  }

  export type AiInterviewCheatingEventUpdateManyMutationInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCheatingEventUncheckedUpdateManyInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewPostureDataCreateInput = {
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
    interview: AiInterviewCreateNestedOneWithoutPosture_dataInput
  }

  export type AiInterviewPostureDataUncheckedCreateInput = {
    posture_id?: number
    interview_id: number
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUpdateInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
    interview?: AiInterviewUpdateOneRequiredWithoutPosture_dataNestedInput
  }

  export type AiInterviewPostureDataUncheckedUpdateInput = {
    posture_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataCreateManyInput = {
    posture_id?: number
    interview_id: number
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUpdateManyMutationInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUncheckedUpdateManyInput = {
    posture_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiVoicePromptCreateInput = {
    prompt_text?: string | null
    prompt_audio_path?: string | null
    interview: AiInterviewCreateNestedOneWithoutVoice_promptsInput
  }

  export type AiVoicePromptUncheckedCreateInput = {
    prompt_id?: number
    interview_id: number
    prompt_text?: string | null
    prompt_audio_path?: string | null
  }

  export type AiVoicePromptUpdateInput = {
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutVoice_promptsNestedInput
  }

  export type AiVoicePromptUncheckedUpdateInput = {
    prompt_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiVoicePromptCreateManyInput = {
    prompt_id?: number
    interview_id: number
    prompt_text?: string | null
    prompt_audio_path?: string | null
  }

  export type AiVoicePromptUpdateManyMutationInput = {
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiVoicePromptUncheckedUpdateManyInput = {
    prompt_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiInterviewAnalysisCreateInput = {
    technical_score?: number | null
    communication_score?: number | null
    confidence_score?: number | null
    overall_score?: number | null
    strengths?: string | null
    weaknesses?: string | null
    improvement_suggestions?: string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
    interview: AiInterviewCreateNestedOneWithoutAnalysisInput
  }

  export type AiInterviewAnalysisUncheckedCreateInput = {
    analysis_id?: number
    interview_id: number
    technical_score?: number | null
    communication_score?: number | null
    confidence_score?: number | null
    overall_score?: number | null
    strengths?: string | null
    weaknesses?: string | null
    improvement_suggestions?: string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisUpdateInput = {
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
    interview?: AiInterviewUpdateOneRequiredWithoutAnalysisNestedInput
  }

  export type AiInterviewAnalysisUncheckedUpdateInput = {
    analysis_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisCreateManyInput = {
    analysis_id?: number
    interview_id: number
    technical_score?: number | null
    communication_score?: number | null
    confidence_score?: number | null
    overall_score?: number | null
    strengths?: string | null
    weaknesses?: string | null
    improvement_suggestions?: string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisUpdateManyMutationInput = {
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisUncheckedUpdateManyInput = {
    analysis_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGenerationLogCreateInput = {
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    user: UserCreateNestedOneWithoutAi_generation_logsInput
  }

  export type AiGenerationLogUncheckedCreateInput = {
    log_id?: number
    user_id: number
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type AiGenerationLogUpdateInput = {
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAi_generation_logsNestedInput
  }

  export type AiGenerationLogUncheckedUpdateInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiGenerationLogCreateManyInput = {
    log_id?: number
    user_id: number
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type AiGenerationLogUpdateManyMutationInput = {
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiGenerationLogUncheckedUpdateManyInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AiGenerationLogListRelationFilter = {
    every?: AiGenerationLogWhereInput
    some?: AiGenerationLogWhereInput
    none?: AiGenerationLogWhereInput
  }

  export type CandidateProfileNullableScalarRelationFilter = {
    is?: CandidateProfileWhereInput | null
    isNot?: CandidateProfileWhereInput | null
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AiGenerationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type JobPostingListRelationFilter = {
    every?: JobPostingWhereInput
    some?: JobPostingWhereInput
    none?: JobPostingWhereInput
  }

  export type JobPostingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    company_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    company_id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    company_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    company_id?: SortOrder
    name?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    company_id?: SortOrder
  }

  export type AiInterviewListRelationFilter = {
    every?: AiInterviewWhereInput
    some?: AiInterviewWhereInput
    none?: AiInterviewWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type JobRequirementListRelationFilter = {
    every?: JobRequirementWhereInput
    some?: JobRequirementWhereInput
    none?: JobRequirementWhereInput
  }

  export type ResumeVsJdMatchListRelationFilter = {
    every?: ResumeVsJdMatchWhereInput
    some?: ResumeVsJdMatchWhereInput
    none?: ResumeVsJdMatchWhereInput
  }

  export type AiInterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeVsJdMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostingCountOrderByAggregateInput = {
    job_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    posted_at?: SortOrder
  }

  export type JobPostingAvgOrderByAggregateInput = {
    job_id?: SortOrder
    company_id?: SortOrder
  }

  export type JobPostingMaxOrderByAggregateInput = {
    job_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    posted_at?: SortOrder
  }

  export type JobPostingMinOrderByAggregateInput = {
    job_id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    posted_at?: SortOrder
  }

  export type JobPostingSumOrderByAggregateInput = {
    job_id?: SortOrder
    company_id?: SortOrder
  }

  export type ParsedResumeSkillListRelationFilter = {
    every?: ParsedResumeSkillWhereInput
    some?: ParsedResumeSkillWhereInput
    none?: ParsedResumeSkillWhereInput
  }

  export type ParsedResumeSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_name?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    skill_id?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_name?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_name?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    skill_id?: SortOrder
  }

  export type JobPostingScalarRelationFilter = {
    is?: JobPostingWhereInput
    isNot?: JobPostingWhereInput
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type JobRequirementCountOrderByAggregateInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    required_level?: SortOrder
  }

  export type JobRequirementAvgOrderByAggregateInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
  }

  export type JobRequirementMaxOrderByAggregateInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    required_level?: SortOrder
  }

  export type JobRequirementMinOrderByAggregateInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    required_level?: SortOrder
  }

  export type JobRequirementSumOrderByAggregateInput = {
    req_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
  }

  export type ResumeListRelationFilter = {
    every?: ResumeWhereInput
    some?: ResumeWhereInput
    none?: ResumeWhereInput
  }

  export type ResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidateProfileCountOrderByAggregateInput = {
    candidate_id?: SortOrder
    education?: SortOrder
    experience?: SortOrder
  }

  export type CandidateProfileAvgOrderByAggregateInput = {
    candidate_id?: SortOrder
  }

  export type CandidateProfileMaxOrderByAggregateInput = {
    candidate_id?: SortOrder
    education?: SortOrder
    experience?: SortOrder
  }

  export type CandidateProfileMinOrderByAggregateInput = {
    candidate_id?: SortOrder
    education?: SortOrder
    experience?: SortOrder
  }

  export type CandidateProfileSumOrderByAggregateInput = {
    candidate_id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CandidateProfileScalarRelationFilter = {
    is?: CandidateProfileWhereInput
    isNot?: CandidateProfileWhereInput
  }

  export type ResumeCountOrderByAggregateInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
    file_path?: SortOrder
    parsed_text?: SortOrder
    parsed_json?: SortOrder
    uploaded_at?: SortOrder
  }

  export type ResumeAvgOrderByAggregateInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
  }

  export type ResumeMaxOrderByAggregateInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
    file_path?: SortOrder
    parsed_text?: SortOrder
    uploaded_at?: SortOrder
  }

  export type ResumeMinOrderByAggregateInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
    file_path?: SortOrder
    parsed_text?: SortOrder
    uploaded_at?: SortOrder
  }

  export type ResumeSumOrderByAggregateInput = {
    resume_id?: SortOrder
    candidate_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ResumeScalarRelationFilter = {
    is?: ResumeWhereInput
    isNot?: ResumeWhereInput
  }

  export type ParsedResumeSkillResume_idSkill_idCompoundUniqueInput = {
    resume_id: number
    skill_id: number
  }

  export type ParsedResumeSkillCountOrderByAggregateInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
  }

  export type ParsedResumeSkillAvgOrderByAggregateInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
  }

  export type ParsedResumeSkillMaxOrderByAggregateInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
  }

  export type ParsedResumeSkillMinOrderByAggregateInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
  }

  export type ParsedResumeSkillSumOrderByAggregateInput = {
    resume_id?: SortOrder
    skill_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ResumeVsJdMatchCountOrderByAggregateInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrder
    matched_skills?: SortOrder
    missing_skills?: SortOrder
  }

  export type ResumeVsJdMatchAvgOrderByAggregateInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrder
  }

  export type ResumeVsJdMatchMaxOrderByAggregateInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrder
  }

  export type ResumeVsJdMatchMinOrderByAggregateInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrder
  }

  export type ResumeVsJdMatchSumOrderByAggregateInput = {
    match_id?: SortOrder
    resume_id?: SortOrder
    job_id?: SortOrder
    match_score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AiInterviewAnalysisNullableScalarRelationFilter = {
    is?: AiInterviewAnalysisWhereInput | null
    isNot?: AiInterviewAnalysisWhereInput | null
  }

  export type AiInterviewCheatingEventListRelationFilter = {
    every?: AiInterviewCheatingEventWhereInput
    some?: AiInterviewCheatingEventWhereInput
    none?: AiInterviewCheatingEventWhereInput
  }

  export type AiInterviewPostureDataListRelationFilter = {
    every?: AiInterviewPostureDataWhereInput
    some?: AiInterviewPostureDataWhereInput
    none?: AiInterviewPostureDataWhereInput
  }

  export type AiInterviewQuestionListRelationFilter = {
    every?: AiInterviewQuestionWhereInput
    some?: AiInterviewQuestionWhereInput
    none?: AiInterviewQuestionWhereInput
  }

  export type AiInterviewResponseListRelationFilter = {
    every?: AiInterviewResponseWhereInput
    some?: AiInterviewResponseWhereInput
    none?: AiInterviewResponseWhereInput
  }

  export type AiVoicePromptListRelationFilter = {
    every?: AiVoicePromptWhereInput
    some?: AiVoicePromptWhereInput
    none?: AiVoicePromptWhereInput
  }

  export type AiInterviewCheatingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiInterviewPostureDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiInterviewQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiInterviewResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiVoicePromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiInterviewCountOrderByAggregateInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type AiInterviewAvgOrderByAggregateInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
  }

  export type AiInterviewMaxOrderByAggregateInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type AiInterviewMinOrderByAggregateInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type AiInterviewSumOrderByAggregateInput = {
    interview_id?: SortOrder
    job_id?: SortOrder
    candidate_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AiInterviewScalarRelationFilter = {
    is?: AiInterviewWhereInput
    isNot?: AiInterviewWhereInput
  }

  export type AiInterviewQuestionCountOrderByAggregateInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    ai_generated?: SortOrder
    asked_at?: SortOrder
  }

  export type AiInterviewQuestionAvgOrderByAggregateInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
  }

  export type AiInterviewQuestionMaxOrderByAggregateInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    ai_generated?: SortOrder
    asked_at?: SortOrder
  }

  export type AiInterviewQuestionMinOrderByAggregateInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    ai_generated?: SortOrder
    asked_at?: SortOrder
  }

  export type AiInterviewQuestionSumOrderByAggregateInput = {
    question_id?: SortOrder
    interview_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AiInterviewQuestionScalarRelationFilter = {
    is?: AiInterviewQuestionWhereInput
    isNot?: AiInterviewQuestionWhereInput
  }

  export type AiInterviewResponseCountOrderByAggregateInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
    response_text?: SortOrder
    response_audio_path?: SortOrder
    response_video_path?: SortOrder
    transcript?: SortOrder
    captured_at?: SortOrder
  }

  export type AiInterviewResponseAvgOrderByAggregateInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
  }

  export type AiInterviewResponseMaxOrderByAggregateInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
    response_text?: SortOrder
    response_audio_path?: SortOrder
    response_video_path?: SortOrder
    transcript?: SortOrder
    captured_at?: SortOrder
  }

  export type AiInterviewResponseMinOrderByAggregateInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
    response_text?: SortOrder
    response_audio_path?: SortOrder
    response_video_path?: SortOrder
    transcript?: SortOrder
    captured_at?: SortOrder
  }

  export type AiInterviewResponseSumOrderByAggregateInput = {
    response_id?: SortOrder
    interview_id?: SortOrder
    question_id?: SortOrder
  }

  export type AiInterviewCheatingEventCountOrderByAggregateInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    event_type?: SortOrder
    confidence_score?: SortOrder
    detected_at?: SortOrder
  }

  export type AiInterviewCheatingEventAvgOrderByAggregateInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    confidence_score?: SortOrder
  }

  export type AiInterviewCheatingEventMaxOrderByAggregateInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    event_type?: SortOrder
    confidence_score?: SortOrder
    detected_at?: SortOrder
  }

  export type AiInterviewCheatingEventMinOrderByAggregateInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    event_type?: SortOrder
    confidence_score?: SortOrder
    detected_at?: SortOrder
  }

  export type AiInterviewCheatingEventSumOrderByAggregateInput = {
    event_id?: SortOrder
    interview_id?: SortOrder
    confidence_score?: SortOrder
  }

  export type AiInterviewPostureDataCountOrderByAggregateInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
    timestamp?: SortOrder
    posture_data?: SortOrder
  }

  export type AiInterviewPostureDataAvgOrderByAggregateInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
  }

  export type AiInterviewPostureDataMaxOrderByAggregateInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
    timestamp?: SortOrder
  }

  export type AiInterviewPostureDataMinOrderByAggregateInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
    timestamp?: SortOrder
  }

  export type AiInterviewPostureDataSumOrderByAggregateInput = {
    posture_id?: SortOrder
    interview_id?: SortOrder
  }

  export type AiVoicePromptCountOrderByAggregateInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
    prompt_text?: SortOrder
    prompt_audio_path?: SortOrder
  }

  export type AiVoicePromptAvgOrderByAggregateInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
  }

  export type AiVoicePromptMaxOrderByAggregateInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
    prompt_text?: SortOrder
    prompt_audio_path?: SortOrder
  }

  export type AiVoicePromptMinOrderByAggregateInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
    prompt_text?: SortOrder
    prompt_audio_path?: SortOrder
  }

  export type AiVoicePromptSumOrderByAggregateInput = {
    prompt_id?: SortOrder
    interview_id?: SortOrder
  }

  export type AiInterviewAnalysisCountOrderByAggregateInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrder
    communication_score?: SortOrder
    confidence_score?: SortOrder
    overall_score?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvement_suggestions?: SortOrder
    analysis_json?: SortOrder
  }

  export type AiInterviewAnalysisAvgOrderByAggregateInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrder
    communication_score?: SortOrder
    confidence_score?: SortOrder
    overall_score?: SortOrder
  }

  export type AiInterviewAnalysisMaxOrderByAggregateInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrder
    communication_score?: SortOrder
    confidence_score?: SortOrder
    overall_score?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvement_suggestions?: SortOrder
  }

  export type AiInterviewAnalysisMinOrderByAggregateInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrder
    communication_score?: SortOrder
    confidence_score?: SortOrder
    overall_score?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvement_suggestions?: SortOrder
  }

  export type AiInterviewAnalysisSumOrderByAggregateInput = {
    analysis_id?: SortOrder
    interview_id?: SortOrder
    technical_score?: SortOrder
    communication_score?: SortOrder
    confidence_score?: SortOrder
    overall_score?: SortOrder
  }

  export type AiGenerationLogCountOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    service_used?: SortOrder
    request_payload?: SortOrder
    response_payload?: SortOrder
    created_at?: SortOrder
  }

  export type AiGenerationLogAvgOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
  }

  export type AiGenerationLogMaxOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    service_used?: SortOrder
    created_at?: SortOrder
  }

  export type AiGenerationLogMinOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    service_used?: SortOrder
    created_at?: SortOrder
  }

  export type AiGenerationLogSumOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
  }

  export type AiGenerationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput> | AiGenerationLogCreateWithoutUserInput[] | AiGenerationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiGenerationLogCreateOrConnectWithoutUserInput | AiGenerationLogCreateOrConnectWithoutUserInput[]
    createMany?: AiGenerationLogCreateManyUserInputEnvelope
    connect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
  }

  export type CandidateProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutUserInput
    connect?: CandidateProfileWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AiGenerationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput> | AiGenerationLogCreateWithoutUserInput[] | AiGenerationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiGenerationLogCreateOrConnectWithoutUserInput | AiGenerationLogCreateOrConnectWithoutUserInput[]
    createMany?: AiGenerationLogCreateManyUserInputEnvelope
    connect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
  }

  export type CandidateProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutUserInput
    connect?: CandidateProfileWhereUniqueInput
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AiGenerationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput> | AiGenerationLogCreateWithoutUserInput[] | AiGenerationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiGenerationLogCreateOrConnectWithoutUserInput | AiGenerationLogCreateOrConnectWithoutUserInput[]
    upsert?: AiGenerationLogUpsertWithWhereUniqueWithoutUserInput | AiGenerationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiGenerationLogCreateManyUserInputEnvelope
    set?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    disconnect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    delete?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    connect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    update?: AiGenerationLogUpdateWithWhereUniqueWithoutUserInput | AiGenerationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiGenerationLogUpdateManyWithWhereWithoutUserInput | AiGenerationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiGenerationLogScalarWhereInput | AiGenerationLogScalarWhereInput[]
  }

  export type CandidateProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutUserInput
    upsert?: CandidateProfileUpsertWithoutUserInput
    disconnect?: CandidateProfileWhereInput | boolean
    delete?: CandidateProfileWhereInput | boolean
    connect?: CandidateProfileWhereUniqueInput
    update?: XOR<XOR<CandidateProfileUpdateToOneWithWhereWithoutUserInput, CandidateProfileUpdateWithoutUserInput>, CandidateProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AiGenerationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput> | AiGenerationLogCreateWithoutUserInput[] | AiGenerationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiGenerationLogCreateOrConnectWithoutUserInput | AiGenerationLogCreateOrConnectWithoutUserInput[]
    upsert?: AiGenerationLogUpsertWithWhereUniqueWithoutUserInput | AiGenerationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiGenerationLogCreateManyUserInputEnvelope
    set?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    disconnect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    delete?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    connect?: AiGenerationLogWhereUniqueInput | AiGenerationLogWhereUniqueInput[]
    update?: AiGenerationLogUpdateWithWhereUniqueWithoutUserInput | AiGenerationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiGenerationLogUpdateManyWithWhereWithoutUserInput | AiGenerationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiGenerationLogScalarWhereInput | AiGenerationLogScalarWhereInput[]
  }

  export type CandidateProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutUserInput
    upsert?: CandidateProfileUpsertWithoutUserInput
    disconnect?: CandidateProfileWhereInput | boolean
    delete?: CandidateProfileWhereInput | boolean
    connect?: CandidateProfileWhereUniqueInput
    update?: XOR<XOR<CandidateProfileUpdateToOneWithWhereWithoutUserInput, CandidateProfileUpdateWithoutUserInput>, CandidateProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type JobPostingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
  }

  export type JobPostingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
  }

  export type JobPostingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    upsert?: JobPostingUpsertWithWhereUniqueWithoutCompanyInput | JobPostingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    set?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    disconnect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    delete?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    update?: JobPostingUpdateWithWhereUniqueWithoutCompanyInput | JobPostingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobPostingUpdateManyWithWhereWithoutCompanyInput | JobPostingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
  }

  export type JobPostingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput> | JobPostingCreateWithoutCompanyInput[] | JobPostingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: JobPostingCreateOrConnectWithoutCompanyInput | JobPostingCreateOrConnectWithoutCompanyInput[]
    upsert?: JobPostingUpsertWithWhereUniqueWithoutCompanyInput | JobPostingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: JobPostingCreateManyCompanyInputEnvelope
    set?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    disconnect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    delete?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    connect?: JobPostingWhereUniqueInput | JobPostingWhereUniqueInput[]
    update?: JobPostingUpdateWithWhereUniqueWithoutCompanyInput | JobPostingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: JobPostingUpdateManyWithWhereWithoutCompanyInput | JobPostingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
  }

  export type AiInterviewCreateNestedManyWithoutJobInput = {
    create?: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput> | AiInterviewCreateWithoutJobInput[] | AiInterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutJobInput | AiInterviewCreateOrConnectWithoutJobInput[]
    createMany?: AiInterviewCreateManyJobInputEnvelope
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutJob_postingsInput = {
    create?: XOR<CompanyCreateWithoutJob_postingsInput, CompanyUncheckedCreateWithoutJob_postingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJob_postingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type JobRequirementCreateNestedManyWithoutJobInput = {
    create?: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput> | JobRequirementCreateWithoutJobInput[] | JobRequirementUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutJobInput | JobRequirementCreateOrConnectWithoutJobInput[]
    createMany?: JobRequirementCreateManyJobInputEnvelope
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
  }

  export type ResumeVsJdMatchCreateNestedManyWithoutJobInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput> | ResumeVsJdMatchCreateWithoutJobInput[] | ResumeVsJdMatchUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutJobInput | ResumeVsJdMatchCreateOrConnectWithoutJobInput[]
    createMany?: ResumeVsJdMatchCreateManyJobInputEnvelope
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
  }

  export type AiInterviewUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput> | AiInterviewCreateWithoutJobInput[] | AiInterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutJobInput | AiInterviewCreateOrConnectWithoutJobInput[]
    createMany?: AiInterviewCreateManyJobInputEnvelope
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
  }

  export type JobRequirementUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput> | JobRequirementCreateWithoutJobInput[] | JobRequirementUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutJobInput | JobRequirementCreateOrConnectWithoutJobInput[]
    createMany?: JobRequirementCreateManyJobInputEnvelope
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
  }

  export type ResumeVsJdMatchUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput> | ResumeVsJdMatchCreateWithoutJobInput[] | ResumeVsJdMatchUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutJobInput | ResumeVsJdMatchCreateOrConnectWithoutJobInput[]
    createMany?: ResumeVsJdMatchCreateManyJobInputEnvelope
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
  }

  export type AiInterviewUpdateManyWithoutJobNestedInput = {
    create?: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput> | AiInterviewCreateWithoutJobInput[] | AiInterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutJobInput | AiInterviewCreateOrConnectWithoutJobInput[]
    upsert?: AiInterviewUpsertWithWhereUniqueWithoutJobInput | AiInterviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AiInterviewCreateManyJobInputEnvelope
    set?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    disconnect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    delete?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    update?: AiInterviewUpdateWithWhereUniqueWithoutJobInput | AiInterviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AiInterviewUpdateManyWithWhereWithoutJobInput | AiInterviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutJob_postingsNestedInput = {
    create?: XOR<CompanyCreateWithoutJob_postingsInput, CompanyUncheckedCreateWithoutJob_postingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJob_postingsInput
    upsert?: CompanyUpsertWithoutJob_postingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutJob_postingsInput, CompanyUpdateWithoutJob_postingsInput>, CompanyUncheckedUpdateWithoutJob_postingsInput>
  }

  export type JobRequirementUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput> | JobRequirementCreateWithoutJobInput[] | JobRequirementUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutJobInput | JobRequirementCreateOrConnectWithoutJobInput[]
    upsert?: JobRequirementUpsertWithWhereUniqueWithoutJobInput | JobRequirementUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobRequirementCreateManyJobInputEnvelope
    set?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    disconnect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    delete?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    update?: JobRequirementUpdateWithWhereUniqueWithoutJobInput | JobRequirementUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobRequirementUpdateManyWithWhereWithoutJobInput | JobRequirementUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
  }

  export type ResumeVsJdMatchUpdateManyWithoutJobNestedInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput> | ResumeVsJdMatchCreateWithoutJobInput[] | ResumeVsJdMatchUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutJobInput | ResumeVsJdMatchCreateOrConnectWithoutJobInput[]
    upsert?: ResumeVsJdMatchUpsertWithWhereUniqueWithoutJobInput | ResumeVsJdMatchUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ResumeVsJdMatchCreateManyJobInputEnvelope
    set?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    disconnect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    delete?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    update?: ResumeVsJdMatchUpdateWithWhereUniqueWithoutJobInput | ResumeVsJdMatchUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ResumeVsJdMatchUpdateManyWithWhereWithoutJobInput | ResumeVsJdMatchUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
  }

  export type AiInterviewUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput> | AiInterviewCreateWithoutJobInput[] | AiInterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutJobInput | AiInterviewCreateOrConnectWithoutJobInput[]
    upsert?: AiInterviewUpsertWithWhereUniqueWithoutJobInput | AiInterviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: AiInterviewCreateManyJobInputEnvelope
    set?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    disconnect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    delete?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    update?: AiInterviewUpdateWithWhereUniqueWithoutJobInput | AiInterviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: AiInterviewUpdateManyWithWhereWithoutJobInput | AiInterviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
  }

  export type JobRequirementUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput> | JobRequirementCreateWithoutJobInput[] | JobRequirementUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutJobInput | JobRequirementCreateOrConnectWithoutJobInput[]
    upsert?: JobRequirementUpsertWithWhereUniqueWithoutJobInput | JobRequirementUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobRequirementCreateManyJobInputEnvelope
    set?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    disconnect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    delete?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    update?: JobRequirementUpdateWithWhereUniqueWithoutJobInput | JobRequirementUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobRequirementUpdateManyWithWhereWithoutJobInput | JobRequirementUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
  }

  export type ResumeVsJdMatchUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput> | ResumeVsJdMatchCreateWithoutJobInput[] | ResumeVsJdMatchUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutJobInput | ResumeVsJdMatchCreateOrConnectWithoutJobInput[]
    upsert?: ResumeVsJdMatchUpsertWithWhereUniqueWithoutJobInput | ResumeVsJdMatchUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ResumeVsJdMatchCreateManyJobInputEnvelope
    set?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    disconnect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    delete?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    update?: ResumeVsJdMatchUpdateWithWhereUniqueWithoutJobInput | ResumeVsJdMatchUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ResumeVsJdMatchUpdateManyWithWhereWithoutJobInput | ResumeVsJdMatchUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
  }

  export type JobRequirementCreateNestedManyWithoutSkillInput = {
    create?: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput> | JobRequirementCreateWithoutSkillInput[] | JobRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutSkillInput | JobRequirementCreateOrConnectWithoutSkillInput[]
    createMany?: JobRequirementCreateManySkillInputEnvelope
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
  }

  export type ParsedResumeSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput> | ParsedResumeSkillCreateWithoutSkillInput[] | ParsedResumeSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutSkillInput | ParsedResumeSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ParsedResumeSkillCreateManySkillInputEnvelope
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
  }

  export type JobRequirementUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput> | JobRequirementCreateWithoutSkillInput[] | JobRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutSkillInput | JobRequirementCreateOrConnectWithoutSkillInput[]
    createMany?: JobRequirementCreateManySkillInputEnvelope
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
  }

  export type ParsedResumeSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput> | ParsedResumeSkillCreateWithoutSkillInput[] | ParsedResumeSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutSkillInput | ParsedResumeSkillCreateOrConnectWithoutSkillInput[]
    createMany?: ParsedResumeSkillCreateManySkillInputEnvelope
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
  }

  export type JobRequirementUpdateManyWithoutSkillNestedInput = {
    create?: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput> | JobRequirementCreateWithoutSkillInput[] | JobRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutSkillInput | JobRequirementCreateOrConnectWithoutSkillInput[]
    upsert?: JobRequirementUpsertWithWhereUniqueWithoutSkillInput | JobRequirementUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: JobRequirementCreateManySkillInputEnvelope
    set?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    disconnect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    delete?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    update?: JobRequirementUpdateWithWhereUniqueWithoutSkillInput | JobRequirementUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: JobRequirementUpdateManyWithWhereWithoutSkillInput | JobRequirementUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
  }

  export type ParsedResumeSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput> | ParsedResumeSkillCreateWithoutSkillInput[] | ParsedResumeSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutSkillInput | ParsedResumeSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ParsedResumeSkillUpsertWithWhereUniqueWithoutSkillInput | ParsedResumeSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ParsedResumeSkillCreateManySkillInputEnvelope
    set?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    disconnect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    delete?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    update?: ParsedResumeSkillUpdateWithWhereUniqueWithoutSkillInput | ParsedResumeSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ParsedResumeSkillUpdateManyWithWhereWithoutSkillInput | ParsedResumeSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
  }

  export type JobRequirementUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput> | JobRequirementCreateWithoutSkillInput[] | JobRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: JobRequirementCreateOrConnectWithoutSkillInput | JobRequirementCreateOrConnectWithoutSkillInput[]
    upsert?: JobRequirementUpsertWithWhereUniqueWithoutSkillInput | JobRequirementUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: JobRequirementCreateManySkillInputEnvelope
    set?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    disconnect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    delete?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    connect?: JobRequirementWhereUniqueInput | JobRequirementWhereUniqueInput[]
    update?: JobRequirementUpdateWithWhereUniqueWithoutSkillInput | JobRequirementUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: JobRequirementUpdateManyWithWhereWithoutSkillInput | JobRequirementUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
  }

  export type ParsedResumeSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput> | ParsedResumeSkillCreateWithoutSkillInput[] | ParsedResumeSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutSkillInput | ParsedResumeSkillCreateOrConnectWithoutSkillInput[]
    upsert?: ParsedResumeSkillUpsertWithWhereUniqueWithoutSkillInput | ParsedResumeSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: ParsedResumeSkillCreateManySkillInputEnvelope
    set?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    disconnect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    delete?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    update?: ParsedResumeSkillUpdateWithWhereUniqueWithoutSkillInput | ParsedResumeSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: ParsedResumeSkillUpdateManyWithWhereWithoutSkillInput | ParsedResumeSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
  }

  export type JobPostingCreateNestedOneWithoutRequirementsInput = {
    create?: XOR<JobPostingCreateWithoutRequirementsInput, JobPostingUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutRequirementsInput
    connect?: JobPostingWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutJob_requirementsInput = {
    create?: XOR<SkillCreateWithoutJob_requirementsInput, SkillUncheckedCreateWithoutJob_requirementsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutJob_requirementsInput
    connect?: SkillWhereUniqueInput
  }

  export type JobPostingUpdateOneRequiredWithoutRequirementsNestedInput = {
    create?: XOR<JobPostingCreateWithoutRequirementsInput, JobPostingUncheckedCreateWithoutRequirementsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutRequirementsInput
    upsert?: JobPostingUpsertWithoutRequirementsInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutRequirementsInput, JobPostingUpdateWithoutRequirementsInput>, JobPostingUncheckedUpdateWithoutRequirementsInput>
  }

  export type SkillUpdateOneRequiredWithoutJob_requirementsNestedInput = {
    create?: XOR<SkillCreateWithoutJob_requirementsInput, SkillUncheckedCreateWithoutJob_requirementsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutJob_requirementsInput
    upsert?: SkillUpsertWithoutJob_requirementsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutJob_requirementsInput, SkillUpdateWithoutJob_requirementsInput>, SkillUncheckedUpdateWithoutJob_requirementsInput>
  }

  export type AiInterviewCreateNestedManyWithoutCandidateInput = {
    create?: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput> | AiInterviewCreateWithoutCandidateInput[] | AiInterviewUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCandidateInput | AiInterviewCreateOrConnectWithoutCandidateInput[]
    createMany?: AiInterviewCreateManyCandidateInputEnvelope
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCandidateProfileInput = {
    create?: XOR<UserCreateWithoutCandidateProfileInput, UserUncheckedCreateWithoutCandidateProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedManyWithoutCandidateInput = {
    create?: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput> | ResumeCreateWithoutCandidateInput[] | ResumeUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutCandidateInput | ResumeCreateOrConnectWithoutCandidateInput[]
    createMany?: ResumeCreateManyCandidateInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type AiInterviewUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput> | AiInterviewCreateWithoutCandidateInput[] | AiInterviewUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCandidateInput | AiInterviewCreateOrConnectWithoutCandidateInput[]
    createMany?: AiInterviewCreateManyCandidateInputEnvelope
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
  }

  export type ResumeUncheckedCreateNestedManyWithoutCandidateInput = {
    create?: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput> | ResumeCreateWithoutCandidateInput[] | ResumeUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutCandidateInput | ResumeCreateOrConnectWithoutCandidateInput[]
    createMany?: ResumeCreateManyCandidateInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type AiInterviewUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput> | AiInterviewCreateWithoutCandidateInput[] | AiInterviewUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCandidateInput | AiInterviewCreateOrConnectWithoutCandidateInput[]
    upsert?: AiInterviewUpsertWithWhereUniqueWithoutCandidateInput | AiInterviewUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: AiInterviewCreateManyCandidateInputEnvelope
    set?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    disconnect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    delete?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    update?: AiInterviewUpdateWithWhereUniqueWithoutCandidateInput | AiInterviewUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: AiInterviewUpdateManyWithWhereWithoutCandidateInput | AiInterviewUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCandidateProfileNestedInput = {
    create?: XOR<UserCreateWithoutCandidateProfileInput, UserUncheckedCreateWithoutCandidateProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCandidateProfileInput
    upsert?: UserUpsertWithoutCandidateProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCandidateProfileInput, UserUpdateWithoutCandidateProfileInput>, UserUncheckedUpdateWithoutCandidateProfileInput>
  }

  export type ResumeUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput> | ResumeCreateWithoutCandidateInput[] | ResumeUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutCandidateInput | ResumeCreateOrConnectWithoutCandidateInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutCandidateInput | ResumeUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: ResumeCreateManyCandidateInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutCandidateInput | ResumeUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutCandidateInput | ResumeUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type AiInterviewUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput> | AiInterviewCreateWithoutCandidateInput[] | AiInterviewUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCandidateInput | AiInterviewCreateOrConnectWithoutCandidateInput[]
    upsert?: AiInterviewUpsertWithWhereUniqueWithoutCandidateInput | AiInterviewUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: AiInterviewCreateManyCandidateInputEnvelope
    set?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    disconnect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    delete?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    connect?: AiInterviewWhereUniqueInput | AiInterviewWhereUniqueInput[]
    update?: AiInterviewUpdateWithWhereUniqueWithoutCandidateInput | AiInterviewUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: AiInterviewUpdateManyWithWhereWithoutCandidateInput | AiInterviewUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
  }

  export type ResumeUncheckedUpdateManyWithoutCandidateNestedInput = {
    create?: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput> | ResumeCreateWithoutCandidateInput[] | ResumeUncheckedCreateWithoutCandidateInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutCandidateInput | ResumeCreateOrConnectWithoutCandidateInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutCandidateInput | ResumeUpsertWithWhereUniqueWithoutCandidateInput[]
    createMany?: ResumeCreateManyCandidateInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutCandidateInput | ResumeUpdateWithWhereUniqueWithoutCandidateInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutCandidateInput | ResumeUpdateManyWithWhereWithoutCandidateInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type ParsedResumeSkillCreateNestedManyWithoutResumeInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput> | ParsedResumeSkillCreateWithoutResumeInput[] | ParsedResumeSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutResumeInput | ParsedResumeSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ParsedResumeSkillCreateManyResumeInputEnvelope
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
  }

  export type CandidateProfileCreateNestedOneWithoutResumesInput = {
    create?: XOR<CandidateProfileCreateWithoutResumesInput, CandidateProfileUncheckedCreateWithoutResumesInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutResumesInput
    connect?: CandidateProfileWhereUniqueInput
  }

  export type ResumeVsJdMatchCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput> | ResumeVsJdMatchCreateWithoutResumeInput[] | ResumeVsJdMatchUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutResumeInput | ResumeVsJdMatchCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeVsJdMatchCreateManyResumeInputEnvelope
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
  }

  export type ParsedResumeSkillUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput> | ParsedResumeSkillCreateWithoutResumeInput[] | ParsedResumeSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutResumeInput | ParsedResumeSkillCreateOrConnectWithoutResumeInput[]
    createMany?: ParsedResumeSkillCreateManyResumeInputEnvelope
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
  }

  export type ResumeVsJdMatchUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput> | ResumeVsJdMatchCreateWithoutResumeInput[] | ResumeVsJdMatchUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutResumeInput | ResumeVsJdMatchCreateOrConnectWithoutResumeInput[]
    createMany?: ResumeVsJdMatchCreateManyResumeInputEnvelope
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
  }

  export type ParsedResumeSkillUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput> | ParsedResumeSkillCreateWithoutResumeInput[] | ParsedResumeSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutResumeInput | ParsedResumeSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ParsedResumeSkillUpsertWithWhereUniqueWithoutResumeInput | ParsedResumeSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ParsedResumeSkillCreateManyResumeInputEnvelope
    set?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    disconnect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    delete?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    update?: ParsedResumeSkillUpdateWithWhereUniqueWithoutResumeInput | ParsedResumeSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ParsedResumeSkillUpdateManyWithWhereWithoutResumeInput | ParsedResumeSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
  }

  export type CandidateProfileUpdateOneRequiredWithoutResumesNestedInput = {
    create?: XOR<CandidateProfileCreateWithoutResumesInput, CandidateProfileUncheckedCreateWithoutResumesInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutResumesInput
    upsert?: CandidateProfileUpsertWithoutResumesInput
    connect?: CandidateProfileWhereUniqueInput
    update?: XOR<XOR<CandidateProfileUpdateToOneWithWhereWithoutResumesInput, CandidateProfileUpdateWithoutResumesInput>, CandidateProfileUncheckedUpdateWithoutResumesInput>
  }

  export type ResumeVsJdMatchUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput> | ResumeVsJdMatchCreateWithoutResumeInput[] | ResumeVsJdMatchUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutResumeInput | ResumeVsJdMatchCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeVsJdMatchUpsertWithWhereUniqueWithoutResumeInput | ResumeVsJdMatchUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeVsJdMatchCreateManyResumeInputEnvelope
    set?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    disconnect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    delete?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    update?: ResumeVsJdMatchUpdateWithWhereUniqueWithoutResumeInput | ResumeVsJdMatchUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeVsJdMatchUpdateManyWithWhereWithoutResumeInput | ResumeVsJdMatchUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
  }

  export type ParsedResumeSkillUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput> | ParsedResumeSkillCreateWithoutResumeInput[] | ParsedResumeSkillUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ParsedResumeSkillCreateOrConnectWithoutResumeInput | ParsedResumeSkillCreateOrConnectWithoutResumeInput[]
    upsert?: ParsedResumeSkillUpsertWithWhereUniqueWithoutResumeInput | ParsedResumeSkillUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ParsedResumeSkillCreateManyResumeInputEnvelope
    set?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    disconnect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    delete?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    connect?: ParsedResumeSkillWhereUniqueInput | ParsedResumeSkillWhereUniqueInput[]
    update?: ParsedResumeSkillUpdateWithWhereUniqueWithoutResumeInput | ParsedResumeSkillUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ParsedResumeSkillUpdateManyWithWhereWithoutResumeInput | ParsedResumeSkillUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
  }

  export type ResumeVsJdMatchUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput> | ResumeVsJdMatchCreateWithoutResumeInput[] | ResumeVsJdMatchUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ResumeVsJdMatchCreateOrConnectWithoutResumeInput | ResumeVsJdMatchCreateOrConnectWithoutResumeInput[]
    upsert?: ResumeVsJdMatchUpsertWithWhereUniqueWithoutResumeInput | ResumeVsJdMatchUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ResumeVsJdMatchCreateManyResumeInputEnvelope
    set?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    disconnect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    delete?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    connect?: ResumeVsJdMatchWhereUniqueInput | ResumeVsJdMatchWhereUniqueInput[]
    update?: ResumeVsJdMatchUpdateWithWhereUniqueWithoutResumeInput | ResumeVsJdMatchUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ResumeVsJdMatchUpdateManyWithWhereWithoutResumeInput | ResumeVsJdMatchUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutParsed_resume_skillsInput = {
    create?: XOR<ResumeCreateWithoutParsed_resume_skillsInput, ResumeUncheckedCreateWithoutParsed_resume_skillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutParsed_resume_skillsInput
    connect?: ResumeWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutParsed_resume_skillsInput = {
    create?: XOR<SkillCreateWithoutParsed_resume_skillsInput, SkillUncheckedCreateWithoutParsed_resume_skillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutParsed_resume_skillsInput
    connect?: SkillWhereUniqueInput
  }

  export type ResumeUpdateOneRequiredWithoutParsed_resume_skillsNestedInput = {
    create?: XOR<ResumeCreateWithoutParsed_resume_skillsInput, ResumeUncheckedCreateWithoutParsed_resume_skillsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutParsed_resume_skillsInput
    upsert?: ResumeUpsertWithoutParsed_resume_skillsInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutParsed_resume_skillsInput, ResumeUpdateWithoutParsed_resume_skillsInput>, ResumeUncheckedUpdateWithoutParsed_resume_skillsInput>
  }

  export type SkillUpdateOneRequiredWithoutParsed_resume_skillsNestedInput = {
    create?: XOR<SkillCreateWithoutParsed_resume_skillsInput, SkillUncheckedCreateWithoutParsed_resume_skillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutParsed_resume_skillsInput
    upsert?: SkillUpsertWithoutParsed_resume_skillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutParsed_resume_skillsInput, SkillUpdateWithoutParsed_resume_skillsInput>, SkillUncheckedUpdateWithoutParsed_resume_skillsInput>
  }

  export type JobPostingCreateNestedOneWithoutMatchesInput = {
    create?: XOR<JobPostingCreateWithoutMatchesInput, JobPostingUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutMatchesInput
    connect?: JobPostingWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutMatchesInput = {
    create?: XOR<ResumeCreateWithoutMatchesInput, ResumeUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutMatchesInput
    connect?: ResumeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobPostingUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<JobPostingCreateWithoutMatchesInput, JobPostingUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutMatchesInput
    upsert?: JobPostingUpsertWithoutMatchesInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutMatchesInput, JobPostingUpdateWithoutMatchesInput>, JobPostingUncheckedUpdateWithoutMatchesInput>
  }

  export type ResumeUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<ResumeCreateWithoutMatchesInput, ResumeUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutMatchesInput
    upsert?: ResumeUpsertWithoutMatchesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutMatchesInput, ResumeUpdateWithoutMatchesInput>, ResumeUncheckedUpdateWithoutMatchesInput>
  }

  export type CandidateProfileCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<CandidateProfileCreateWithoutInterviewsInput, CandidateProfileUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutInterviewsInput
    connect?: CandidateProfileWhereUniqueInput
  }

  export type JobPostingCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<JobPostingCreateWithoutInterviewsInput, JobPostingUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutInterviewsInput
    connect?: JobPostingWhereUniqueInput
  }

  export type AiInterviewAnalysisCreateNestedOneWithoutInterviewInput = {
    create?: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: AiInterviewAnalysisCreateOrConnectWithoutInterviewInput
    connect?: AiInterviewAnalysisWhereUniqueInput
  }

  export type AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput> | AiInterviewCheatingEventCreateWithoutInterviewInput[] | AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput | AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewCheatingEventCreateManyInterviewInputEnvelope
    connect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
  }

  export type AiInterviewPostureDataCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput> | AiInterviewPostureDataCreateWithoutInterviewInput[] | AiInterviewPostureDataUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewPostureDataCreateOrConnectWithoutInterviewInput | AiInterviewPostureDataCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewPostureDataCreateManyInterviewInputEnvelope
    connect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
  }

  export type AiInterviewQuestionCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput> | AiInterviewQuestionCreateWithoutInterviewInput[] | AiInterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutInterviewInput | AiInterviewQuestionCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewQuestionCreateManyInterviewInputEnvelope
    connect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
  }

  export type AiInterviewResponseCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput> | AiInterviewResponseCreateWithoutInterviewInput[] | AiInterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutInterviewInput | AiInterviewResponseCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewResponseCreateManyInterviewInputEnvelope
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
  }

  export type AiVoicePromptCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput> | AiVoicePromptCreateWithoutInterviewInput[] | AiVoicePromptUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiVoicePromptCreateOrConnectWithoutInterviewInput | AiVoicePromptCreateOrConnectWithoutInterviewInput[]
    createMany?: AiVoicePromptCreateManyInterviewInputEnvelope
    connect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
  }

  export type AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput = {
    create?: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: AiInterviewAnalysisCreateOrConnectWithoutInterviewInput
    connect?: AiInterviewAnalysisWhereUniqueInput
  }

  export type AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput> | AiInterviewCheatingEventCreateWithoutInterviewInput[] | AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput | AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewCheatingEventCreateManyInterviewInputEnvelope
    connect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
  }

  export type AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput> | AiInterviewPostureDataCreateWithoutInterviewInput[] | AiInterviewPostureDataUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewPostureDataCreateOrConnectWithoutInterviewInput | AiInterviewPostureDataCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewPostureDataCreateManyInterviewInputEnvelope
    connect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
  }

  export type AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput> | AiInterviewQuestionCreateWithoutInterviewInput[] | AiInterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutInterviewInput | AiInterviewQuestionCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewQuestionCreateManyInterviewInputEnvelope
    connect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
  }

  export type AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput> | AiInterviewResponseCreateWithoutInterviewInput[] | AiInterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutInterviewInput | AiInterviewResponseCreateOrConnectWithoutInterviewInput[]
    createMany?: AiInterviewResponseCreateManyInterviewInputEnvelope
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
  }

  export type AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput> | AiVoicePromptCreateWithoutInterviewInput[] | AiVoicePromptUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiVoicePromptCreateOrConnectWithoutInterviewInput | AiVoicePromptCreateOrConnectWithoutInterviewInput[]
    createMany?: AiVoicePromptCreateManyInterviewInputEnvelope
    connect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
  }

  export type CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<CandidateProfileCreateWithoutInterviewsInput, CandidateProfileUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: CandidateProfileCreateOrConnectWithoutInterviewsInput
    upsert?: CandidateProfileUpsertWithoutInterviewsInput
    connect?: CandidateProfileWhereUniqueInput
    update?: XOR<XOR<CandidateProfileUpdateToOneWithWhereWithoutInterviewsInput, CandidateProfileUpdateWithoutInterviewsInput>, CandidateProfileUncheckedUpdateWithoutInterviewsInput>
  }

  export type JobPostingUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<JobPostingCreateWithoutInterviewsInput, JobPostingUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: JobPostingCreateOrConnectWithoutInterviewsInput
    upsert?: JobPostingUpsertWithoutInterviewsInput
    connect?: JobPostingWhereUniqueInput
    update?: XOR<XOR<JobPostingUpdateToOneWithWhereWithoutInterviewsInput, JobPostingUpdateWithoutInterviewsInput>, JobPostingUncheckedUpdateWithoutInterviewsInput>
  }

  export type AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: AiInterviewAnalysisCreateOrConnectWithoutInterviewInput
    upsert?: AiInterviewAnalysisUpsertWithoutInterviewInput
    disconnect?: AiInterviewAnalysisWhereInput | boolean
    delete?: AiInterviewAnalysisWhereInput | boolean
    connect?: AiInterviewAnalysisWhereUniqueInput
    update?: XOR<XOR<AiInterviewAnalysisUpdateToOneWithWhereWithoutInterviewInput, AiInterviewAnalysisUpdateWithoutInterviewInput>, AiInterviewAnalysisUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput> | AiInterviewCheatingEventCreateWithoutInterviewInput[] | AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput | AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewCheatingEventUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewCheatingEventUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewCheatingEventCreateManyInterviewInputEnvelope
    set?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    disconnect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    delete?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    connect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    update?: AiInterviewCheatingEventUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewCheatingEventUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewCheatingEventUpdateManyWithWhereWithoutInterviewInput | AiInterviewCheatingEventUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewCheatingEventScalarWhereInput | AiInterviewCheatingEventScalarWhereInput[]
  }

  export type AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput> | AiInterviewPostureDataCreateWithoutInterviewInput[] | AiInterviewPostureDataUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewPostureDataCreateOrConnectWithoutInterviewInput | AiInterviewPostureDataCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewPostureDataUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewPostureDataUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewPostureDataCreateManyInterviewInputEnvelope
    set?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    disconnect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    delete?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    connect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    update?: AiInterviewPostureDataUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewPostureDataUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewPostureDataUpdateManyWithWhereWithoutInterviewInput | AiInterviewPostureDataUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewPostureDataScalarWhereInput | AiInterviewPostureDataScalarWhereInput[]
  }

  export type AiInterviewQuestionUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput> | AiInterviewQuestionCreateWithoutInterviewInput[] | AiInterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutInterviewInput | AiInterviewQuestionCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewQuestionCreateManyInterviewInputEnvelope
    set?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    disconnect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    delete?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    connect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    update?: AiInterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewQuestionUpdateManyWithWhereWithoutInterviewInput | AiInterviewQuestionUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewQuestionScalarWhereInput | AiInterviewQuestionScalarWhereInput[]
  }

  export type AiInterviewResponseUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput> | AiInterviewResponseCreateWithoutInterviewInput[] | AiInterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutInterviewInput | AiInterviewResponseCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewResponseUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewResponseUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewResponseCreateManyInterviewInputEnvelope
    set?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    disconnect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    delete?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    update?: AiInterviewResponseUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewResponseUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewResponseUpdateManyWithWhereWithoutInterviewInput | AiInterviewResponseUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
  }

  export type AiVoicePromptUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput> | AiVoicePromptCreateWithoutInterviewInput[] | AiVoicePromptUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiVoicePromptCreateOrConnectWithoutInterviewInput | AiVoicePromptCreateOrConnectWithoutInterviewInput[]
    upsert?: AiVoicePromptUpsertWithWhereUniqueWithoutInterviewInput | AiVoicePromptUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiVoicePromptCreateManyInterviewInputEnvelope
    set?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    disconnect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    delete?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    connect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    update?: AiVoicePromptUpdateWithWhereUniqueWithoutInterviewInput | AiVoicePromptUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiVoicePromptUpdateManyWithWhereWithoutInterviewInput | AiVoicePromptUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiVoicePromptScalarWhereInput | AiVoicePromptScalarWhereInput[]
  }

  export type AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: AiInterviewAnalysisCreateOrConnectWithoutInterviewInput
    upsert?: AiInterviewAnalysisUpsertWithoutInterviewInput
    disconnect?: AiInterviewAnalysisWhereInput | boolean
    delete?: AiInterviewAnalysisWhereInput | boolean
    connect?: AiInterviewAnalysisWhereUniqueInput
    update?: XOR<XOR<AiInterviewAnalysisUpdateToOneWithWhereWithoutInterviewInput, AiInterviewAnalysisUpdateWithoutInterviewInput>, AiInterviewAnalysisUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput> | AiInterviewCheatingEventCreateWithoutInterviewInput[] | AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput | AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewCheatingEventUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewCheatingEventUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewCheatingEventCreateManyInterviewInputEnvelope
    set?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    disconnect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    delete?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    connect?: AiInterviewCheatingEventWhereUniqueInput | AiInterviewCheatingEventWhereUniqueInput[]
    update?: AiInterviewCheatingEventUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewCheatingEventUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewCheatingEventUpdateManyWithWhereWithoutInterviewInput | AiInterviewCheatingEventUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewCheatingEventScalarWhereInput | AiInterviewCheatingEventScalarWhereInput[]
  }

  export type AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput> | AiInterviewPostureDataCreateWithoutInterviewInput[] | AiInterviewPostureDataUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewPostureDataCreateOrConnectWithoutInterviewInput | AiInterviewPostureDataCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewPostureDataUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewPostureDataUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewPostureDataCreateManyInterviewInputEnvelope
    set?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    disconnect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    delete?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    connect?: AiInterviewPostureDataWhereUniqueInput | AiInterviewPostureDataWhereUniqueInput[]
    update?: AiInterviewPostureDataUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewPostureDataUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewPostureDataUpdateManyWithWhereWithoutInterviewInput | AiInterviewPostureDataUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewPostureDataScalarWhereInput | AiInterviewPostureDataScalarWhereInput[]
  }

  export type AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput> | AiInterviewQuestionCreateWithoutInterviewInput[] | AiInterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutInterviewInput | AiInterviewQuestionCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewQuestionCreateManyInterviewInputEnvelope
    set?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    disconnect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    delete?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    connect?: AiInterviewQuestionWhereUniqueInput | AiInterviewQuestionWhereUniqueInput[]
    update?: AiInterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewQuestionUpdateManyWithWhereWithoutInterviewInput | AiInterviewQuestionUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewQuestionScalarWhereInput | AiInterviewQuestionScalarWhereInput[]
  }

  export type AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput> | AiInterviewResponseCreateWithoutInterviewInput[] | AiInterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutInterviewInput | AiInterviewResponseCreateOrConnectWithoutInterviewInput[]
    upsert?: AiInterviewResponseUpsertWithWhereUniqueWithoutInterviewInput | AiInterviewResponseUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiInterviewResponseCreateManyInterviewInputEnvelope
    set?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    disconnect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    delete?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    update?: AiInterviewResponseUpdateWithWhereUniqueWithoutInterviewInput | AiInterviewResponseUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiInterviewResponseUpdateManyWithWhereWithoutInterviewInput | AiInterviewResponseUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
  }

  export type AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput> | AiVoicePromptCreateWithoutInterviewInput[] | AiVoicePromptUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: AiVoicePromptCreateOrConnectWithoutInterviewInput | AiVoicePromptCreateOrConnectWithoutInterviewInput[]
    upsert?: AiVoicePromptUpsertWithWhereUniqueWithoutInterviewInput | AiVoicePromptUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: AiVoicePromptCreateManyInterviewInputEnvelope
    set?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    disconnect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    delete?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    connect?: AiVoicePromptWhereUniqueInput | AiVoicePromptWhereUniqueInput[]
    update?: AiVoicePromptUpdateWithWhereUniqueWithoutInterviewInput | AiVoicePromptUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: AiVoicePromptUpdateManyWithWhereWithoutInterviewInput | AiVoicePromptUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: AiVoicePromptScalarWhereInput | AiVoicePromptScalarWhereInput[]
  }

  export type AiInterviewCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<AiInterviewCreateWithoutQuestionsInput, AiInterviewUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutQuestionsInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewResponseCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput> | AiInterviewResponseCreateWithoutQuestionInput[] | AiInterviewResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutQuestionInput | AiInterviewResponseCreateOrConnectWithoutQuestionInput[]
    createMany?: AiInterviewResponseCreateManyQuestionInputEnvelope
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
  }

  export type AiInterviewResponseUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput> | AiInterviewResponseCreateWithoutQuestionInput[] | AiInterviewResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutQuestionInput | AiInterviewResponseCreateOrConnectWithoutQuestionInput[]
    createMany?: AiInterviewResponseCreateManyQuestionInputEnvelope
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AiInterviewUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<AiInterviewCreateWithoutQuestionsInput, AiInterviewUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutQuestionsInput
    upsert?: AiInterviewUpsertWithoutQuestionsInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutQuestionsInput, AiInterviewUpdateWithoutQuestionsInput>, AiInterviewUncheckedUpdateWithoutQuestionsInput>
  }

  export type AiInterviewResponseUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput> | AiInterviewResponseCreateWithoutQuestionInput[] | AiInterviewResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutQuestionInput | AiInterviewResponseCreateOrConnectWithoutQuestionInput[]
    upsert?: AiInterviewResponseUpsertWithWhereUniqueWithoutQuestionInput | AiInterviewResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AiInterviewResponseCreateManyQuestionInputEnvelope
    set?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    disconnect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    delete?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    update?: AiInterviewResponseUpdateWithWhereUniqueWithoutQuestionInput | AiInterviewResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AiInterviewResponseUpdateManyWithWhereWithoutQuestionInput | AiInterviewResponseUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
  }

  export type AiInterviewResponseUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput> | AiInterviewResponseCreateWithoutQuestionInput[] | AiInterviewResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AiInterviewResponseCreateOrConnectWithoutQuestionInput | AiInterviewResponseCreateOrConnectWithoutQuestionInput[]
    upsert?: AiInterviewResponseUpsertWithWhereUniqueWithoutQuestionInput | AiInterviewResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AiInterviewResponseCreateManyQuestionInputEnvelope
    set?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    disconnect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    delete?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    connect?: AiInterviewResponseWhereUniqueInput | AiInterviewResponseWhereUniqueInput[]
    update?: AiInterviewResponseUpdateWithWhereUniqueWithoutQuestionInput | AiInterviewResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AiInterviewResponseUpdateManyWithWhereWithoutQuestionInput | AiInterviewResponseUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
  }

  export type AiInterviewCreateNestedOneWithoutResponsesInput = {
    create?: XOR<AiInterviewCreateWithoutResponsesInput, AiInterviewUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutResponsesInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewQuestionCreateNestedOneWithoutResponsesInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutResponsesInput, AiInterviewQuestionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutResponsesInput
    connect?: AiInterviewQuestionWhereUniqueInput
  }

  export type AiInterviewUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<AiInterviewCreateWithoutResponsesInput, AiInterviewUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutResponsesInput
    upsert?: AiInterviewUpsertWithoutResponsesInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutResponsesInput, AiInterviewUpdateWithoutResponsesInput>, AiInterviewUncheckedUpdateWithoutResponsesInput>
  }

  export type AiInterviewQuestionUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<AiInterviewQuestionCreateWithoutResponsesInput, AiInterviewQuestionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AiInterviewQuestionCreateOrConnectWithoutResponsesInput
    upsert?: AiInterviewQuestionUpsertWithoutResponsesInput
    connect?: AiInterviewQuestionWhereUniqueInput
    update?: XOR<XOR<AiInterviewQuestionUpdateToOneWithWhereWithoutResponsesInput, AiInterviewQuestionUpdateWithoutResponsesInput>, AiInterviewQuestionUncheckedUpdateWithoutResponsesInput>
  }

  export type AiInterviewCreateNestedOneWithoutCheating_eventsInput = {
    create?: XOR<AiInterviewCreateWithoutCheating_eventsInput, AiInterviewUncheckedCreateWithoutCheating_eventsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCheating_eventsInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewUpdateOneRequiredWithoutCheating_eventsNestedInput = {
    create?: XOR<AiInterviewCreateWithoutCheating_eventsInput, AiInterviewUncheckedCreateWithoutCheating_eventsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutCheating_eventsInput
    upsert?: AiInterviewUpsertWithoutCheating_eventsInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutCheating_eventsInput, AiInterviewUpdateWithoutCheating_eventsInput>, AiInterviewUncheckedUpdateWithoutCheating_eventsInput>
  }

  export type AiInterviewCreateNestedOneWithoutPosture_dataInput = {
    create?: XOR<AiInterviewCreateWithoutPosture_dataInput, AiInterviewUncheckedCreateWithoutPosture_dataInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutPosture_dataInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewUpdateOneRequiredWithoutPosture_dataNestedInput = {
    create?: XOR<AiInterviewCreateWithoutPosture_dataInput, AiInterviewUncheckedCreateWithoutPosture_dataInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutPosture_dataInput
    upsert?: AiInterviewUpsertWithoutPosture_dataInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutPosture_dataInput, AiInterviewUpdateWithoutPosture_dataInput>, AiInterviewUncheckedUpdateWithoutPosture_dataInput>
  }

  export type AiInterviewCreateNestedOneWithoutVoice_promptsInput = {
    create?: XOR<AiInterviewCreateWithoutVoice_promptsInput, AiInterviewUncheckedCreateWithoutVoice_promptsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutVoice_promptsInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewUpdateOneRequiredWithoutVoice_promptsNestedInput = {
    create?: XOR<AiInterviewCreateWithoutVoice_promptsInput, AiInterviewUncheckedCreateWithoutVoice_promptsInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutVoice_promptsInput
    upsert?: AiInterviewUpsertWithoutVoice_promptsInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutVoice_promptsInput, AiInterviewUpdateWithoutVoice_promptsInput>, AiInterviewUncheckedUpdateWithoutVoice_promptsInput>
  }

  export type AiInterviewCreateNestedOneWithoutAnalysisInput = {
    create?: XOR<AiInterviewCreateWithoutAnalysisInput, AiInterviewUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutAnalysisInput
    connect?: AiInterviewWhereUniqueInput
  }

  export type AiInterviewUpdateOneRequiredWithoutAnalysisNestedInput = {
    create?: XOR<AiInterviewCreateWithoutAnalysisInput, AiInterviewUncheckedCreateWithoutAnalysisInput>
    connectOrCreate?: AiInterviewCreateOrConnectWithoutAnalysisInput
    upsert?: AiInterviewUpsertWithoutAnalysisInput
    connect?: AiInterviewWhereUniqueInput
    update?: XOR<XOR<AiInterviewUpdateToOneWithWhereWithoutAnalysisInput, AiInterviewUpdateWithoutAnalysisInput>, AiInterviewUncheckedUpdateWithoutAnalysisInput>
  }

  export type UserCreateNestedOneWithoutAi_generation_logsInput = {
    create?: XOR<UserCreateWithoutAi_generation_logsInput, UserUncheckedCreateWithoutAi_generation_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAi_generation_logsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAi_generation_logsNestedInput = {
    create?: XOR<UserCreateWithoutAi_generation_logsInput, UserUncheckedCreateWithoutAi_generation_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAi_generation_logsInput
    upsert?: UserUpsertWithoutAi_generation_logsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAi_generation_logsInput, UserUpdateWithoutAi_generation_logsInput>, UserUncheckedUpdateWithoutAi_generation_logsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type AiGenerationLogCreateWithoutUserInput = {
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type AiGenerationLogUncheckedCreateWithoutUserInput = {
    log_id?: number
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type AiGenerationLogCreateOrConnectWithoutUserInput = {
    where: AiGenerationLogWhereUniqueInput
    create: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput>
  }

  export type AiGenerationLogCreateManyUserInputEnvelope = {
    data: AiGenerationLogCreateManyUserInput | AiGenerationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CandidateProfileCreateWithoutUserInput = {
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewCreateNestedManyWithoutCandidateInput
    resumes?: ResumeCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileUncheckedCreateWithoutUserInput = {
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutCandidateInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileCreateOrConnectWithoutUserInput = {
    where: CandidateProfileWhereUniqueInput
    create: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    role_id: number
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AiGenerationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AiGenerationLogWhereUniqueInput
    update: XOR<AiGenerationLogUpdateWithoutUserInput, AiGenerationLogUncheckedUpdateWithoutUserInput>
    create: XOR<AiGenerationLogCreateWithoutUserInput, AiGenerationLogUncheckedCreateWithoutUserInput>
  }

  export type AiGenerationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AiGenerationLogWhereUniqueInput
    data: XOR<AiGenerationLogUpdateWithoutUserInput, AiGenerationLogUncheckedUpdateWithoutUserInput>
  }

  export type AiGenerationLogUpdateManyWithWhereWithoutUserInput = {
    where: AiGenerationLogScalarWhereInput
    data: XOR<AiGenerationLogUpdateManyMutationInput, AiGenerationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AiGenerationLogScalarWhereInput = {
    AND?: AiGenerationLogScalarWhereInput | AiGenerationLogScalarWhereInput[]
    OR?: AiGenerationLogScalarWhereInput[]
    NOT?: AiGenerationLogScalarWhereInput | AiGenerationLogScalarWhereInput[]
    log_id?: IntFilter<"AiGenerationLog"> | number
    user_id?: IntFilter<"AiGenerationLog"> | number
    service_used?: StringNullableFilter<"AiGenerationLog"> | string | null
    request_payload?: JsonNullableFilter<"AiGenerationLog">
    response_payload?: JsonNullableFilter<"AiGenerationLog">
    created_at?: DateTimeNullableFilter<"AiGenerationLog"> | Date | string | null
  }

  export type CandidateProfileUpsertWithoutUserInput = {
    update: XOR<CandidateProfileUpdateWithoutUserInput, CandidateProfileUncheckedUpdateWithoutUserInput>
    create: XOR<CandidateProfileCreateWithoutUserInput, CandidateProfileUncheckedCreateWithoutUserInput>
    where?: CandidateProfileWhereInput
  }

  export type CandidateProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: CandidateProfileWhereInput
    data: XOR<CandidateProfileUpdateWithoutUserInput, CandidateProfileUncheckedUpdateWithoutUserInput>
  }

  export type CandidateProfileUpdateWithoutUserInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUpdateManyWithoutCandidateNestedInput
    resumes?: ResumeUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateProfileUncheckedUpdateWithoutUserInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutCandidateNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    user_id?: IntFilter<"UserRole"> | number
    role_id?: IntFilter<"UserRole"> | number
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    user_id: number
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutUsersInput = {
    role_name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    role_id?: number
    role_name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutRolesInput = {
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogCreateNestedManyWithoutUserInput
    CandidateProfile?: CandidateProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    user_id?: number
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedCreateNestedManyWithoutUserInput
    CandidateProfile?: CandidateProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUpdateManyWithoutUserNestedInput
    CandidateProfile?: CandidateProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedUpdateManyWithoutUserNestedInput
    CandidateProfile?: CandidateProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type JobPostingCreateWithoutCompanyInput = {
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewCreateNestedManyWithoutJobInput
    requirements?: JobRequirementCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutJobInput
  }

  export type JobPostingUncheckedCreateWithoutCompanyInput = {
    job_id?: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutJobInput
    requirements?: JobRequirementUncheckedCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobPostingCreateOrConnectWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostingCreateManyCompanyInputEnvelope = {
    data: JobPostingCreateManyCompanyInput | JobPostingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type JobPostingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    update: XOR<JobPostingUpdateWithoutCompanyInput, JobPostingUncheckedUpdateWithoutCompanyInput>
    create: XOR<JobPostingCreateWithoutCompanyInput, JobPostingUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JobPostingWhereUniqueInput
    data: XOR<JobPostingUpdateWithoutCompanyInput, JobPostingUncheckedUpdateWithoutCompanyInput>
  }

  export type JobPostingUpdateManyWithWhereWithoutCompanyInput = {
    where: JobPostingScalarWhereInput
    data: XOR<JobPostingUpdateManyMutationInput, JobPostingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type JobPostingScalarWhereInput = {
    AND?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
    OR?: JobPostingScalarWhereInput[]
    NOT?: JobPostingScalarWhereInput | JobPostingScalarWhereInput[]
    job_id?: IntFilter<"JobPosting"> | number
    company_id?: IntFilter<"JobPosting"> | number
    title?: StringNullableFilter<"JobPosting"> | string | null
    description?: StringNullableFilter<"JobPosting"> | string | null
    location?: StringNullableFilter<"JobPosting"> | string | null
    posted_at?: DateTimeNullableFilter<"JobPosting"> | Date | string | null
  }

  export type AiInterviewCreateWithoutJobInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutJobInput = {
    interview_id?: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutJobInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput>
  }

  export type AiInterviewCreateManyJobInputEnvelope = {
    data: AiInterviewCreateManyJobInput | AiInterviewCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutJob_postingsInput = {
    name?: string | null
    website?: string | null
    created_at?: Date | string | null
  }

  export type CompanyUncheckedCreateWithoutJob_postingsInput = {
    company_id?: number
    name?: string | null
    website?: string | null
    created_at?: Date | string | null
  }

  export type CompanyCreateOrConnectWithoutJob_postingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJob_postingsInput, CompanyUncheckedCreateWithoutJob_postingsInput>
  }

  export type JobRequirementCreateWithoutJobInput = {
    required_level?: string | null
    skill: SkillCreateNestedOneWithoutJob_requirementsInput
  }

  export type JobRequirementUncheckedCreateWithoutJobInput = {
    req_id?: number
    skill_id: number
    required_level?: string | null
  }

  export type JobRequirementCreateOrConnectWithoutJobInput = {
    where: JobRequirementWhereUniqueInput
    create: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput>
  }

  export type JobRequirementCreateManyJobInputEnvelope = {
    data: JobRequirementCreateManyJobInput | JobRequirementCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ResumeVsJdMatchCreateWithoutJobInput = {
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    resume: ResumeCreateNestedOneWithoutMatchesInput
  }

  export type ResumeVsJdMatchUncheckedCreateWithoutJobInput = {
    match_id?: number
    resume_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchCreateOrConnectWithoutJobInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    create: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput>
  }

  export type ResumeVsJdMatchCreateManyJobInputEnvelope = {
    data: ResumeVsJdMatchCreateManyJobInput | ResumeVsJdMatchCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewUpsertWithWhereUniqueWithoutJobInput = {
    where: AiInterviewWhereUniqueInput
    update: XOR<AiInterviewUpdateWithoutJobInput, AiInterviewUncheckedUpdateWithoutJobInput>
    create: XOR<AiInterviewCreateWithoutJobInput, AiInterviewUncheckedCreateWithoutJobInput>
  }

  export type AiInterviewUpdateWithWhereUniqueWithoutJobInput = {
    where: AiInterviewWhereUniqueInput
    data: XOR<AiInterviewUpdateWithoutJobInput, AiInterviewUncheckedUpdateWithoutJobInput>
  }

  export type AiInterviewUpdateManyWithWhereWithoutJobInput = {
    where: AiInterviewScalarWhereInput
    data: XOR<AiInterviewUpdateManyMutationInput, AiInterviewUncheckedUpdateManyWithoutJobInput>
  }

  export type AiInterviewScalarWhereInput = {
    AND?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
    OR?: AiInterviewScalarWhereInput[]
    NOT?: AiInterviewScalarWhereInput | AiInterviewScalarWhereInput[]
    interview_id?: IntFilter<"AiInterview"> | number
    job_id?: IntFilter<"AiInterview"> | number
    candidate_id?: IntFilter<"AiInterview"> | number
    scheduled_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
    status?: StringNullableFilter<"AiInterview"> | string | null
    created_at?: DateTimeNullableFilter<"AiInterview"> | Date | string | null
  }

  export type CompanyUpsertWithoutJob_postingsInput = {
    update: XOR<CompanyUpdateWithoutJob_postingsInput, CompanyUncheckedUpdateWithoutJob_postingsInput>
    create: XOR<CompanyCreateWithoutJob_postingsInput, CompanyUncheckedCreateWithoutJob_postingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutJob_postingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutJob_postingsInput, CompanyUncheckedUpdateWithoutJob_postingsInput>
  }

  export type CompanyUpdateWithoutJob_postingsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateWithoutJob_postingsInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobRequirementUpsertWithWhereUniqueWithoutJobInput = {
    where: JobRequirementWhereUniqueInput
    update: XOR<JobRequirementUpdateWithoutJobInput, JobRequirementUncheckedUpdateWithoutJobInput>
    create: XOR<JobRequirementCreateWithoutJobInput, JobRequirementUncheckedCreateWithoutJobInput>
  }

  export type JobRequirementUpdateWithWhereUniqueWithoutJobInput = {
    where: JobRequirementWhereUniqueInput
    data: XOR<JobRequirementUpdateWithoutJobInput, JobRequirementUncheckedUpdateWithoutJobInput>
  }

  export type JobRequirementUpdateManyWithWhereWithoutJobInput = {
    where: JobRequirementScalarWhereInput
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyWithoutJobInput>
  }

  export type JobRequirementScalarWhereInput = {
    AND?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
    OR?: JobRequirementScalarWhereInput[]
    NOT?: JobRequirementScalarWhereInput | JobRequirementScalarWhereInput[]
    req_id?: IntFilter<"JobRequirement"> | number
    job_id?: IntFilter<"JobRequirement"> | number
    skill_id?: IntFilter<"JobRequirement"> | number
    required_level?: StringNullableFilter<"JobRequirement"> | string | null
  }

  export type ResumeVsJdMatchUpsertWithWhereUniqueWithoutJobInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    update: XOR<ResumeVsJdMatchUpdateWithoutJobInput, ResumeVsJdMatchUncheckedUpdateWithoutJobInput>
    create: XOR<ResumeVsJdMatchCreateWithoutJobInput, ResumeVsJdMatchUncheckedCreateWithoutJobInput>
  }

  export type ResumeVsJdMatchUpdateWithWhereUniqueWithoutJobInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    data: XOR<ResumeVsJdMatchUpdateWithoutJobInput, ResumeVsJdMatchUncheckedUpdateWithoutJobInput>
  }

  export type ResumeVsJdMatchUpdateManyWithWhereWithoutJobInput = {
    where: ResumeVsJdMatchScalarWhereInput
    data: XOR<ResumeVsJdMatchUpdateManyMutationInput, ResumeVsJdMatchUncheckedUpdateManyWithoutJobInput>
  }

  export type ResumeVsJdMatchScalarWhereInput = {
    AND?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
    OR?: ResumeVsJdMatchScalarWhereInput[]
    NOT?: ResumeVsJdMatchScalarWhereInput | ResumeVsJdMatchScalarWhereInput[]
    match_id?: IntFilter<"ResumeVsJdMatch"> | number
    resume_id?: IntFilter<"ResumeVsJdMatch"> | number
    job_id?: IntFilter<"ResumeVsJdMatch"> | number
    match_score?: FloatNullableFilter<"ResumeVsJdMatch"> | number | null
    matched_skills?: JsonNullableFilter<"ResumeVsJdMatch">
    missing_skills?: JsonNullableFilter<"ResumeVsJdMatch">
  }

  export type JobRequirementCreateWithoutSkillInput = {
    required_level?: string | null
    job: JobPostingCreateNestedOneWithoutRequirementsInput
  }

  export type JobRequirementUncheckedCreateWithoutSkillInput = {
    req_id?: number
    job_id: number
    required_level?: string | null
  }

  export type JobRequirementCreateOrConnectWithoutSkillInput = {
    where: JobRequirementWhereUniqueInput
    create: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput>
  }

  export type JobRequirementCreateManySkillInputEnvelope = {
    data: JobRequirementCreateManySkillInput | JobRequirementCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type ParsedResumeSkillCreateWithoutSkillInput = {
    resume: ResumeCreateNestedOneWithoutParsed_resume_skillsInput
  }

  export type ParsedResumeSkillUncheckedCreateWithoutSkillInput = {
    resume_id: number
  }

  export type ParsedResumeSkillCreateOrConnectWithoutSkillInput = {
    where: ParsedResumeSkillWhereUniqueInput
    create: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput>
  }

  export type ParsedResumeSkillCreateManySkillInputEnvelope = {
    data: ParsedResumeSkillCreateManySkillInput | ParsedResumeSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type JobRequirementUpsertWithWhereUniqueWithoutSkillInput = {
    where: JobRequirementWhereUniqueInput
    update: XOR<JobRequirementUpdateWithoutSkillInput, JobRequirementUncheckedUpdateWithoutSkillInput>
    create: XOR<JobRequirementCreateWithoutSkillInput, JobRequirementUncheckedCreateWithoutSkillInput>
  }

  export type JobRequirementUpdateWithWhereUniqueWithoutSkillInput = {
    where: JobRequirementWhereUniqueInput
    data: XOR<JobRequirementUpdateWithoutSkillInput, JobRequirementUncheckedUpdateWithoutSkillInput>
  }

  export type JobRequirementUpdateManyWithWhereWithoutSkillInput = {
    where: JobRequirementScalarWhereInput
    data: XOR<JobRequirementUpdateManyMutationInput, JobRequirementUncheckedUpdateManyWithoutSkillInput>
  }

  export type ParsedResumeSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: ParsedResumeSkillWhereUniqueInput
    update: XOR<ParsedResumeSkillUpdateWithoutSkillInput, ParsedResumeSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<ParsedResumeSkillCreateWithoutSkillInput, ParsedResumeSkillUncheckedCreateWithoutSkillInput>
  }

  export type ParsedResumeSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: ParsedResumeSkillWhereUniqueInput
    data: XOR<ParsedResumeSkillUpdateWithoutSkillInput, ParsedResumeSkillUncheckedUpdateWithoutSkillInput>
  }

  export type ParsedResumeSkillUpdateManyWithWhereWithoutSkillInput = {
    where: ParsedResumeSkillScalarWhereInput
    data: XOR<ParsedResumeSkillUpdateManyMutationInput, ParsedResumeSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type ParsedResumeSkillScalarWhereInput = {
    AND?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
    OR?: ParsedResumeSkillScalarWhereInput[]
    NOT?: ParsedResumeSkillScalarWhereInput | ParsedResumeSkillScalarWhereInput[]
    resume_id?: IntFilter<"ParsedResumeSkill"> | number
    skill_id?: IntFilter<"ParsedResumeSkill"> | number
  }

  export type JobPostingCreateWithoutRequirementsInput = {
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewCreateNestedManyWithoutJobInput
    company: CompanyCreateNestedOneWithoutJob_postingsInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutJobInput
  }

  export type JobPostingUncheckedCreateWithoutRequirementsInput = {
    job_id?: number
    company_id: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobPostingCreateOrConnectWithoutRequirementsInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutRequirementsInput, JobPostingUncheckedCreateWithoutRequirementsInput>
  }

  export type SkillCreateWithoutJob_requirementsInput = {
    skill_name: string
    parsed_resume_skills?: ParsedResumeSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutJob_requirementsInput = {
    skill_id?: number
    skill_name: string
    parsed_resume_skills?: ParsedResumeSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutJob_requirementsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutJob_requirementsInput, SkillUncheckedCreateWithoutJob_requirementsInput>
  }

  export type JobPostingUpsertWithoutRequirementsInput = {
    update: XOR<JobPostingUpdateWithoutRequirementsInput, JobPostingUncheckedUpdateWithoutRequirementsInput>
    create: XOR<JobPostingCreateWithoutRequirementsInput, JobPostingUncheckedCreateWithoutRequirementsInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutRequirementsInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutRequirementsInput, JobPostingUncheckedUpdateWithoutRequirementsInput>
  }

  export type JobPostingUpdateWithoutRequirementsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUpdateManyWithoutJobNestedInput
    company?: CompanyUpdateOneRequiredWithoutJob_postingsNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutRequirementsInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutJobNestedInput
  }

  export type SkillUpsertWithoutJob_requirementsInput = {
    update: XOR<SkillUpdateWithoutJob_requirementsInput, SkillUncheckedUpdateWithoutJob_requirementsInput>
    create: XOR<SkillCreateWithoutJob_requirementsInput, SkillUncheckedCreateWithoutJob_requirementsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutJob_requirementsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutJob_requirementsInput, SkillUncheckedUpdateWithoutJob_requirementsInput>
  }

  export type SkillUpdateWithoutJob_requirementsInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    parsed_resume_skills?: ParsedResumeSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutJob_requirementsInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    parsed_resume_skills?: ParsedResumeSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type AiInterviewCreateWithoutCandidateInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutCandidateInput = {
    interview_id?: number
    job_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutCandidateInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput>
  }

  export type AiInterviewCreateManyCandidateInputEnvelope = {
    data: AiInterviewCreateManyCandidateInput | AiInterviewCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCandidateProfileInput = {
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCandidateProfileInput = {
    user_id?: number
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCandidateProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCandidateProfileInput, UserUncheckedCreateWithoutCandidateProfileInput>
  }

  export type ResumeCreateWithoutCandidateInput = {
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillCreateNestedManyWithoutResumeInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutCandidateInput = {
    resume_id?: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedCreateNestedManyWithoutResumeInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutCandidateInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput>
  }

  export type ResumeCreateManyCandidateInputEnvelope = {
    data: ResumeCreateManyCandidateInput | ResumeCreateManyCandidateInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewUpsertWithWhereUniqueWithoutCandidateInput = {
    where: AiInterviewWhereUniqueInput
    update: XOR<AiInterviewUpdateWithoutCandidateInput, AiInterviewUncheckedUpdateWithoutCandidateInput>
    create: XOR<AiInterviewCreateWithoutCandidateInput, AiInterviewUncheckedCreateWithoutCandidateInput>
  }

  export type AiInterviewUpdateWithWhereUniqueWithoutCandidateInput = {
    where: AiInterviewWhereUniqueInput
    data: XOR<AiInterviewUpdateWithoutCandidateInput, AiInterviewUncheckedUpdateWithoutCandidateInput>
  }

  export type AiInterviewUpdateManyWithWhereWithoutCandidateInput = {
    where: AiInterviewScalarWhereInput
    data: XOR<AiInterviewUpdateManyMutationInput, AiInterviewUncheckedUpdateManyWithoutCandidateInput>
  }

  export type UserUpsertWithoutCandidateProfileInput = {
    update: XOR<UserUpdateWithoutCandidateProfileInput, UserUncheckedUpdateWithoutCandidateProfileInput>
    create: XOR<UserCreateWithoutCandidateProfileInput, UserUncheckedCreateWithoutCandidateProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCandidateProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCandidateProfileInput, UserUncheckedUpdateWithoutCandidateProfileInput>
  }

  export type UserUpdateWithoutCandidateProfileInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCandidateProfileInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ai_generation_logs?: AiGenerationLogUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithWhereUniqueWithoutCandidateInput = {
    where: ResumeWhereUniqueInput
    update: XOR<ResumeUpdateWithoutCandidateInput, ResumeUncheckedUpdateWithoutCandidateInput>
    create: XOR<ResumeCreateWithoutCandidateInput, ResumeUncheckedCreateWithoutCandidateInput>
  }

  export type ResumeUpdateWithWhereUniqueWithoutCandidateInput = {
    where: ResumeWhereUniqueInput
    data: XOR<ResumeUpdateWithoutCandidateInput, ResumeUncheckedUpdateWithoutCandidateInput>
  }

  export type ResumeUpdateManyWithWhereWithoutCandidateInput = {
    where: ResumeScalarWhereInput
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyWithoutCandidateInput>
  }

  export type ResumeScalarWhereInput = {
    AND?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    OR?: ResumeScalarWhereInput[]
    NOT?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    resume_id?: IntFilter<"Resume"> | number
    candidate_id?: IntFilter<"Resume"> | number
    file_path?: StringNullableFilter<"Resume"> | string | null
    parsed_text?: StringNullableFilter<"Resume"> | string | null
    parsed_json?: JsonNullableFilter<"Resume">
    uploaded_at?: DateTimeNullableFilter<"Resume"> | Date | string | null
  }

  export type ParsedResumeSkillCreateWithoutResumeInput = {
    skill: SkillCreateNestedOneWithoutParsed_resume_skillsInput
  }

  export type ParsedResumeSkillUncheckedCreateWithoutResumeInput = {
    skill_id: number
  }

  export type ParsedResumeSkillCreateOrConnectWithoutResumeInput = {
    where: ParsedResumeSkillWhereUniqueInput
    create: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput>
  }

  export type ParsedResumeSkillCreateManyResumeInputEnvelope = {
    data: ParsedResumeSkillCreateManyResumeInput | ParsedResumeSkillCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type CandidateProfileCreateWithoutResumesInput = {
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewCreateNestedManyWithoutCandidateInput
    user: UserCreateNestedOneWithoutCandidateProfileInput
  }

  export type CandidateProfileUncheckedCreateWithoutResumesInput = {
    candidate_id: number
    education?: string | null
    experience?: string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileCreateOrConnectWithoutResumesInput = {
    where: CandidateProfileWhereUniqueInput
    create: XOR<CandidateProfileCreateWithoutResumesInput, CandidateProfileUncheckedCreateWithoutResumesInput>
  }

  export type ResumeVsJdMatchCreateWithoutResumeInput = {
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    job: JobPostingCreateNestedOneWithoutMatchesInput
  }

  export type ResumeVsJdMatchUncheckedCreateWithoutResumeInput = {
    match_id?: number
    job_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchCreateOrConnectWithoutResumeInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    create: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput>
  }

  export type ResumeVsJdMatchCreateManyResumeInputEnvelope = {
    data: ResumeVsJdMatchCreateManyResumeInput | ResumeVsJdMatchCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ParsedResumeSkillUpsertWithWhereUniqueWithoutResumeInput = {
    where: ParsedResumeSkillWhereUniqueInput
    update: XOR<ParsedResumeSkillUpdateWithoutResumeInput, ParsedResumeSkillUncheckedUpdateWithoutResumeInput>
    create: XOR<ParsedResumeSkillCreateWithoutResumeInput, ParsedResumeSkillUncheckedCreateWithoutResumeInput>
  }

  export type ParsedResumeSkillUpdateWithWhereUniqueWithoutResumeInput = {
    where: ParsedResumeSkillWhereUniqueInput
    data: XOR<ParsedResumeSkillUpdateWithoutResumeInput, ParsedResumeSkillUncheckedUpdateWithoutResumeInput>
  }

  export type ParsedResumeSkillUpdateManyWithWhereWithoutResumeInput = {
    where: ParsedResumeSkillScalarWhereInput
    data: XOR<ParsedResumeSkillUpdateManyMutationInput, ParsedResumeSkillUncheckedUpdateManyWithoutResumeInput>
  }

  export type CandidateProfileUpsertWithoutResumesInput = {
    update: XOR<CandidateProfileUpdateWithoutResumesInput, CandidateProfileUncheckedUpdateWithoutResumesInput>
    create: XOR<CandidateProfileCreateWithoutResumesInput, CandidateProfileUncheckedCreateWithoutResumesInput>
    where?: CandidateProfileWhereInput
  }

  export type CandidateProfileUpdateToOneWithWhereWithoutResumesInput = {
    where?: CandidateProfileWhereInput
    data: XOR<CandidateProfileUpdateWithoutResumesInput, CandidateProfileUncheckedUpdateWithoutResumesInput>
  }

  export type CandidateProfileUpdateWithoutResumesInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUpdateManyWithoutCandidateNestedInput
    user?: UserUpdateOneRequiredWithoutCandidateProfileNestedInput
  }

  export type CandidateProfileUncheckedUpdateWithoutResumesInput = {
    candidate_id?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type ResumeVsJdMatchUpsertWithWhereUniqueWithoutResumeInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    update: XOR<ResumeVsJdMatchUpdateWithoutResumeInput, ResumeVsJdMatchUncheckedUpdateWithoutResumeInput>
    create: XOR<ResumeVsJdMatchCreateWithoutResumeInput, ResumeVsJdMatchUncheckedCreateWithoutResumeInput>
  }

  export type ResumeVsJdMatchUpdateWithWhereUniqueWithoutResumeInput = {
    where: ResumeVsJdMatchWhereUniqueInput
    data: XOR<ResumeVsJdMatchUpdateWithoutResumeInput, ResumeVsJdMatchUncheckedUpdateWithoutResumeInput>
  }

  export type ResumeVsJdMatchUpdateManyWithWhereWithoutResumeInput = {
    where: ResumeVsJdMatchScalarWhereInput
    data: XOR<ResumeVsJdMatchUpdateManyMutationInput, ResumeVsJdMatchUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeCreateWithoutParsed_resume_skillsInput = {
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutResumesInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutParsed_resume_skillsInput = {
    resume_id?: number
    candidate_id: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutParsed_resume_skillsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutParsed_resume_skillsInput, ResumeUncheckedCreateWithoutParsed_resume_skillsInput>
  }

  export type SkillCreateWithoutParsed_resume_skillsInput = {
    skill_name: string
    job_requirements?: JobRequirementCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutParsed_resume_skillsInput = {
    skill_id?: number
    skill_name: string
    job_requirements?: JobRequirementUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutParsed_resume_skillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutParsed_resume_skillsInput, SkillUncheckedCreateWithoutParsed_resume_skillsInput>
  }

  export type ResumeUpsertWithoutParsed_resume_skillsInput = {
    update: XOR<ResumeUpdateWithoutParsed_resume_skillsInput, ResumeUncheckedUpdateWithoutParsed_resume_skillsInput>
    create: XOR<ResumeCreateWithoutParsed_resume_skillsInput, ResumeUncheckedCreateWithoutParsed_resume_skillsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutParsed_resume_skillsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutParsed_resume_skillsInput, ResumeUncheckedUpdateWithoutParsed_resume_skillsInput>
  }

  export type ResumeUpdateWithoutParsed_resume_skillsInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutResumesNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutParsed_resume_skillsInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type SkillUpsertWithoutParsed_resume_skillsInput = {
    update: XOR<SkillUpdateWithoutParsed_resume_skillsInput, SkillUncheckedUpdateWithoutParsed_resume_skillsInput>
    create: XOR<SkillCreateWithoutParsed_resume_skillsInput, SkillUncheckedCreateWithoutParsed_resume_skillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutParsed_resume_skillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutParsed_resume_skillsInput, SkillUncheckedUpdateWithoutParsed_resume_skillsInput>
  }

  export type SkillUpdateWithoutParsed_resume_skillsInput = {
    skill_name?: StringFieldUpdateOperationsInput | string
    job_requirements?: JobRequirementUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutParsed_resume_skillsInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_name?: StringFieldUpdateOperationsInput | string
    job_requirements?: JobRequirementUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type JobPostingCreateWithoutMatchesInput = {
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewCreateNestedManyWithoutJobInput
    company: CompanyCreateNestedOneWithoutJob_postingsInput
    requirements?: JobRequirementCreateNestedManyWithoutJobInput
  }

  export type JobPostingUncheckedCreateWithoutMatchesInput = {
    job_id?: number
    company_id: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    interviews?: AiInterviewUncheckedCreateNestedManyWithoutJobInput
    requirements?: JobRequirementUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobPostingCreateOrConnectWithoutMatchesInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutMatchesInput, JobPostingUncheckedCreateWithoutMatchesInput>
  }

  export type ResumeCreateWithoutMatchesInput = {
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillCreateNestedManyWithoutResumeInput
    candidate: CandidateProfileCreateNestedOneWithoutResumesInput
  }

  export type ResumeUncheckedCreateWithoutMatchesInput = {
    resume_id?: number
    candidate_id: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutMatchesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutMatchesInput, ResumeUncheckedCreateWithoutMatchesInput>
  }

  export type JobPostingUpsertWithoutMatchesInput = {
    update: XOR<JobPostingUpdateWithoutMatchesInput, JobPostingUncheckedUpdateWithoutMatchesInput>
    create: XOR<JobPostingCreateWithoutMatchesInput, JobPostingUncheckedCreateWithoutMatchesInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutMatchesInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutMatchesInput, JobPostingUncheckedUpdateWithoutMatchesInput>
  }

  export type JobPostingUpdateWithoutMatchesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUpdateManyWithoutJobNestedInput
    company?: CompanyUpdateOneRequiredWithoutJob_postingsNestedInput
    requirements?: JobRequirementUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutMatchesInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutJobNestedInput
    requirements?: JobRequirementUncheckedUpdateManyWithoutJobNestedInput
  }

  export type ResumeUpsertWithoutMatchesInput = {
    update: XOR<ResumeUpdateWithoutMatchesInput, ResumeUncheckedUpdateWithoutMatchesInput>
    create: XOR<ResumeCreateWithoutMatchesInput, ResumeUncheckedCreateWithoutMatchesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutMatchesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutMatchesInput, ResumeUncheckedUpdateWithoutMatchesInput>
  }

  export type ResumeUpdateWithoutMatchesInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUpdateManyWithoutResumeNestedInput
    candidate?: CandidateProfileUpdateOneRequiredWithoutResumesNestedInput
  }

  export type ResumeUncheckedUpdateWithoutMatchesInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type CandidateProfileCreateWithoutInterviewsInput = {
    education?: string | null
    experience?: string | null
    user: UserCreateNestedOneWithoutCandidateProfileInput
    resumes?: ResumeCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileUncheckedCreateWithoutInterviewsInput = {
    candidate_id: number
    education?: string | null
    experience?: string | null
    resumes?: ResumeUncheckedCreateNestedManyWithoutCandidateInput
  }

  export type CandidateProfileCreateOrConnectWithoutInterviewsInput = {
    where: CandidateProfileWhereUniqueInput
    create: XOR<CandidateProfileCreateWithoutInterviewsInput, CandidateProfileUncheckedCreateWithoutInterviewsInput>
  }

  export type JobPostingCreateWithoutInterviewsInput = {
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    company: CompanyCreateNestedOneWithoutJob_postingsInput
    requirements?: JobRequirementCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchCreateNestedManyWithoutJobInput
  }

  export type JobPostingUncheckedCreateWithoutInterviewsInput = {
    job_id?: number
    company_id: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
    requirements?: JobRequirementUncheckedCreateNestedManyWithoutJobInput
    matches?: ResumeVsJdMatchUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobPostingCreateOrConnectWithoutInterviewsInput = {
    where: JobPostingWhereUniqueInput
    create: XOR<JobPostingCreateWithoutInterviewsInput, JobPostingUncheckedCreateWithoutInterviewsInput>
  }

  export type AiInterviewAnalysisCreateWithoutInterviewInput = {
    technical_score?: number | null
    communication_score?: number | null
    confidence_score?: number | null
    overall_score?: number | null
    strengths?: string | null
    weaknesses?: string | null
    improvement_suggestions?: string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisUncheckedCreateWithoutInterviewInput = {
    analysis_id?: number
    technical_score?: number | null
    communication_score?: number | null
    confidence_score?: number | null
    overall_score?: number | null
    strengths?: string | null
    weaknesses?: string | null
    improvement_suggestions?: string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisCreateOrConnectWithoutInterviewInput = {
    where: AiInterviewAnalysisWhereUniqueInput
    create: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventCreateWithoutInterviewInput = {
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
  }

  export type AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput = {
    event_id?: number
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
  }

  export type AiInterviewCheatingEventCreateOrConnectWithoutInterviewInput = {
    where: AiInterviewCheatingEventWhereUniqueInput
    create: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventCreateManyInterviewInputEnvelope = {
    data: AiInterviewCheatingEventCreateManyInterviewInput | AiInterviewCheatingEventCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewPostureDataCreateWithoutInterviewInput = {
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUncheckedCreateWithoutInterviewInput = {
    posture_id?: number
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataCreateOrConnectWithoutInterviewInput = {
    where: AiInterviewPostureDataWhereUniqueInput
    create: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewPostureDataCreateManyInterviewInputEnvelope = {
    data: AiInterviewPostureDataCreateManyInterviewInput | AiInterviewPostureDataCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewQuestionCreateWithoutInterviewInput = {
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
    responses?: AiInterviewResponseCreateNestedManyWithoutQuestionInput
  }

  export type AiInterviewQuestionUncheckedCreateWithoutInterviewInput = {
    question_id?: number
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type AiInterviewQuestionCreateOrConnectWithoutInterviewInput = {
    where: AiInterviewQuestionWhereUniqueInput
    create: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewQuestionCreateManyInterviewInputEnvelope = {
    data: AiInterviewQuestionCreateManyInterviewInput | AiInterviewQuestionCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewResponseCreateWithoutInterviewInput = {
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
    question: AiInterviewQuestionCreateNestedOneWithoutResponsesInput
  }

  export type AiInterviewResponseUncheckedCreateWithoutInterviewInput = {
    response_id?: number
    question_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiInterviewResponseCreateOrConnectWithoutInterviewInput = {
    where: AiInterviewResponseWhereUniqueInput
    create: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewResponseCreateManyInterviewInputEnvelope = {
    data: AiInterviewResponseCreateManyInterviewInput | AiInterviewResponseCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type AiVoicePromptCreateWithoutInterviewInput = {
    prompt_text?: string | null
    prompt_audio_path?: string | null
  }

  export type AiVoicePromptUncheckedCreateWithoutInterviewInput = {
    prompt_id?: number
    prompt_text?: string | null
    prompt_audio_path?: string | null
  }

  export type AiVoicePromptCreateOrConnectWithoutInterviewInput = {
    where: AiVoicePromptWhereUniqueInput
    create: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput>
  }

  export type AiVoicePromptCreateManyInterviewInputEnvelope = {
    data: AiVoicePromptCreateManyInterviewInput | AiVoicePromptCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type CandidateProfileUpsertWithoutInterviewsInput = {
    update: XOR<CandidateProfileUpdateWithoutInterviewsInput, CandidateProfileUncheckedUpdateWithoutInterviewsInput>
    create: XOR<CandidateProfileCreateWithoutInterviewsInput, CandidateProfileUncheckedCreateWithoutInterviewsInput>
    where?: CandidateProfileWhereInput
  }

  export type CandidateProfileUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: CandidateProfileWhereInput
    data: XOR<CandidateProfileUpdateWithoutInterviewsInput, CandidateProfileUncheckedUpdateWithoutInterviewsInput>
  }

  export type CandidateProfileUpdateWithoutInterviewsInput = {
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCandidateProfileNestedInput
    resumes?: ResumeUpdateManyWithoutCandidateNestedInput
  }

  export type CandidateProfileUncheckedUpdateWithoutInterviewsInput = {
    candidate_id?: IntFieldUpdateOperationsInput | number
    education?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    resumes?: ResumeUncheckedUpdateManyWithoutCandidateNestedInput
  }

  export type JobPostingUpsertWithoutInterviewsInput = {
    update: XOR<JobPostingUpdateWithoutInterviewsInput, JobPostingUncheckedUpdateWithoutInterviewsInput>
    create: XOR<JobPostingCreateWithoutInterviewsInput, JobPostingUncheckedCreateWithoutInterviewsInput>
    where?: JobPostingWhereInput
  }

  export type JobPostingUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: JobPostingWhereInput
    data: XOR<JobPostingUpdateWithoutInterviewsInput, JobPostingUncheckedUpdateWithoutInterviewsInput>
  }

  export type JobPostingUpdateWithoutInterviewsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company?: CompanyUpdateOneRequiredWithoutJob_postingsNestedInput
    requirements?: JobRequirementUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutInterviewsInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requirements?: JobRequirementUncheckedUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutJobNestedInput
  }

  export type AiInterviewAnalysisUpsertWithoutInterviewInput = {
    update: XOR<AiInterviewAnalysisUpdateWithoutInterviewInput, AiInterviewAnalysisUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiInterviewAnalysisCreateWithoutInterviewInput, AiInterviewAnalysisUncheckedCreateWithoutInterviewInput>
    where?: AiInterviewAnalysisWhereInput
  }

  export type AiInterviewAnalysisUpdateToOneWithWhereWithoutInterviewInput = {
    where?: AiInterviewAnalysisWhereInput
    data: XOR<AiInterviewAnalysisUpdateWithoutInterviewInput, AiInterviewAnalysisUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewAnalysisUpdateWithoutInterviewInput = {
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewAnalysisUncheckedUpdateWithoutInterviewInput = {
    analysis_id?: IntFieldUpdateOperationsInput | number
    technical_score?: NullableFloatFieldUpdateOperationsInput | number | null
    communication_score?: NullableFloatFieldUpdateOperationsInput | number | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    overall_score?: NullableFloatFieldUpdateOperationsInput | number | null
    strengths?: NullableStringFieldUpdateOperationsInput | string | null
    weaknesses?: NullableStringFieldUpdateOperationsInput | string | null
    improvement_suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    analysis_json?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewCheatingEventUpsertWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewCheatingEventWhereUniqueInput
    update: XOR<AiInterviewCheatingEventUpdateWithoutInterviewInput, AiInterviewCheatingEventUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiInterviewCheatingEventCreateWithoutInterviewInput, AiInterviewCheatingEventUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventUpdateWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewCheatingEventWhereUniqueInput
    data: XOR<AiInterviewCheatingEventUpdateWithoutInterviewInput, AiInterviewCheatingEventUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventUpdateManyWithWhereWithoutInterviewInput = {
    where: AiInterviewCheatingEventScalarWhereInput
    data: XOR<AiInterviewCheatingEventUpdateManyMutationInput, AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewInput>
  }

  export type AiInterviewCheatingEventScalarWhereInput = {
    AND?: AiInterviewCheatingEventScalarWhereInput | AiInterviewCheatingEventScalarWhereInput[]
    OR?: AiInterviewCheatingEventScalarWhereInput[]
    NOT?: AiInterviewCheatingEventScalarWhereInput | AiInterviewCheatingEventScalarWhereInput[]
    event_id?: IntFilter<"AiInterviewCheatingEvent"> | number
    interview_id?: IntFilter<"AiInterviewCheatingEvent"> | number
    event_type?: StringNullableFilter<"AiInterviewCheatingEvent"> | string | null
    confidence_score?: FloatNullableFilter<"AiInterviewCheatingEvent"> | number | null
    detected_at?: DateTimeNullableFilter<"AiInterviewCheatingEvent"> | Date | string | null
  }

  export type AiInterviewPostureDataUpsertWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewPostureDataWhereUniqueInput
    update: XOR<AiInterviewPostureDataUpdateWithoutInterviewInput, AiInterviewPostureDataUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiInterviewPostureDataCreateWithoutInterviewInput, AiInterviewPostureDataUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewPostureDataUpdateWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewPostureDataWhereUniqueInput
    data: XOR<AiInterviewPostureDataUpdateWithoutInterviewInput, AiInterviewPostureDataUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewPostureDataUpdateManyWithWhereWithoutInterviewInput = {
    where: AiInterviewPostureDataScalarWhereInput
    data: XOR<AiInterviewPostureDataUpdateManyMutationInput, AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewInput>
  }

  export type AiInterviewPostureDataScalarWhereInput = {
    AND?: AiInterviewPostureDataScalarWhereInput | AiInterviewPostureDataScalarWhereInput[]
    OR?: AiInterviewPostureDataScalarWhereInput[]
    NOT?: AiInterviewPostureDataScalarWhereInput | AiInterviewPostureDataScalarWhereInput[]
    posture_id?: IntFilter<"AiInterviewPostureData"> | number
    interview_id?: IntFilter<"AiInterviewPostureData"> | number
    timestamp?: DateTimeNullableFilter<"AiInterviewPostureData"> | Date | string | null
    posture_data?: JsonNullableFilter<"AiInterviewPostureData">
  }

  export type AiInterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewQuestionWhereUniqueInput
    update: XOR<AiInterviewQuestionUpdateWithoutInterviewInput, AiInterviewQuestionUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiInterviewQuestionCreateWithoutInterviewInput, AiInterviewQuestionUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewQuestionWhereUniqueInput
    data: XOR<AiInterviewQuestionUpdateWithoutInterviewInput, AiInterviewQuestionUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewQuestionUpdateManyWithWhereWithoutInterviewInput = {
    where: AiInterviewQuestionScalarWhereInput
    data: XOR<AiInterviewQuestionUpdateManyMutationInput, AiInterviewQuestionUncheckedUpdateManyWithoutInterviewInput>
  }

  export type AiInterviewQuestionScalarWhereInput = {
    AND?: AiInterviewQuestionScalarWhereInput | AiInterviewQuestionScalarWhereInput[]
    OR?: AiInterviewQuestionScalarWhereInput[]
    NOT?: AiInterviewQuestionScalarWhereInput | AiInterviewQuestionScalarWhereInput[]
    question_id?: IntFilter<"AiInterviewQuestion"> | number
    interview_id?: IntFilter<"AiInterviewQuestion"> | number
    question_text?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    question_type?: StringNullableFilter<"AiInterviewQuestion"> | string | null
    ai_generated?: BoolNullableFilter<"AiInterviewQuestion"> | boolean | null
    asked_at?: DateTimeNullableFilter<"AiInterviewQuestion"> | Date | string | null
  }

  export type AiInterviewResponseUpsertWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewResponseWhereUniqueInput
    update: XOR<AiInterviewResponseUpdateWithoutInterviewInput, AiInterviewResponseUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiInterviewResponseCreateWithoutInterviewInput, AiInterviewResponseUncheckedCreateWithoutInterviewInput>
  }

  export type AiInterviewResponseUpdateWithWhereUniqueWithoutInterviewInput = {
    where: AiInterviewResponseWhereUniqueInput
    data: XOR<AiInterviewResponseUpdateWithoutInterviewInput, AiInterviewResponseUncheckedUpdateWithoutInterviewInput>
  }

  export type AiInterviewResponseUpdateManyWithWhereWithoutInterviewInput = {
    where: AiInterviewResponseScalarWhereInput
    data: XOR<AiInterviewResponseUpdateManyMutationInput, AiInterviewResponseUncheckedUpdateManyWithoutInterviewInput>
  }

  export type AiInterviewResponseScalarWhereInput = {
    AND?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
    OR?: AiInterviewResponseScalarWhereInput[]
    NOT?: AiInterviewResponseScalarWhereInput | AiInterviewResponseScalarWhereInput[]
    response_id?: IntFilter<"AiInterviewResponse"> | number
    interview_id?: IntFilter<"AiInterviewResponse"> | number
    question_id?: IntFilter<"AiInterviewResponse"> | number
    response_text?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_audio_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    response_video_path?: StringNullableFilter<"AiInterviewResponse"> | string | null
    transcript?: StringNullableFilter<"AiInterviewResponse"> | string | null
    captured_at?: DateTimeNullableFilter<"AiInterviewResponse"> | Date | string | null
  }

  export type AiVoicePromptUpsertWithWhereUniqueWithoutInterviewInput = {
    where: AiVoicePromptWhereUniqueInput
    update: XOR<AiVoicePromptUpdateWithoutInterviewInput, AiVoicePromptUncheckedUpdateWithoutInterviewInput>
    create: XOR<AiVoicePromptCreateWithoutInterviewInput, AiVoicePromptUncheckedCreateWithoutInterviewInput>
  }

  export type AiVoicePromptUpdateWithWhereUniqueWithoutInterviewInput = {
    where: AiVoicePromptWhereUniqueInput
    data: XOR<AiVoicePromptUpdateWithoutInterviewInput, AiVoicePromptUncheckedUpdateWithoutInterviewInput>
  }

  export type AiVoicePromptUpdateManyWithWhereWithoutInterviewInput = {
    where: AiVoicePromptScalarWhereInput
    data: XOR<AiVoicePromptUpdateManyMutationInput, AiVoicePromptUncheckedUpdateManyWithoutInterviewInput>
  }

  export type AiVoicePromptScalarWhereInput = {
    AND?: AiVoicePromptScalarWhereInput | AiVoicePromptScalarWhereInput[]
    OR?: AiVoicePromptScalarWhereInput[]
    NOT?: AiVoicePromptScalarWhereInput | AiVoicePromptScalarWhereInput[]
    prompt_id?: IntFilter<"AiVoicePrompt"> | number
    interview_id?: IntFilter<"AiVoicePrompt"> | number
    prompt_text?: StringNullableFilter<"AiVoicePrompt"> | string | null
    prompt_audio_path?: StringNullableFilter<"AiVoicePrompt"> | string | null
  }

  export type AiInterviewCreateWithoutQuestionsInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutQuestionsInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutQuestionsInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutQuestionsInput, AiInterviewUncheckedCreateWithoutQuestionsInput>
  }

  export type AiInterviewResponseCreateWithoutQuestionInput = {
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
    interview: AiInterviewCreateNestedOneWithoutResponsesInput
  }

  export type AiInterviewResponseUncheckedCreateWithoutQuestionInput = {
    response_id?: number
    interview_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiInterviewResponseCreateOrConnectWithoutQuestionInput = {
    where: AiInterviewResponseWhereUniqueInput
    create: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput>
  }

  export type AiInterviewResponseCreateManyQuestionInputEnvelope = {
    data: AiInterviewResponseCreateManyQuestionInput | AiInterviewResponseCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type AiInterviewUpsertWithoutQuestionsInput = {
    update: XOR<AiInterviewUpdateWithoutQuestionsInput, AiInterviewUncheckedUpdateWithoutQuestionsInput>
    create: XOR<AiInterviewCreateWithoutQuestionsInput, AiInterviewUncheckedCreateWithoutQuestionsInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutQuestionsInput, AiInterviewUncheckedUpdateWithoutQuestionsInput>
  }

  export type AiInterviewUpdateWithoutQuestionsInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutQuestionsInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewResponseUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AiInterviewResponseWhereUniqueInput
    update: XOR<AiInterviewResponseUpdateWithoutQuestionInput, AiInterviewResponseUncheckedUpdateWithoutQuestionInput>
    create: XOR<AiInterviewResponseCreateWithoutQuestionInput, AiInterviewResponseUncheckedCreateWithoutQuestionInput>
  }

  export type AiInterviewResponseUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AiInterviewResponseWhereUniqueInput
    data: XOR<AiInterviewResponseUpdateWithoutQuestionInput, AiInterviewResponseUncheckedUpdateWithoutQuestionInput>
  }

  export type AiInterviewResponseUpdateManyWithWhereWithoutQuestionInput = {
    where: AiInterviewResponseScalarWhereInput
    data: XOR<AiInterviewResponseUpdateManyMutationInput, AiInterviewResponseUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AiInterviewCreateWithoutResponsesInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutResponsesInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutResponsesInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutResponsesInput, AiInterviewUncheckedCreateWithoutResponsesInput>
  }

  export type AiInterviewQuestionCreateWithoutResponsesInput = {
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
    interview: AiInterviewCreateNestedOneWithoutQuestionsInput
  }

  export type AiInterviewQuestionUncheckedCreateWithoutResponsesInput = {
    question_id?: number
    interview_id: number
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
  }

  export type AiInterviewQuestionCreateOrConnectWithoutResponsesInput = {
    where: AiInterviewQuestionWhereUniqueInput
    create: XOR<AiInterviewQuestionCreateWithoutResponsesInput, AiInterviewQuestionUncheckedCreateWithoutResponsesInput>
  }

  export type AiInterviewUpsertWithoutResponsesInput = {
    update: XOR<AiInterviewUpdateWithoutResponsesInput, AiInterviewUncheckedUpdateWithoutResponsesInput>
    create: XOR<AiInterviewCreateWithoutResponsesInput, AiInterviewUncheckedCreateWithoutResponsesInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutResponsesInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutResponsesInput, AiInterviewUncheckedUpdateWithoutResponsesInput>
  }

  export type AiInterviewUpdateWithoutResponsesInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutResponsesInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewQuestionUpsertWithoutResponsesInput = {
    update: XOR<AiInterviewQuestionUpdateWithoutResponsesInput, AiInterviewQuestionUncheckedUpdateWithoutResponsesInput>
    create: XOR<AiInterviewQuestionCreateWithoutResponsesInput, AiInterviewQuestionUncheckedCreateWithoutResponsesInput>
    where?: AiInterviewQuestionWhereInput
  }

  export type AiInterviewQuestionUpdateToOneWithWhereWithoutResponsesInput = {
    where?: AiInterviewQuestionWhereInput
    data: XOR<AiInterviewQuestionUpdateWithoutResponsesInput, AiInterviewQuestionUncheckedUpdateWithoutResponsesInput>
  }

  export type AiInterviewQuestionUpdateWithoutResponsesInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type AiInterviewQuestionUncheckedUpdateWithoutResponsesInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCreateWithoutCheating_eventsInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutCheating_eventsInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutCheating_eventsInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutCheating_eventsInput, AiInterviewUncheckedCreateWithoutCheating_eventsInput>
  }

  export type AiInterviewUpsertWithoutCheating_eventsInput = {
    update: XOR<AiInterviewUpdateWithoutCheating_eventsInput, AiInterviewUncheckedUpdateWithoutCheating_eventsInput>
    create: XOR<AiInterviewCreateWithoutCheating_eventsInput, AiInterviewUncheckedCreateWithoutCheating_eventsInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutCheating_eventsInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutCheating_eventsInput, AiInterviewUncheckedUpdateWithoutCheating_eventsInput>
  }

  export type AiInterviewUpdateWithoutCheating_eventsInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutCheating_eventsInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewCreateWithoutPosture_dataInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutPosture_dataInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutPosture_dataInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutPosture_dataInput, AiInterviewUncheckedCreateWithoutPosture_dataInput>
  }

  export type AiInterviewUpsertWithoutPosture_dataInput = {
    update: XOR<AiInterviewUpdateWithoutPosture_dataInput, AiInterviewUncheckedUpdateWithoutPosture_dataInput>
    create: XOR<AiInterviewCreateWithoutPosture_dataInput, AiInterviewUncheckedCreateWithoutPosture_dataInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutPosture_dataInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutPosture_dataInput, AiInterviewUncheckedUpdateWithoutPosture_dataInput>
  }

  export type AiInterviewUpdateWithoutPosture_dataInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutPosture_dataInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewCreateWithoutVoice_promptsInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    analysis?: AiInterviewAnalysisCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutVoice_promptsInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    analysis?: AiInterviewAnalysisUncheckedCreateNestedOneWithoutInterviewInput
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutVoice_promptsInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutVoice_promptsInput, AiInterviewUncheckedCreateWithoutVoice_promptsInput>
  }

  export type AiInterviewUpsertWithoutVoice_promptsInput = {
    update: XOR<AiInterviewUpdateWithoutVoice_promptsInput, AiInterviewUncheckedUpdateWithoutVoice_promptsInput>
    create: XOR<AiInterviewCreateWithoutVoice_promptsInput, AiInterviewUncheckedCreateWithoutVoice_promptsInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutVoice_promptsInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutVoice_promptsInput, AiInterviewUncheckedUpdateWithoutVoice_promptsInput>
  }

  export type AiInterviewUpdateWithoutVoice_promptsInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutVoice_promptsInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewCreateWithoutAnalysisInput = {
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    candidate: CandidateProfileCreateNestedOneWithoutInterviewsInput
    job: JobPostingCreateNestedOneWithoutInterviewsInput
    cheating_events?: AiInterviewCheatingEventCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewUncheckedCreateWithoutAnalysisInput = {
    interview_id?: number
    job_id: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
    cheating_events?: AiInterviewCheatingEventUncheckedCreateNestedManyWithoutInterviewInput
    posture_data?: AiInterviewPostureDataUncheckedCreateNestedManyWithoutInterviewInput
    questions?: AiInterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: AiInterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    voice_prompts?: AiVoicePromptUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type AiInterviewCreateOrConnectWithoutAnalysisInput = {
    where: AiInterviewWhereUniqueInput
    create: XOR<AiInterviewCreateWithoutAnalysisInput, AiInterviewUncheckedCreateWithoutAnalysisInput>
  }

  export type AiInterviewUpsertWithoutAnalysisInput = {
    update: XOR<AiInterviewUpdateWithoutAnalysisInput, AiInterviewUncheckedUpdateWithoutAnalysisInput>
    create: XOR<AiInterviewCreateWithoutAnalysisInput, AiInterviewUncheckedCreateWithoutAnalysisInput>
    where?: AiInterviewWhereInput
  }

  export type AiInterviewUpdateToOneWithWhereWithoutAnalysisInput = {
    where?: AiInterviewWhereInput
    data: XOR<AiInterviewUpdateWithoutAnalysisInput, AiInterviewUncheckedUpdateWithoutAnalysisInput>
  }

  export type AiInterviewUpdateWithoutAnalysisInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutAnalysisInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type UserCreateWithoutAi_generation_logsInput = {
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    CandidateProfile?: CandidateProfileCreateNestedOneWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAi_generation_logsInput = {
    user_id?: number
    name?: string | null
    email: string
    password_hash: string
    phone?: string | null
    created_at?: Date | string | null
    CandidateProfile?: CandidateProfileUncheckedCreateNestedOneWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAi_generation_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAi_generation_logsInput, UserUncheckedCreateWithoutAi_generation_logsInput>
  }

  export type UserUpsertWithoutAi_generation_logsInput = {
    update: XOR<UserUpdateWithoutAi_generation_logsInput, UserUncheckedUpdateWithoutAi_generation_logsInput>
    create: XOR<UserCreateWithoutAi_generation_logsInput, UserUncheckedCreateWithoutAi_generation_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAi_generation_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAi_generation_logsInput, UserUncheckedUpdateWithoutAi_generation_logsInput>
  }

  export type UserUpdateWithoutAi_generation_logsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CandidateProfile?: CandidateProfileUpdateOneWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAi_generation_logsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CandidateProfile?: CandidateProfileUncheckedUpdateOneWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiGenerationLogCreateManyUserInput = {
    log_id?: number
    service_used?: string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type UserRoleCreateManyUserInput = {
    role_id: number
  }

  export type AiGenerationLogUpdateWithoutUserInput = {
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiGenerationLogUncheckedUpdateWithoutUserInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiGenerationLogUncheckedUpdateManyWithoutUserInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    service_used?: NullableStringFieldUpdateOperationsInput | string | null
    request_payload?: NullableJsonNullValueInput | InputJsonValue
    response_payload?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyRoleInput = {
    user_id: number
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type JobPostingCreateManyCompanyInput = {
    job_id?: number
    title?: string | null
    description?: string | null
    location?: string | null
    posted_at?: Date | string | null
  }

  export type JobPostingUpdateWithoutCompanyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUpdateManyWithoutJobNestedInput
    requirements?: JobRequirementUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateWithoutCompanyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interviews?: AiInterviewUncheckedUpdateManyWithoutJobNestedInput
    requirements?: JobRequirementUncheckedUpdateManyWithoutJobNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobPostingUncheckedUpdateManyWithoutCompanyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    posted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCreateManyJobInput = {
    interview_id?: number
    candidate_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type JobRequirementCreateManyJobInput = {
    req_id?: number
    skill_id: number
    required_level?: string | null
  }

  export type ResumeVsJdMatchCreateManyJobInput = {
    match_id?: number
    resume_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewUpdateWithoutJobInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    candidate?: CandidateProfileUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutJobInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateManyWithoutJobInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    candidate_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobRequirementUpdateWithoutJobInput = {
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: SkillUpdateOneRequiredWithoutJob_requirementsNestedInput
  }

  export type JobRequirementUncheckedUpdateWithoutJobInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateManyWithoutJobInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResumeVsJdMatchUpdateWithoutJobInput = {
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    resume?: ResumeUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type ResumeVsJdMatchUncheckedUpdateWithoutJobInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchUncheckedUpdateManyWithoutJobInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    resume_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JobRequirementCreateManySkillInput = {
    req_id?: number
    job_id: number
    required_level?: string | null
  }

  export type ParsedResumeSkillCreateManySkillInput = {
    resume_id: number
  }

  export type JobRequirementUpdateWithoutSkillInput = {
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
    job?: JobPostingUpdateOneRequiredWithoutRequirementsNestedInput
  }

  export type JobRequirementUncheckedUpdateWithoutSkillInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRequirementUncheckedUpdateManyWithoutSkillInput = {
    req_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    required_level?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ParsedResumeSkillUpdateWithoutSkillInput = {
    resume?: ResumeUpdateOneRequiredWithoutParsed_resume_skillsNestedInput
  }

  export type ParsedResumeSkillUncheckedUpdateWithoutSkillInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
  }

  export type ParsedResumeSkillUncheckedUpdateManyWithoutSkillInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
  }

  export type AiInterviewCreateManyCandidateInput = {
    interview_id?: number
    job_id: number
    scheduled_at?: Date | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type ResumeCreateManyCandidateInput = {
    resume_id?: number
    file_path?: string | null
    parsed_text?: string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: Date | string | null
  }

  export type AiInterviewUpdateWithoutCandidateInput = {
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job?: JobPostingUpdateOneRequiredWithoutInterviewsNestedInput
    analysis?: AiInterviewAnalysisUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateWithoutCandidateInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysis?: AiInterviewAnalysisUncheckedUpdateOneWithoutInterviewNestedInput
    cheating_events?: AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewNestedInput
    posture_data?: AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewNestedInput
    questions?: AiInterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    voice_prompts?: AiVoicePromptUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type AiInterviewUncheckedUpdateManyWithoutCandidateInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    scheduled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResumeUpdateWithoutCandidateInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUpdateManyWithoutResumeNestedInput
    matches?: ResumeVsJdMatchUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutCandidateInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parsed_resume_skills?: ParsedResumeSkillUncheckedUpdateManyWithoutResumeNestedInput
    matches?: ResumeVsJdMatchUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateManyWithoutCandidateInput = {
    resume_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_text?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_json?: NullableJsonNullValueInput | InputJsonValue
    uploaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParsedResumeSkillCreateManyResumeInput = {
    skill_id: number
  }

  export type ResumeVsJdMatchCreateManyResumeInput = {
    match_id?: number
    job_id: number
    match_score?: number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ParsedResumeSkillUpdateWithoutResumeInput = {
    skill?: SkillUpdateOneRequiredWithoutParsed_resume_skillsNestedInput
  }

  export type ParsedResumeSkillUncheckedUpdateWithoutResumeInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
  }

  export type ParsedResumeSkillUncheckedUpdateManyWithoutResumeInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
  }

  export type ResumeVsJdMatchUpdateWithoutResumeInput = {
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
    job?: JobPostingUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type ResumeVsJdMatchUncheckedUpdateWithoutResumeInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResumeVsJdMatchUncheckedUpdateManyWithoutResumeInput = {
    match_id?: IntFieldUpdateOperationsInput | number
    job_id?: IntFieldUpdateOperationsInput | number
    match_score?: NullableFloatFieldUpdateOperationsInput | number | null
    matched_skills?: NullableJsonNullValueInput | InputJsonValue
    missing_skills?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewCheatingEventCreateManyInterviewInput = {
    event_id?: number
    event_type?: string | null
    confidence_score?: number | null
    detected_at?: Date | string | null
  }

  export type AiInterviewPostureDataCreateManyInterviewInput = {
    posture_id?: number
    timestamp?: Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewQuestionCreateManyInterviewInput = {
    question_id?: number
    question_text?: string | null
    question_type?: string | null
    ai_generated?: boolean | null
    asked_at?: Date | string | null
  }

  export type AiInterviewResponseCreateManyInterviewInput = {
    response_id?: number
    question_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiVoicePromptCreateManyInterviewInput = {
    prompt_id?: number
    prompt_text?: string | null
    prompt_audio_path?: string | null
  }

  export type AiInterviewCheatingEventUpdateWithoutInterviewInput = {
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCheatingEventUncheckedUpdateWithoutInterviewInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewCheatingEventUncheckedUpdateManyWithoutInterviewInput = {
    event_id?: IntFieldUpdateOperationsInput | number
    event_type?: NullableStringFieldUpdateOperationsInput | string | null
    confidence_score?: NullableFloatFieldUpdateOperationsInput | number | null
    detected_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewPostureDataUpdateWithoutInterviewInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUncheckedUpdateWithoutInterviewInput = {
    posture_id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewPostureDataUncheckedUpdateManyWithoutInterviewInput = {
    posture_id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posture_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiInterviewQuestionUpdateWithoutInterviewInput = {
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: AiInterviewResponseUpdateManyWithoutQuestionNestedInput
  }

  export type AiInterviewQuestionUncheckedUpdateWithoutInterviewInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: AiInterviewResponseUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AiInterviewQuestionUncheckedUpdateManyWithoutInterviewInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question_text?: NullableStringFieldUpdateOperationsInput | string | null
    question_type?: NullableStringFieldUpdateOperationsInput | string | null
    ai_generated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    asked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseUpdateWithoutInterviewInput = {
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: AiInterviewQuestionUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type AiInterviewResponseUncheckedUpdateWithoutInterviewInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseUncheckedUpdateManyWithoutInterviewInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiVoicePromptUpdateWithoutInterviewInput = {
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiVoicePromptUncheckedUpdateWithoutInterviewInput = {
    prompt_id?: IntFieldUpdateOperationsInput | number
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiVoicePromptUncheckedUpdateManyWithoutInterviewInput = {
    prompt_id?: IntFieldUpdateOperationsInput | number
    prompt_text?: NullableStringFieldUpdateOperationsInput | string | null
    prompt_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiInterviewResponseCreateManyQuestionInput = {
    response_id?: number
    interview_id: number
    response_text?: string | null
    response_audio_path?: string | null
    response_video_path?: string | null
    transcript?: string | null
    captured_at?: Date | string | null
  }

  export type AiInterviewResponseUpdateWithoutQuestionInput = {
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interview?: AiInterviewUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type AiInterviewResponseUncheckedUpdateWithoutQuestionInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiInterviewResponseUncheckedUpdateManyWithoutQuestionInput = {
    response_id?: IntFieldUpdateOperationsInput | number
    interview_id?: IntFieldUpdateOperationsInput | number
    response_text?: NullableStringFieldUpdateOperationsInput | string | null
    response_audio_path?: NullableStringFieldUpdateOperationsInput | string | null
    response_video_path?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    captured_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}